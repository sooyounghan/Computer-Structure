-----
### 예 : MIPS 명령어 집합 구조의 정적 다중 내보내기
-----
1. 정적 다중 내보기를 위한 간단한 2개 명령어 내보내기 MIPS 프로세서 가정
   - 이 프로세서에서 명령어 중 하나는 정수형 ALU 연산이나 분기 명령어가 될 수 있으며, 다른 명령어 하나는 적재 명령어나 저장 명령어가 될 수 있음
   - 사이클 당 2개의 명령어를 내보내려면 명령어들을 64비트 단위로 인출하고 해독할 수 있어야 함
   - 많은 정적 다중 내보내기 프로세서와 모든 VLIW 프로세서는 명령어 해독과 명령어 내보내기를 단순화하기 위해 동시에 내보내는 명령어의 레이아웃에 제한을 둠
     + 이 예에서는 명령어를 2개를 짝지어서 64비트 경계에 정렬하되 ALU나 분기 명령어가 먼저 나오도록 함
     + 두 명령어 중 하나를 사용할 수 없으면 nop으로 대체해야 함 : 따라서, 명령어는 항상 쌍으로 내보내기가 행해지며 이 중 하나는 nop일 가능성이 존재

2. 정적 2개 명령어 내보내기 파이프라인 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/a0605515-c5e6-4b71-84f4-d38585d8586d">
</div>

3. 정적 다중 내보내기 프로세서는 발생 가능성이 있는 데이터 해저드와 제어 해저드를 어떻게 다루느냐에 따라 몇 가지 존재
   - 어떤 설계에서는 컴파일러가 모든 해저드 제거, 코드 스케줄링, nop 삽입 등 전부 책임져서 하드웨어가 해저드를 검출하거나 지연을 만들 필요 없이 코드가 실행되도록 함
   - 하지만, 다른 설계에서는 명령어 쌍 안에서 종속성이 생기지 않게 하는 일만 컴파일러가 책임지고, 내보내기 패킷들 사이의 데이터 해저드 검출과 지연 생성은 하드웨어가 함
   - 그렇다고 하더라도 해저드가 발생하면 종속적인 명령어가 들어있는 내보내기 패킷은 전체가 다 지연되는 것이 일반적
   - 소프트웨어가 모든 해저드를 처리하든지 혹은 서로 다른 내보내기 패킷 사이의 해저드 일부만을 감소시키든지 간에, 외형성 커다란 명령어 하나가 복수의 연산을 수행하는 것으로 보임

4. ALU 명령어와 데이터 전송 명령어를 병렬로 내보내기 위해서 일반적인 해저드 검출 회로와 지연 회로 이외 추가로 필요한 첫 번째 하드웨어가 레지스터 파일 추가 포트
<div align="center">
<img src="https://github.com/user-attachments/assets/9e3171fc-e31c-494c-b826-7669cfd741de">
</div>

   - 한 클럭 사이클에 ALU 연산을 위해 두 레지스터를 읽어야 되고, 저장 명령어를 위해 두 레지스터를 더 읽어야 되며, ALU 연산을 위해 하나의 쓰기 포트, 또 적재 명령어를 위해 하나의 쓰기 포트가 더 필요
   - ALU는 ALU 명령어를 연산해야 되므로 데이터 전송 명령어의 실제 주소를 계산하기 위해서는 독자적 덧셈기가 필요
   - 이 같은 추가 자원 없이는 2개 내보내기 파이프라인은 구조적 해저드를 격께 됨

5. 이 2개 명령어 내보내기 프로세서가 성능을 2배까지 높일 수 있지만, 이를 위해서는 2배의 명령어가 실행 중 중첩되어야 하고, 이러한 추가적 중첩은 데이터 해저드나 제어 해저드에 의한 성능 저하를 증가시킴
   - 에를 들면, 단순한 다섯 단계 파이프라인에서 적재 명령어는 한 클럭 사이클의 사용 지연(Use Latency)이 있어서, 바로 다음 명령어 하나는 지연 없이 적재 결과를 사용할 수 없음
     + 파이프라인을 지연시키지 않기 위해 필요한 적재 명령어와 적재 결과를 사용하는 명령어 사이의 최소 간격
   - 2개 내보내기 다섯 단계 파이프라인에서도 적재 명령어 결과는 다음 클럭 사이클에서 사용될 수 없음 : 다음 2개 명령어가 적재 결과를 사용할 수 없다는 것을 의미
   - 더구나 단순한 다섯 단계 파이프라인에서는 사용 지연이 없었던 ALU 명령어도 이제는 1개 명령어의 사용 지연을 갖게 됨 : 이 명령어와 쌍으로 묶인 적재나 저장 명령어는 연산 결과를 사용할 수 없음
   - 다중 내보내기 프로세서에서 사용 가능한 병렬성을 효과적으로 활용하기 위해서는 좀 더 의욕적인 컴파일러나 하드웨어 스케일링 기법이 요구되고, 정적 다중 내보내기는 컴파일러가 이러한 역할을 해주기가 요구

6. 예) 간단한 다중 내보내기 코드 스케줄링
   - MIPS용 정적 2개 내보내기 파이프라인
<div align="center">
<img src="https://github.com/user-attachments/assets/224dd65c-c0f4-4b50-a45e-5bb829c89f68">
</div>

   - 가능한 많은 파이프라인 지연을 피할 수 있게 명령어 재정렬 (예측 분기가 사용되고 제어 해저드는 하드웨어가 처리한다고 가정)
     + 첫 3개 명령어에 데이터 종속성이 있고, 마지막 2개의 명령어 사이에 역시 데이터 종속성 존재
     + 이 명령어를 위한 가장 좋은 스케줄
<div align="center">
<img src="https://github.com/user-attachments/assets/3ade91ab-0e22-48c0-acfb-51128a0afc52">
</div>

   - 단 하나의 명령어 쌍만이 내보내기 슬롯 2개를 모두 사용하고 있음
   - 따라서, 순환문 반복에 네 클럭이 걸림
   - 즉, 5개 명령어를 실행하는데 네 클럭 사이클이 소요됨
   - 따라서, 가장 좋은 경우에는 CPI가 0.5인데 반해, 이 경우 CPI가 0.8이라는 실망 스러운 결과가 나옴
   - IPC로 말하자면 가장 좋은 경우는 8인데 반해, 이 경우 1.25 밖에 되지 않음
   - CPI나 IPC를 계산할 때, nop은 유용한 명령어로 취급하지 않음 : 유용한 명령어로 취급하면 CPI 값은 좋아지지만 성능은 좋아지지 않음

7. 순환문에서 좀 더 좋은 성능을 얻기 위한 한 가지 중요한 컴파일러 기법 : 순환문 펼치기(Loop Unrolling)
   - 순환문 펼치기 : 배열에 접근하는 순환문에서 더 좋은 성능을 얻기 위한 기술로, 순환몸 몸체를 여러 벌 복사해서 서로 다른 반복에 속한 명령어들을 같이 스케줄링
   - 따라서, 가용한 ILP가 많아짐

8. 예) 다중 내보내기 파이프라인을 위한 순환문 펼치기
   - MIPS용 정적 2개 내보내기 파이프라인
<div align="center">
<img src="https://github.com/user-attachments/assets/224dd65c-c0f4-4b50-a45e-5bb829c89f68">
</div>

   - 순환문 인덱스는 4의 배수
     + 순환문을 지연 없이 스케줄링하기 위해서는 순환문 본체를 4번 만들 필요가 있음
     + 순환문 펼치기를 하고, 불필요한 순환문 오버헤드 명령어를 없애면 순환문은 4개의 lw, add, sw와 1개의 addi, bne을 가짐
     + 순환문 펼치기 후 스케줄링 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/550daafb-70d3-48ad-8eae-920937fbd87f">
</div>

   - 펼치기 과정 도중 컴파일러는 레지스터들을 추가로($t1, $t2, $t3) 사용하는데, 이런 과정을 레지스터 재명명(Register Renaming)이라 고함
     + 레지스터 재명명 : 반종속성을 없애기 위해 컴파일러나 하드웨어가 레지스터 이름을 다시 붙이는 것
     + 목적 : 진정한 데이터 종속성은 아니지만, 잠재적 해저드의 원인이 되거나 컴파일러가 코드를 유연하게 스케줄링하는 것을 방해하는 종속성을 없애는 것

   - $t0만을 사용하여, 펼치기를 한 경우
     + lw $t0, 0($1) / addu $t0, $t0, $s2 / sw $t0 4($t1)으로 구성된 명령어 그룹이 여러번 나타날 것
     + 모두 $t0를 사용하기는 하지만, 실제로 각 명령어 그룹은 완전히 독립적일 것
     + 어떤 데이터 값도 한 명령어 그룹과 다른 명령어 그룹 사이 흘러가지 않는데, 이를 반종속성(Anti-Dependence) 또는 이름 종속성(Name-Dependence)
       * 이는 실제 데이터 종속성이 아니고, 순전히 같은 이름을 반복 사용함으로써 강요되는 순서
       * 반종속성, 이름종속성 : 두 명령어 사이에 값이 전달되는 진정한 종속성 때문에 지켜야 되는 순서가 아니라 같은 이름(레지스터)을 재사용하므로 강요되는 순서

   - 순환문 펼치기 과정에서 레지스터들을 재명명함으로써 명령어들이 독립적으로 되어서, 컴파일러가 명령어들을 쉽게 옮길 수 있고, 결과적으로 잘 스케줄링 할 수 있음
   - 재명명 과정은 이름 종속성만 없애고 진정한 종속성은 유지

   - 순환문의 14개 명령어 중 12개 명령어가 쌍으로 실행 : 네 번의 순환문 반복에 여덟 클럭, 즉 반복당 두 클럭이 걸리므로 CPI 8 / 14 = 0.57이 됨
     + 순환문을 펼치고 스케줄링한 후 2개 내보내기를 하면 거의 2배 성능 향상을 얻을 수 있는데, 일부는 순환문 제어 명령어들을 줄인 데 기인하고 또 일부는 2개 내보내기 실행을 한 결과
     + 이 같은 성능 향상을 위해 지불하는 대가는 임시 레지스터가 하나가 아닌 4개나 사용되어야 하고, 코드 크기가 상당히 증가
