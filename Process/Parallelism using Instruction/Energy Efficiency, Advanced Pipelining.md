-----
### 에너지 효율성과 고급 파이프라닝
-----
1. 동적 다중 내보내기와 추정 방법을 통해 명령어 수준 병렬성을 더 많이 이용하면서 생기는 부정적 측면은 전력 효율성
   - 매번 등장하는 신기술은 더 많은 트랜지스터를 사용하여 성능을 높일 수 있게 하였으나, 매우 비효율적으로 성능을 높인 경우가 많았음
   - 전력 장벽에 부딪히게 되자, 전처럼 깊은 파이프라인이나 적극적 추정 방법을 사용하지 않는 비교적 단순한 프로세서 여러 개를 칩 하나에 넣는 설계가 나타나고 있음

2. 단순한 프로세서들이 정교한 프로세서들에 비해 빠르지는 않지만 단위 에너지(줄, Joule) 당 성능이 더 좋으므로, 트랜지스터의 개수보다 소모 전력에 의해 제한을 받는 설계에서는 칩당 성능이 더 좋다는 믿음이 있음
3. 과거와 최신 마이크로프로세서들의 파이프라인 단계 수, 내보내는 명령어 개수, 추정 수준, 클럭 속도, 칩당 코어 개수, 소모 전력을 보여주는 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/85104215-adb9-4a33-a708-52a8a180fc84">
</div>

   - 회사들이 다중코어 설계 쪽으로 진행됨에 있어 파이프라인 단계 수와 소모 전력이 감소함을 볼 수 있음

4. 결과 쓰기 유닛은 레지스터 파일뿐만 아니라 메모리 갱신도 제어
   - 어떤 동적 스케줄 프로세서는 실행 중에 곧바로 레지스터 파일을 갱신하는데, 이 경우 레지스터를 갱신하는 명령어가 더 이상 추정이 아니고 추정 성공 여부가 확실할 때까지 별도 레지스터를 사용하여 재명명 기능을 구현하고 레지스터의 옛 복사본을 간직하게 됨
   - 어떤 프로세서는 결과값을 재정렬 버퍼에 버퍼링하고, 레지스터 파일의 실제 갱신은 결과 쓰기의 일부분으로 나중에 일어남
   - 메모리 저장은 결과 쓰기 때까지 저장 버퍼(Store Buffer)나 재정렬 버퍼에 임시 저장되어야 함
   - 결과 쓰기 유닛은 버퍼가 합법적 주소(Valid Address)와 합법적 데이터를 갖고 있으면서 저장 명령어가 더 이상 예측 분기에 종속적이 아닐 때만 저장 명령어가 버퍼에서 메모리로 쓰는 것을 허용

5. 무정지 캐시(Non-Blocking Cache)를 사용하면 메모리 접근 성능이 좋아짐
   - 무정지 캐시는 캐시 실패 동안에도 캐시 접근 서비스를 계속함
   - 비순차 실행 프로세서는 캐시 실패 동안에도 명령어를 계속 실행하므로, 무정지 캐시를 필요로 함
