-----
### 동적 파이프라인 스케줄링
-----
1. 동적 파이프라인 스케줄링은 다음에 어떤 명령어를 실행할 것인가를 결정하는데, 지연을 피하기 위해 명령어들을 재정렬하기도 함
   - 그러한 프로세서의 파이프라인은 명령어 인출 및 내보내기 유닛, 다수의 기능 유닛, 결과 쓰기 유닛(Commit Unit)의 세 가지 유닛으로 나누어짐
     + 결과 쓰기 유닛 : 동적 파이프라인 혹은 비순차 실행 파이프라인에서 연산의 결과를 프로그래머가 볼 수 있는 레지스터나 메모리에 언제 보내는 것이 안전할지 결정하는 유닛
<div align="center">
<img src="https://github.com/user-attachments/assets/d1d8fa51-229a-4843-b571-7e8f1812f48b">
</div>

   - 첫 번쨰 유닛은 명령어를 가져오고 해독하고 각각의 명령어를 실행 단계 해당 기능 유닛에 보냄
   - 각 기능 유닛은 대기 영역(Reservation Station)이라 불리는 버퍼를 가지고 있는 이 대기 영역은 피연산자와 연산자를 가지고 있음
     + 대기 영역 : 연산자와 피연산자를 가지고 있는 기능 유닛 내 버퍼
   - 버퍼에 모든 피연산자가 준비되고 실행할 기능 유닛이 준비되어 있으면, 연산을 실행
   - 연산이 끝나면, 그 결과는 결과 쓰기 유닛뿐만 아니라 이 결과를 기다리고 있는 대기 영역에도 보내짐
   - 결과 쓰기 유닛은 결과를 버퍼링하고 있다가 안전할 때, 결과값을 레지스터 파일이나 메모리(저장 명령어의 경우)에 씀
     + 결과 쓰기 유닛에 있는 이 버퍼는 재정렬 버퍼(Reorder Buffer)라고 불리는데, 피연산자들을 공급하는 역할을 함
     + 재정렬 버퍼 : 동적 스케줄 프로세서에서 결과값을 메모리나 레지스터에 저장해도 안전할 때까지 보관하는 버퍼
     + 피연산자는 정적 스케줄 파이프라인에서 전방전달 회로가 했던 것과 같은 방법으로 공급 : 일단 결과값이 레지스터 파일에 써지면 정상적인 파이프라인에서와 같이 레지스터 파일로부터 직접 읽을 수 있음

2. 피연산자를 대기 영역에 버퍼링하는 방법과 결과값을 재정렬 버퍼에 임시 저장하는 방법을 같이 사용하면, 일종의 레지스터 재명명이 됨
   - 즉, 지난번 순환문 펼치기에서 컴파일러가 사용했던 것과 같은 기술
   - 개념적 동작 과정
     + 명령어 가 내보내질 떄, 명령어는 해당 기능 유닛의 대기 영역으로 복사되며, 피연산자 중 레지스터 파일이나 재정렬 버퍼에 있는 것은 즉시 복사
       * 명령어는 모든 피연산자와 실행 유닛이 사용 가능할 때 까지 버퍼링
       * 내보내진 명령어는 레지스터에 있는 피연산자가 더 이상 필요 없기 때문에, 이 레지스터에 쓰기를 해야 된다면 그냥 덮어써도 됨
     + 만약 피연산자가 레지스터 파일이나 재정렬 버퍼에 없다면, 기능 유닛이 생성할 때까지 기다려야 함
       * 결과를 만들어 낼 기능 유닛의 이름을 추적하다가, 언젠가 그 기능 유닛이 결과를 만들면 레지스터를 우회하여 기능 유닛에서 기다리고 있는 대기 영역으로 직접 복사

   - 이 단계들은 재정렬 버퍼와 대기 영역을 효과적으로 사용해서 레지스터 재명명을 구현하고 있음

3. 개념적으로 동적 스케줄 파이프라인을 프로그램의 데이터 흐름 구조 분석으로 생각할 수 있음
   - 프로세서는 프로그램의 데이터 흐름 순서를 유지하는 어떤 순서에 따라 명령어를 실행 : 명령어 인출 순서와 다르게 실행될 수 있으므로 이 같은 실행 형태를 비순차 실행(Out-of-Order Execution)이라 부름
     + 비순차 실행 : 실행할 수 없는 명령어 때문에 뒤의 명령어들이 기다리지 않게 되는 파이프라인 실행의 상황
   - 프로그램이 단순한 순차 실행 파이프라인에서 실행되는 것처럼 만들려면, 명령어 인출 및 해독 유닛이 명령어들을 순서대로 내보내야 하고(이렇게 하면 종속성 추적이 가능하게 됨), 쓰기 유닛은 프로그램 인출 순서대로 레지스터나 메모리에 결과를 써야 하는데, 이러한 보수적인 방식을 순차 결과 쓰기(In-Order Commit)라고 함
     + 순차 결과 쓰기 : 파이프라인 실행의 결과를 명령어 인출과 같은 순서로 프로그래머가 볼 수 있는 상태 소자에 쓰는 결과 쓰기 방식
   - 순차적으로 쓰므로, 예외가 발생했을 때 컴퓨터가 마지막으로 실행된 명령어를 찾아낼 수 있으며, 예외를 일으킨 명령어보다 앞에 있던 명령어들이 쓴 레지스터들만 값이 변경
   - 파이프라인의 전단부, 즉 명령어 인출 및 내보내기 부분과 후단부, 즉 결과 쓰기 부분은 순서대로 실행되지만, 기능 유닛들은 필요한 데이터가 가용하면 언제나 실행을 자유롭게 시작할 수 있음 : 오늘날 모든 동적 스케줄 파이프라인은 순차 결과 쓰기를 사용

4. 동적 스케줄링은 하드웨어 기반 추정(Hardware-Based Speculation)을 포함하도록 확장되는 경우가 많음
   - 특히 분기의 결과에 대해서는 더욱 그러하며, 동적 스케줄 프로세서는 분기의 방향을 예측함으로써 예상 경로를 따라 명령어 인출과 실행을 계속할 수 있음
   - 명령어들은 순서대로 결과를 쓰기 대문에, 예상 경로상의 명령어들이 결과를 쓰기 전 분기 예측의 정확성 여부를 판단할 수 있음
   - 추정 동적 스케줄 파이프라인은 적재 주소에 대한 추정도 지원할 수 있어, 적재-저장 재정렬을 허용하고, 결과 쓰기 유닛을 사용하여 잘못된 추정을 피할 수 있음

5. 비순차 실행을 하면 이전 파이프라인 구조에서는 보지 못했던 새로운 파이프라인 해저드가 발생
   - 이름 종속성(Name Dependence)은 두 명령어가 같은 레지스터나 메모리 주소[이름(name)]를 사용할 때 발생하지만, 그 이름으로 연관된 두 명령어 사이에 데이터 흐름은 없음
   - 프로그램 순서상 앞선 명령어 i와 뒤따르는 명령어 j가 있을 때, 이들 사이에 있을 수 있는 이름 종속성에는 두 종류가 존재
     + 명령어 i와 명령어 j 사이의 반종속성(Anti-Dependecne)은 명령어 i가 읽는 레지스터나 메모리 주소에 명령어 j가 쓸 때 발생 : i가 올바른 값을 읽게 하려면 원래 실행 순서를 유지해야 함
     + 쓰기 종속성(Output Dependence)은 명령어 i와 j가 똑같은 레지스터나 메모리 주소를 쓸 때 일어나며, 원래의 명령어 간 실행 순서가 지켜져야 마지막에 쓰인 값이 명령어 j가 쓴 값이라는 것을 보장하게 됨

   - 앞에서 본 파이프라인 해저드는 진성 데이터 종속성(True Data Dependence)라 불리는 종속성 결과
     + 예를 들어, 다음 코드에서 swc1과 addiu 사이에 레지스터 x1이 관련된 반종속성이 존재하고, lwc1과 add.s 사이에는 레지스터 f0와 관련된 진성 데이터 종속성이 존재
     + 같은 반복 내 명령어들 사이에는 쓰기 종속성이 존재하지 않지만, 이 순환문의 다른 반복 사이에는 쓰기 종속성이 존재
     + 예를 들면, 첫 번째 반복의 addiu 명령어와 두 번쨰 반복의 addiu 명령어 사이에 쓰기 종속성이 존재
<div align="center">
<img src="https://github.com/user-attachments/assets/b10e118d-fbbe-4701-b41f-683cc5bc275d">
</div>

   - 명령어 사이에 이름 종속성이나 데이터 종속성이 존재하고, 이들 사이의 거리가 매우 가까워서 중첩 실행이 종속성에 연관된 피연산자에의 접근 순서를 바꾸게 되면 파이프라인 해저드가 발생
   - 이 같은 사실로부터 좀 더 직관적인 파이프라인 해저드 이름 명명
     + 반종속성은 WAR(Write-After-Read) 해저드를 일으킴
     + 쓰기 종속성은 WAW(Write-After-Write) 해저드를 일으킴
     + 진성 데이터 종속성은 RAW(Read-After-Write) 해저드를 일으킴

   - WAR와 WAW 해저드는 모든 명령어가 순차적으로 실행되었을 뿐만 아니라 레지스터-레지스터 명령어는 마지막 파이프라인 단계에서만 쓰기를 하고, 적재와 저장 명령어 데이터 접근은 항상 같은 파이프라인 단계에서 일어났기 때문에 보지 못함

6. 컴파일러도 데이터 종속성이 있는 명령어들 주변의 코드를 스케줄할 수 있는데, 왜 슈퍼스칼라 프로세서는 굳이 동적 스케줄링을 하는가?
   - 메모리 계층 구조에서 캐시 실패는 예측 불가능한 지연을 일으킴 : 동적 스케줄링은 프로세서로 하여금 지연이 끝나기를 기다리는 동안 명령어를 계속 실행할 수 있도록 하여 이런 지연의 일부를 감출 수 있음
   - 만약 프로세서가 동적 분기 예측을 사용하여 분기 결과에 대해 추정한다면, 컴파일 시에는 명령어의 정확한 순서를 알 수 없음 : 이 순서는 분기에 대한 예측과 실제 행동 모두에 의존하기 때문이며, 더 많은 ILP(Instruction-Level Parallelism)를 얻기 위해 동적 스케줄링을 하지 않으면서, 동적 추정을 사용하면 추정의 이득을 크게 제한하게 됨
   - 파이프라인 지연과 내보내기 폭이 구현마다 달라지면, 코드를 가장 잘 컴파일 하는 방법도 달라지게 됨
     + 예를 들면, 종속적 명령어 시퀀스를 스케줄링하는 방법은 내보내기 폭과 지연에 대해 영향을 받음
     + 파이프라인 구조는 컴파일러 기반의 레지스터 재명명 과정 뿐 아니라 지연을 피하기 위한 순환문 펼치기 횟수에도 영향을 줌
     + 동적 스케줄링은 하드웨어가 이런 세부 사항을 신경쓰지 않아도 되게 해줌
     + 따라서, 사용자나 소프트웨어 공급자는 같은 명령어 집합이라도 구현에 따라 프로그램이 달라져야 하는 문제를 걱정할 필요가 없음
     + 마찬가지로, 물려받은 오래된 코드는 다시 컴파일하지 않아도 새로운 구현에 의해 얻어지는 대부분의 이득을 취할 수 있음

7. 파이프라이닝과 다중 내보내기는 둘 다 최고의 명령어 처리량을 증가시키고, 명령어 수준 병렬성(ILP)을 활용하려는 기술
   - 그러나 종속성이 해결될 때까지, 프로세서가 기다려야 하는 경우가 많으므로, 프로그램의 데이터 종속성 / 제어 종속성은 지속적으로 얻을 수 있는 성능의 상한성을 결정함
   - ILP을 활용하기 위한 소프트웨어 중심 접근 방법은 컴파일러 능력에 의존해서 이런 종속성을 찾아내고 그 영향을 줄이는 반면, 하드웨어 중심의 접근 방법은 파이프라인과 내보내기 메커니즘의 확장에 의존
   - 컴파일러 또는 하드웨어의 추정을 하면 예측을 통해 이용할 수 있는 ILP의 양을 증가시킬 수 잇지만, 틀린 추정은 성능을 저하시킬 수 있음

8. 최신 고성능 마이크로프로세서들은 한 클럭에 여러 명령어를 내보낼 수 있지만, 그러한 내보내기율을 유지하는 것은 매우 어려움
   - 예를 들면, 매 클럭 4 ~ 6개의 명령어를 유지하는 응용이 힘든 원인
   - 파이프라인 내에서 성능의 주요 병목은 제거할 수 없는 종속성에 기인
     + 이 종속성 때문에 명령어 간의 병렬성은 줄고, 지속적 내보내기율도 줄게 됨
     + 비록 진정한 데이터 종속성에 대해서는 할 수 있는 것이 없지만, 많은 경우 컴파일러나 하드웨어는 종속성이 존재한느지 그렇지 않은지에 대해 정확히 알지 못하므로 종속성이 존재한다고 보수적으로 가정해야 함
     + 예를 들면, 포인터를 사용하는 코드, 특히 동의어 문제(Aliasing)가 생길 수 있는 방식으로 포인터를 사용하면 잠재적 종속을 더 많이 만들게 되며, 반면 규칙적 배열 접근은 컴파일러가 종속성이 없다고 판단할 수 있게 하기도 함
     + 마찬가지로, 실행할 때나 컴파일할 때 정확히 예측할 수 없는 분기는 ILP를 이용하는 능력에 제한을 가하게 됨 : 더 많은 ILP가 있음에도 불구하고 멀리 떨어져 있는 ILP를 찾을 수 없는 컴파일러나 하드웨어 능력 한계 때문에 활용하지 못하는 경우도 존재

   - 메모리 계층구조에서의 손실이 파이프라인을 충분히 이용할 능력을 제한 : 어떤 메모리 시스템 지연은 감춰질 수 있지만, 제한된 양의 ILP를 가지고는 감출 수 있는 지연의 양에 한계가 존재
