-----
### 파이프라이닝 개요
-----
1. 파이프라이닝(Pipelining) : 여러 명령어가 중첩되어 실행되는 구현 기술로, 오늘날 아주 보편적인 기술
2. 파이프라이닝의 예 : 세탁
   - 파이프라이닝되지 않은(Non-Pipelined) 세탁 방법
     + 세탁기에 한 뭉치의 더러운 옷을 넣음
     + 세탁기 작동이 끝나면 젖은 옷을 건조기에 넣음
     + 건조기 작동이 끝나면 건조된 옷을 탁자 위에 놓고 접음
     + 접는 일이 끝나면 같은 방 친구에게 옷을 옷장에 넣어달라고 부탁

   - 파이프라이닝 방법
     + 첫 번째 묶음의 세탁이 끝나서 건조기를 넣은 후, 두 번째 더러운 옷 묶음을 세탁기에 넣음
     + 첫 번째 묶음이 건조되면 탁자 위에 놓고 접기 시작하고, 젖은 옷 묶음은 건조기에,  또 다음 더러운 옷 묶음은 세탁기에 넣음
     + 다음은 친구에게 첫 번째 묶음을 옷장에 넣어 줄 것을 부탁하고 두 번째 묶음을 접기 시작하며, 세 번째 묶음을 건조기에, 네 번째 묶음을 세탁기에 넣음
     + 이 시점에서는 모든 과정[파이프라이닝에서는 단계(Stage)라고 함]이 동시에 작동하며, 각 단계마다 별개의 자원을 가지고 있으면, 작업들을 파이프라이닝 할 수 있으므로, 시간이 훨씬 덜 걸림
<div align="center">
<img src="https://github.com/user-attachments/assets/e0c4fe40-e474-4bc2-86ca-a1f1c65b4855">
</div>

   - 역설적인 점 : 더러운 양말 하나를 세탁기에 넣고 건조한 후 접어서 옷장에 넣을 때까지의 시간은 파이프라이닝을 한다고 더 짧아지는 것이 아님
   - 일감이 많을 때 파이프라이닝이 더 빠른 이유는 모든 것이 병렬로 동작하며, 따라서 같은 시간에 더 많은 일감을 처리할 수 있기 때문임
   - 즉, 파이프라이닝은 세탁 시스템의 처리량을 증가시킴
     + 그러므로, 파이프라이닝이 일감 하나를 끝내는데 걸리는 시간을 단축하지는 못하지만, 해야 할 빨래가 많을 경우 처리량이 증가하므로 일을 끝내는 데 전체 시간을 단축시킴

3. 만약 모든 단계가 거의 같은 시간이 걸리며, 할 일이 충분히 많다면 파이프라이닝에 의한 속도 향상은 파이프라인 단계 수와 동일
   - 세탁, 건조, 개기, 넣기의 4단계가 있으므로 이 경우 단계 수는 4임
   - 그러므로, 파이프라인 세탁소는 파이프라이닝되지 않은 경우에 비해 4배 빠를 수 있음
     + 따라서 20묶음을 처리하려면 한 묶음 처리 시간의 5배가 걸릴 것
     + 반면에, 20묶음을 순차적인 세탁소에서 처리하려면, 한 묶음 처리 시간의 20배가 걸림
     + 위 그림에서는 4배가 아닌 2.3배 밖에 빠르지 못함 : 묶음이 4개 밖에 없기 때문임 : 파이프라인 버전에서의 작업과 시작과 끝 부분에서는 파이프라인이 완전히 차 있지 않음을 알 수 있음
     + 즉, 할 일의 수가 파이프라인 단계의 수에 비해 많지 않을 경우에는 이 같은 시작 시간과 마지막 시간이 성능에 영향을 미침
     + 즉, 일감의 수가 4보다 훨씬 크다면 대부분의 시간에 단계들이 다 차있을 것이고, 따라서 처리량은 4배 가까이 증가할 것

4. 명령어 실행을 파이프라이닝한 프로세서에도 같은 원리가 적용 : MIPS 명령어는 전통적으로 다섯 단계가 걸림
   - 메모리에서 명령어를 가져옴
   - 명령어를 해독하는 동시에 레지스터를 읽음 : MIPS 명령어는 형식이 규칙적이므로 읽기와 해독이 동시에 일어날 수 있음
   - 연산을 수행하거나 주소를 계산
   - 데이터 메모리에 있는 피연산자에 접근
   - 결과값을 레지스터에 씀
  
5. 예) 단일 사이클 대 파이프라인의 성능
   - 가상의 파이프라인 (lw(load word), sw(store word), add(add), sub(subtract), and(AND), or(OR), slt(set on less than), beq(branch on equal) 총 8개 명령어만 가정) 가정
   - 단일 사이클 구현에서 명령어 사이의 평균 시간을 파이프라인 구현 경우와 비교
     + 단일 사이클 구현에서는 모든 명령어가 한 클럭 사이클에 실행
     + 이 예제에서는 주요 기능 동작 시간은 다음과 같이 가정
       * 메모리 접근 : 200 ps
       * ALU 연산 : 200 ps
       * 레지스터 파일 읽기나 쓰기 : 100 ps
     + 단일 사이클 모델에서는 모든 명령어가 한 클럭 사이클 내 실행되므로 가장 느린 명령어를 수용할 수 있을 만큼 클럭 사이클이 충분히 길어야 함

   - 8개 명령어 각각에 필요한 시간
<div align="center">
<img src="https://github.com/user-attachments/assets/fbdcaf27-60a1-4d4b-8b1a-4929d8927678">
</div>

   - 단일 사이클 설계는 가장 느린 명령어를 수용해야 하며, 가장 느린 명령어는 lw
   - 따라서, 모든 명령어에 필요한 시간은 800 ps
   - lw 명령어 3개의 파이프라이닝 되지 않은 실행과 파이프라인 실행 비교
<div align="center">
<img src="https://github.com/user-attachments/assets/f9ff76fb-42f9-4868-b7a5-1640bd0be721">
</div>

   - 파이프라이닝되지 않은 설계에서 첫 번째 명령어와 네 번쨰 명령어 사이의 시간 : 3 X 800 ps = 2400ps
   - 파이프라인 구현에서는 모든 단계가 한 클럭 사이클에 처리
     + 따라서, 클럭 사이클은 가장 느린 동작을 수용할만큼 충분히 길어야 함
     + 단일 사이클 설계에서 어떤 명령어들은 500 ps밖에 걸리지 않지만, 클럭 사이클 시간이 최악의 경우에 맞추어 800 ps가 되었듯이, 파이프라인 클럭 실행 사이클도 어떤 단계는 100 ps 밖에 안걸리지만, 최악의 경우 200 ps가 되어야 함
   - 파이프라이닝은 아직도 4배 성능 향상을 제공하여, 첫 번째 명령어와 네 번째 명령어 사이의 시간은 3 X 200 = 600 ps

6. 속도 향상에 관한 논의 식
   - 단계들이 완벽하게 균형을 이루고 있으면, 파이프라인 프로세서에 명령어 사이의 시간 (이상적 조건을 가정)
<div align="center">
<img src="https://github.com/user-attachments/assets/e4c84547-ce98-45f1-bac0-06ac21109f24">
</div>

   - 이상적 조건 하에서 매우 많은 명령어를 실행하는 경우, 파이프라이닝에 의한 속도 향상은 파이프 단계 수와 거의 같음
     + 따라서, 다섯 단계 파이프라인은 거의 5배 빨라짐
   - 위 식에 따르면 다섯 단계 파이프라인은 800 ps의 파이프라이닝되지 않은 시스템보다 5배 향상된 성능을 제공해야 함
     + 즉, 클럭 사이클이 160ps가 되어야 함
     + 그러나 예제의 단계들은 완벽하게 균형이 잡혀있지 않으며, 더구나 파이프라이닝은 어느 정도의 오버헤드를 유발
     + 이런 이유로 파이프라이닝 프로세서에서의 명령어당 시간이 가능한 촤소값보다 커져서 속도 향상은 파이프라이닝 단계 수보다 작아짐

   - 더구나 4배의 성능 향상이 있다는 예제의 주장은 명령어 3개의 전체 실행 시간이 반영되지 않아서 1400 ps 대 2400 ps
     + 이는 물론 실행 명령어가 많지 않기 때문임
     + 명령어의 수를 증가시킬 경우
       * 1,000,003개의 명령어로 확장 : 위 파이프라이닝에서 1,000,000개의 명령어를 추가하면 되는데, 명령어 하나당 200 ps가 추가되므로, 전체 실행 시간은 1,000,000 X 200 ps + 1400 ps = 200,001,400 ps
       * 파이프라이닝 되지 않은 경우 1,000,000개의 명령어 추가 : 각 명령어는 800 ps씩 걸림 : 따라서, 전체 실행 시간은 1,000,000 X 800 ps + 2400 ps = 800,002,400 ps
       * 이 같은 이상적 조건 하에서는 파이프라이닝 되지 않은 컴퓨터와 파이프라인 컴퓨터에서 실제 프로그램 실행 시간 비율은 명령어 사이 시간 비율과 근접
<div align="center">
<img src="https://github.com/user-attachments/assets/00783d06-63ac-4f48-aff4-0313678e2065">
</div>

7. 💡 즉, 파이프라이닝은 개별 명령어의 실행 시간을 줄이지는 못하지만, 대신 명령어 처리량을 증대시킴으로써, 성능을 향상
   - 실제 프로그램들은 수십억 개의 명령어를 실행하므로 명령어 처리량이 중요 척도
