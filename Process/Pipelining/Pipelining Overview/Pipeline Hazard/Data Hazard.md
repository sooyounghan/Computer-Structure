-----
### 데이터 해저드 (Data Hazard)
-----
1. 파이프라인 데이터 해저드라고 하며, 명령어를 실행하는 데 필요한 데이터가 아직 준비되지 않아서 계획된 명령어가 적절한 클럭 사이클에 실행될 수 없는 사건
2. 즉, 어떤 단계가 다른 단계가 끝나기를 기다려야 하기 때문에 파이프라인이 지연되어야 하는 경우가 발생
   - 옷을 개다가 한 짝이 없는 양말을 발견했다고 가정
   - 한 가지 방법 : 방으로 달려갓 옷장을 뒤져 나머지 짝을 찾아보는 것
   - 옷장을 뒤지고 있는 동안은 건조 과정을 끝내고, 개는 과정을 기다리는 옷들과 세탁 과정을 끝내고 건조 과정을 기다리는 옷들은 기다려야 함

3. 컴퓨터 파이프라인에서는 어떤 명령어가 아직 파이프라인에 있는 앞선 명령어에 종속성을 가질 때 데이터 해저드가 일어남
   - 예를 들어, add 명령어 바로 다음에 add의 합($s0)을 사용하는 뺄셈 명령어가 뒤 따르는 경우 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/6cc585bd-72a9-4c6b-aafa-0a853fc963d9">
</div>

   - 별다른 조치가 없다면 데이터 해저드가 파이프라인을 심각하게 지연시킬 수 있음
   - add 명령어가 다섯 번째 단계까지 결과값을 쓰지 않을 텐데, 파이프라인이 세 클럭 사이클을 낭비해야 함

4. 컴파일러를 이용해서 이런 데이터 해저드를 모두 제거하려고 할 수 있지만, 결과는 그리 만족스럽지 못할 것
   - 이런 종속성은 너무 자주 일어나고, 지연은 너무 길어서 컴파일러가 우리를 이 같은 딜레마로부터 구출할 것이라고 기대하기가 어려움
   - 첫 번째 해결책은 명령어가 끝날 때까지 기다렸다가 그 후에 데이터 해저드를 해결하려고 할 필요가 없다는 관찰에 기반을 둠
     + 위와 같은 코드의 경우 ALU가 add 명령어의 합을 만들어내자마자 이것을 뺄셈의 입력으로 사용할 수 있음
     + 별도의 하드웨어를 추가하여 정상적으로 얻을 수 없는 값을 내부 작원으로부터 일찍 받아오는 것을 전방전달(Forwarding) 또는 우회전달(Bypassing)이라고 함
     + 전방전달 또는 우회전달 : 프로그래머가 볼 수 있는 레지스터나 메모리에 데이터가 도착할 때까지 기다리지 않고, 내부 버퍼에서 가져옴으로써 데이터 해저드를 해결하는 방법
     + 전방전달이라는 이름은 앞의 명령어가 뒤의 명령어에게 결과값을 전방(앞쪽)으로 전달하는 생각에서 나옴
     + 우회전달이라는 말은 결과값이 레지스터 파일을 거치지 않고 빙 돌아서 원하는 유닛으로 전달(Pass)된다는 뜻에서 나옴

  - 예) 두 명령어 사이의 전방전달 : 다음 두 명령어에서 어느 파이프라인 단계가 전방전달에 의해 연결되어야 하는지를 보이되, 아래 그림과 같은 방식으로 파이프라인 다섯 단계의 데이터패스를 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/b7a54f9f-abd5-4c80-90ae-913a15e7d507">
</div>

   - add 명령어 실행 단계 후의 $s0 값을 sub 명령어의 실행 단계 입력으로 전방전달하기 위한 연결을 보여주고 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/72227122-82d2-491c-96fc-154ff1312b43">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/0fcf06d3-f564-497a-baf0-9443a67594d4">
</div>

   - 위 표현에서 목적지 단계가 근원지 단계보다 시간상 늦을 경우에만 전방전달 통로가 유효
   - 예를 들면, 첫 번째 명령어 메모리 접근 단계 출력으로부터 다음 명령어의 실행 단계 입력으로의 전방전달 통로는 유효한 통로가 될 수 없음 : 그 통로는 시간이 뒤로 돌아가는 것을 의미

   - 전방전달이 모든 파이프라인 지연을 방지할 수 없음
     + 예를 들어, 첫 번째 명령어가 add 명령어가 아닌 $s0의 적재 명령어라고 가정 : 데이터 종속 관계에 있는 첫 번째 명령어의 4단계 이후에만 사용할 수 있어서 sub 명령어의 세 번째 단계 입력으로는 너무 늦음
     + 따라서, 다음과 같이 적재-사용 데이터 해저드(Load-Use Data Hazard)의 경우에는 전방전달을 해도 한 단계 지연되어야 함
       * 적재-사용 데이터 해저드 : 적재 명령어에 의해 적재된 데이터를 다른 명령어가 필요로 하는데, 필요한 시점까지 이 데이터가 도착하지 않아서 생기는 특별한 형태 해저드
     + 이 그림은 파이프라인 지연(Pipeline Stall)이라는 중요 파이프라이닝 개념을 보여줌 : 파이프라인 지연은 지연은 거품(Bubble)이라는 별명으로 불리는 경우도 많으며, 해저드를 해결하기 위해 만드는 지연
     + 또한, 파이프라이닝의 다른 곳에서도 지연을 볼 수 있는데, 어려운 경우의 처리 방법의 경우에는 하드웨어 검출과 지연을 사용하거나 적재-사용 파이프라인 지연을 피할 수 있게 명령어 순서를 바꾸는 소프트웨어 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/80edac39-63f7-4892-bda2-3059c91a8aff">
</div>

5. 예) 파이프라인 지연을 피하기 위한 코드 재정렬
   - C로 작성된 다음 코드
```
a = b + e;
c = b + f;
```
   - 이 코드에 대한 MIPS 코드 (모든 변수는 메모리에 있고, $T0를 베이스로 사용해 접근할 수 있는 위치에 있다고 가정)
<div align="center">
<img src="https://github.com/user-attachments/assets/43883b78-38e0-4c3f-8c17-81f7a4f5a28a">
</div>

   - 두 add 명령어가 모두 해저드를 가지고 있는데, 이는 바로 앞의 명령어인 lw 명령어와 각각 종속성이 있기 때문임
   - 전방전달을 하면, 첫 번쨰 lw 명령어에 대한 첫 번째 add 명령어의 종속성과 저장 명령어 관련 모든 해저드를 포함하여 가능성 있는 몇 가지 다른 해저드가 제거됨을 주목
   - 세 번쨰 lw 명령어를 위로 올리면, 두 해저드가 모두 없어짐
<div align="center">
<img src="https://github.com/user-attachments/assets/2c5ff3ff-c090-40f7-ad1a-41dd6b1a486c">
</div>

   - 전방전달 유닛이 있는 파이프라인 프로세서에서, 재정렬된 코드는 원래 코드보다 두 사이클 먼저 완료

6. 전방전달은 앞서 언급한 네 가지 통찰 외에 MIPS 구조에 대한 또 다른 점을 인식하게 함
   - 각각의 MIPS 명령어는 기껏해야 하나의 결과 쓰기를 할 뿐이며, 그것도 파이프라인 끝에서 함
   - 명령어 하나에 전방전달해야 하는 결과가 여러 개 있거나 명령어 실행의 앞 단계에서 결과 쓰기를 한다면 전방전달은 더 어려워졌을 것

   
