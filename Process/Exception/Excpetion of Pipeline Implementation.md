-----
### 파이프라인 구현에서의 예외
-----
1. 파이프라인 구현은 예외를 제어 해저드의 다른 형태로 취급
   - 예를 들어, add 명령어가 산술 오버플로우를 가진다고 가정
     + 분기가 일어났을 때 했던것과 같이 add 명령어 다음 명령어들을 파이프라인에서 쓸어버리고, 새로운 주소에서 명령어를 가져와야 함
     + 분기가 일어났을 때, 사용했던 것과 같은 방법을 사용할 예정이지만, 이번에는 예외가 제어선들을 비인가(0) 상태로 만듬

   - 잘못된 분기 에측을 다루었을 때, IF 단계에서 명령어를 nop로 바꿈으로써 명령어를 버리는 방법이 존재
     + ID 단계의 명령어를 버리기 위해서는 ID 단계의 멀티플렉서를 사용해 제어 신호들을 0으로 만듦으로써 지연시킴
     + ID.Flush라 불리는 새로운 제어 신호는 해저드 검출 유닛의 지연 신호와 OR 하여 ID 단계의 명령어를 지움
     + EX 단계의 명령어를 버리기 위해 EX.Flush라는 새로운 신호를 사용하며, 이 신호는 새로운 멀티플렉서가 제어 신호들을 0으로 만들게 함
     + MIPS 예외 주소인 8000 $0180_{16}$번지에서 명령어를 인출하기 위해 PC 멀티플렉서의 입력을 추가하여 8000 $0180_{16}$ 값을 PC로 보낼 수 있게 함
     + 수정된 데이터패스
<div align="center">
<img src="https://github.com/user-attachments/assets/3bcef505-8045-4507-bc67-4e90f01a1e8f">
</div>

2. 이 예(add $1, $2, $1의 산술 오버플로우)는 예외와 관련된 한 가지 문제점을 보여줌
   - 명령어 실행을 중간에서 정지시키지 않으면, 프로그래머는 레지스터 $1의 원래 값을 확인할 수 없음
   - $1이 오버플로우의 원인일 수 있는데, add 명령어의 목적지 레지스터이기 때문에 그 값이 바뀔 수 있기 때문임
   - 조심스럽게 설계를 하여 오버플로우 예외가 EX 단계에서 검출되도록 하면, EX.Flush 신호를 사용하여 EX 단게의 명령어가 WB 단게에서 결과값을 쓰지 않도록 할 수 있음

3. 많은 예외의 경우에 예외를 일으켰던 명령어가 마치 정상적으로 실행되는 것처럼 실행 완료되기를 요구하고 있음
   - 이렇게 하는 가장 간단한 방법은 해당 명령어를 일단 쓸어버리고, 예외 처리가 끝난 후 그 명령어를 처음부터 다시 시작하는 것

4. 마지막 단계는 문제를 일으킨 명령어의 주소를 예외 프로그램 카운터(EPC)에 저장하는 것
   - 실제로는 명령어 주소 + 4를 저장하므로, 에외 처리 루틴은 저장된 값에서 4를 빼야 함
   - 예외를 처리하기 위한 분기 하드웨어와 기타 필요한 것들을 포함하는 데이터패스
<div align="center">
<img src="https://github.com/user-attachments/assets/3bcef505-8045-4507-bc67-4e90f01a1e8f">
</div>

5. 예) 파이프라인 컴퓨터에서 예외
   - 프로그램 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/732bcc5f-3450-4b1f-9683-c367c21533d0">
</div>

   - 예외가 일어났을 때 호출되는 명령어들은 다음과 같이 시작된다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/22a96fd9-cc3d-4b87-b9c5-d2fc86c97291">
</div>

   - add 명령어의 산술 오버플로우 때문에 발생한 예외의 결과 (명령어가 EX 단계에 있을 때 부터 시작)
<div align="center">
<img src="https://github.com/user-attachments/assets/e5894f17-457d-443c-82b7-f78b8fd22912">
</div>

   - 클럭 사이클 6에서 오버플로우가 검출되어 PC에 8000 $0180_{16}$가 들어감
   - 클럭 사이클 7은 add 명령어와 그 다음 2개의 명령어를 버리고, 예외 코드의 첫 번째 명령어가 인출됨을 보여줌
   - add 다음의 명령어 주소 4$C_{16}$ = 4 = $50_{16}$가 EPC에 저장됨을 주목

6. 항상 5개의 명령어가 활성화되어 있으므로, 예외와 그 예외를 일으킨 명령어를 연결짓는 것은 쉽지 않음
   - 게다가 한 클럭 사이클에서 여러 개의 예외가 동시에 일어날 수 있음
   - 보통의 해결책은 예외에 우선순위를 두어 어떤 것이 먼저 서비스되어야 하는지 결정하기 쉽도록 하는 것
   - 대부분 MIPS 구현에서는 가장 앞선 명령어가 인터럽트되도록 하드웨어가 예외를 정렬

7. 입출력 장치의 요구와 하드웨어 오동작은 특정 명령어와 연관되어 있지는 않음
   - 따라서 언제 파이프라인을 인터럽트 할 것인가에 대해서 어느 정도 유연성을 가지고 있음
   - 그러므로 다른 예외에 사용하는 기법을 그대로 사용해도 무방

8. EPC는 인터럽트당한 명령어 주소를 갖게 되며 MIPS Cause 레지스터는 한 클럭 사이클에서 가능한 모든 예외를 기록하고 있으므로, 예외 소프트웨어는 예외를 적절한 명령어와 대응시켜야 함
   - 가장 중요한 것은 어떤 종류의 예외가 어느 파이프라인 단계에서 일어날 수 있는지에 대한 정보
   - 예를 들면, 정의 안 된 명령어는 ID 단계에서 발견되며 운영체제 호출은 EX 단계에서 일어남
   - 발생한 예외는 모두 Cause 레지스터의 미처리 예외 필드(Pending Exception Field)에 모아두었다가, 가장 먼저 발생한 예외의 서비스가 끝난 후 이를 보고 나중에 발생한 예외들을 처리

9. 예외를 기대한 대로 처리되도록 하드웨어와 운영체제가 함께 협력하여 동작해야 함
    - 일반적으로 하드웨어가 맡은 부분은 예외가 일어난 명령어를 중간에서 중지시키는 일, 이전 명령어의 실행을 모두 끝내는 일, 뒤따라 나오는 모든 명령어를 쓸어 버리는 일, 예외의 원인을 나타내도록 레지스터 값을 설정하는 일, 예외가 일어난 명령어의 주소를 지정하는 일, 미리 약속된 주소로 점프하는 일 등
    - 운영체제가 맡은 부분은 예외를 찾아서 적절히 대처하는 일이며, 정의 안된 명령어 / 하드웨어 오동작 / 산술 오버플로우 예외의 경우에 운영체제는 일반적으로 프로그램 실행을 중단하고 원인을 나타내는 메세지를 출력
    - 입출력 장치 요구나 운영체제 서비스 호출의 경우에는 프로그램의 상태를 저장하고 원하는 일을 수행한 후, 원래의 프로그램을 복구하여 실행을 계속함
    - 입출력 장치 요구의 경우에는 입출력을 요구하였던 프로그램을 재개하기전 까지 다른 프로그램을 실행하도록 할 수 있음
      + 입출력이 끝날 때까지 이 프로그램을 진행시킬 수 없는 경우가 흔하기 때문에 가능
    - 이는 프로그램 상태를 저장하고 복원하는 능력이 매우 중요한 이유

10. 파이프라인 컴퓨터에서는 예외와 그에 대응하는 명령어를 옳게 연결시키는 것이 어려움
    - 그래서 어떤 컴퓨터 설계자들은 결정적인 경우가 아니라면, 이런 요구 사항을 다소 완화하게 됨
    - 이런 프로세서를 부정확한 인터럽트(Imprecise Interrupt) 또는 부정확한 예외(Imprecise Exception)를 갖는다고 말함
      + 부정확한 인터럽트 (부정확한 예외) : 인터럽트 또는 예외의 원인인 명령어와 정확히 연관되지 않는 파이프라인 컴퓨터의 인터럽트 또는 예외
      + 위의 예에서는 에외를 일으킨 명령어가 주소 $4C_{16}$에 있는 명령어지만, 예외가 검출된 직후 클럭 사이클에서 PC 값은 $58_{16}$인 것이 보통
      + 부정확한 예욀르 사용하는 프로세서의 경우 $58_{16}$를 EPC에 저장하고 어떤 명령어가 문제를 일으켰는지 결정하는 것은 운영체제에 맡김
    - 오늘날은 MIPS를 포함한 굉장히 많은 컴퓨터가 정확한 인터럽트(Precise Interrupt) 또는 정확한 예외(Precise Exception)을 지원
      + 정확한 인터럽트 (정확한 예외) : 파이프라인 컴퓨터에서 정확한 명령어와 연관 짓는 인터럽트 또는 예외

11. MIPS는 거의 모든 예외에 대해 예외 진입 주소 8000 $0180_{16}$를 사용하지만, TLB 실패 예외는 예외 핸들러의 성능을 높이기 위해 주소 8000 $0000_{16}$를 사용
