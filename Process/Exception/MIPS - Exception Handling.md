-----
### MIPS 구조의 예외 처리
-----
1. 예외가 일어났을 때 컴퓨터 해야 되는 기본 동작은 문제를 일으킨 명령어의 주소를 예외 프로그램 카운터(EPC, Exception Program Counter)에 저장하고 어떤 특정 주소에 있는 운영체제로 제어를 옮기는 것
   - 그러면 운영체제는 알맞은 행동을 취할 수 있는데, 이러한 행동에는 사용자 프로그램에 어떤 서비스를 제공한다든지, 오버플로우에 대하여 미리 정의된 행동을 취한다든지, 아니면 프로그램 실행을 중지하고 오류를 보고한다든지 하는 것이 포함
   - 예외 처리에 필요한 작업을 마친 다음에는 운영체제가 프로그램을 끝내든지 아니면 실행을 계속할 수 있음
     + 실행을 계속할 경우에는 어느 곳에서 실행을 재개해야 하는지 EPC를 사용

2. 운영체제가 예외를 처리하려면 예외를 일으킨 명령어뿐만 아니라 예외의 원인을 알아야 함
   - 예외의 원인을 알려주기 위해 사용되는 방법으로는 Cause 레지스터와 백터 인터럽트(Vetcor Interrupt)
   - MIPS 구조에서 사용하는 방법 : Cause 레지스터라 불리는 상태 레지스터를 이용
     + 이 상태 레지스터에는 예외의 원인을 나타내는 필드가 존재
   - 벡터 인터럽트(Vector Interrupt)를 사용하는 것
     + 벡터 인터럽트 : 제어를 넘길 주소가 예외의 원인에 의해 결정되는 인터럽트
     + 제어를 넘길 주소가 예외의 원인에 의해 결정
     + 예를 들면, 정의 안 된 명령어와 산술 오버플로우 예외에 대해 다음과 같이 벡터 주소 정의 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/838af1ec-514b-4690-b19c-d375a4050900">
</div>

   - 운영체제는 예외 처리가 시작되는 주소를 보고 예외의 원인을 알 수 있음
     + 이 주소는 32바이트씩(8개 명령어씩) 떨어져 있음
     + 이 주소로 제어가 넘어오면 운영체제가 예외의 원인을 기록한 후 제한적 처리를 할 수 있음

   - 예외가 벡터화되어 있지 않으면, 모든 예외가 같은 시작점을 사용해야 되고, 예외의 원인은 운영체제가 상태 레지스터를 해독해서 알아냄

3. MIPS 구조에서 쓰이는 예외 시스템을 구현한다고 가정
   - 공통 시작 지점의 주소는 8000 $0180_{16}$
   - 예외 처리를 위해 현재의 MIPS 구현에 레지스터 2개를 추가해야 함
     + EPC : 예외가 일어났던 명령어의 주소를 보관하기 위해 사용되는 32비트 레지스터 (이 레지스터는 예외가 벡터화되어도 필요)
     + Cause : 예외의 원인을 기록하는 데 사용되는 레지스터, MIPS 구조에서 리 제스터는 32비트이지만 현재 몇 비트는 사용되지 않고 있음
       * 예외 원인을 표시하는 5비트 필드가 있어서, 그 값이 10이면 정의 안 된 명령어 / 12이면 산술 오버플로우를 뜻한다고 가정
      
