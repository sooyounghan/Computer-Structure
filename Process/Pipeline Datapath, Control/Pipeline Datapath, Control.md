-----
### 파이프라인 데이터패스 및 제어
-----
1. 단일 사이클 데이터패스에 파이프라인 단계
<div align="center">
<img src="https://github.com/user-attachments/assets/edfd59a8-ccc3-4a2f-85d4-d0a4d9b2c0e8">
</div>

   - 명령어 실행 과정을 다섯 단계로 나눈 것은 다섯 단계 파이프라인을 의미하며, 이는 한 클럭 사이클에 최대 5개 명령어가 실행 중일 수 있다는 것을 의미
   - 따라서, 데이터패스를 5개 부분으로 나누어야 하며, 각 부분은 명령어 실행 단계에 따라 다음과 같이 이름이 붙여짐
     + IF(Instruction Fetch) : 명령어 인출
     + ID(Instruction Decode / Register File Read) : 명령어 해독 및 레지스터 파일 읽기
     + EX(Execute / Address Calculation) : 실행 또는 주소 계산
     + MEM(Memory Access) : 데이터 메모리 접근
     + WB(Write Back) : 쓰기(Write-Back)

   - 명령어와 데이터는 실행되면서 다섯 단계를 왼쪽에서 오른쪽으로 통과
     + 세탁소에 비유하면 옷들은 선을 따라 움직이면서 더 깨끗해지고 건조되고 정돈되어 결코 뒤쪽으로 되돌아가지 않음

2. 그러나 명령어에서 이같이 왼쪽에서 오른쪽으로 가는 흐름에 두 가지 예외가 존재
   - 쓰기 단계 : 이 단게에서는 결과를 데이터패스의 중앙에 있는 레지스터 파일에 다 씀
   - PC의 다음 값 선정 : 증가된 PC 값과 MEM 단계의 분기 주소 중 고름

3. 오른쪽에서 왼쪽으로 흐르는 데이터는 현재 명령어에 영향을 주지 않음
   - 파이프라인의 뒤쪽에 있는 명령어들만이 이 역방향 데이터 흐름에 영향을 받음
   - 오른쪽에서 왼쪽으로 가는 첫 번째 연결은 데이터 해저드를 일으킬 수 있으며, 두 번째 연결은 제어 해저드를 일으킬 수 있음

4. 파이프라인 실행에서 일어나는 일을 보여주는 한 가지 방법은 각 명령어가 자신의 데이터패스를 가지고 있는 것처럼 하고, 이들을 시간 축에 배치하여 그들 사이의 관계를 보여주는 것
   - 공통 시간 축에 각 명령어들의 데이터패스
<div align="center">
<img src="https://github.com/user-attachments/assets/063f6857-a849-48fd-9387-37f4fc0102e4">
</div>

   - 명령어 3개가 3개의 데이터패스를 필요로 한다고 말하는 것처럼 보임
   - 하지만 여기서 데이터를 유지하는 레지스터를 추가하여 한 데이터패스의 부분 부분이 명령어 실행 동안 공유될 수 있게함
   - 명령어 메모리는 명령어의 다섯 단계 중 한 단계에서만 사용되므로, 이 명령어가 다른 네 단계에 있는 동안 명령어 메모리는 다른 명령어가 사용할 수 있음
   - 다른 네 단계 동안에도 각 명령어의 값을 유지하기 위해 명령어 메모리에서 읽어들인 값을 레지스터에 저장해야 함
   - 즉, 비슷한 논지가 모든 파이프라인 단계에 적용
   - 따라서, 위 그림에서 단계를 나누는 선이 있는 곳마다 레지스터를 두어야 하는데, 이를 파이프라인 레지스터라고 함
     + 세탁소에 비유하면, 다음 단계로 갈 옷을 보관하기 위해 각 단계 사이에 바구니를 비치해야 함

5. 파이프라인 데이터패스
<div align="center">
<img src="https://github.com/user-attachments/assets/fe31071d-b93c-4f48-914b-ec99064f8956">
</div>

   - 파이프라인 레지스터가 강조되었음
   - 모든 명령어는 매 클럭 사이클마다 한 파이프라인 레지스터에서 다음 레지스터로 전진
   - 레지스터 이름을 이 레지스터가 분리하고 있는 두 단계를 따라서 붙임
     + 예를 들면, IF 단계와 ID 단계 사이의 파이프라인 레지스터는 IF/ID라 불림

   - 쓰기 단계 끝에는 파이프라인 레지스터가 없음
     + 모든 명령어는 컴퓨터의 상태(레지스터 파일, 메모리, PC)를 갱신해야 함
     + 이렇게 갱신되는 상태는 별도의 파이프라인 레지스터가 필요 없음
     + 예를 들면, 적재 명령어는 32개 레지스터 중 하나에다 결과값을 쓰는데, 뒤에 있는 명령어 중 이 데이터를 필요로 하는 것이 있으면 그냥 그 레지스터를 읽으면 되므로, 파이프라인 레지스터에 저장할 필요가 없음

   - 모든 명령어는 PC 값을 증가시키든, 분기 목적지 주소로 바꾸든 PC 값을 바꿈
     + PC는 IF 단계 앞에 있는 파이프라인 레지스터로 생각할 수 있음
     + 그러나 위 그림에서 파란색으로 표시된 파이프라인 레지스터와 달리 PC는 사용자가 볼 수 있는 구조적 상태
     + 예외가 발생하면 구조적 상태 내용은 저장되어야 하지만, 파이프라인 레지스터는 버리게 되는 것이 다름
     + 즉, 세탁소에 비유하면 PC를 세탁 단계 전 더러운 옷 묶음을 가지고 있는 바구니로 볼 수 있음

6. 여기서는 파이프라이닝이 어떻게 동작하는지 보여주기 위해 시간에 따라 변하는 연속된 그림을 제시

7. 적재 명령어가 파이프라인의 다섯 단계를 통과해가면서 활성화되는 데이터패스 부분
8. 첫 번째 예시) 적재 명령어 (적재 명령어가 다섯 단계 모두 활성화가 됨)
     + 레지스터나 메모리를 읽을 때는 레지스터 또는 메모리의 오른쪽 파랗게 칠하고, 쓰기를 행할 때 왼쪽 반을 파랗게 칠함
     + 각 그림에서 명령어 약어인 lw와 함께 활성화된 파이프 단계의 이름을 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/2b89298e-15b7-4c00-9e81-d6182746fa56">
</div>

   - 명령어 인출(Instruction Fetch)
     + 위 그림 윗 부분은 PC에 있는 주소를 사용하여 명령어를 읽어오고 IF / ID 파이프라인 레지스터에 저장하는 것을 보여줌
     + PC 주소는 4만큼 증가되어 PC에 다시 저장됨으로써 다음 클럭 사이클에 사용될 수 있음
     + 이 증가한 주소는 beq 같은 명령어가 나중에 사용할 수 있기 때문에 IF / ID 파이프라인 레지스터에 저장
     + 컴퓨터는 어떤 종류의 명령어를 가져오고 있는지 모르므로, 모든 명령어에 대비해야 하므로 잠재적으로 필요한 정보는 모두 파이프라인을 따라 전달해야 함

   - 명령어 해독 및 레지스터 파일 읽기(Instruction Decode and Register File Read)
     + 위 그림의 아래 부분은 IF / ID 파이프라인 레지스터의 명령어 부분이 16비트 수치 필드(32비트로 부호확장됨) 값과 레지스터 번호 2개를 제공하는 것을 보여줌
     + 세 값 모두 증가한 PC 주소 값과 더불어 ID / EX 파이프라인 레지스터에 저장
     + 차후의 클럭 사이클에 어느 명령어에 의해 필요할지 모르는 것은 모두 전달

<div align="center">
<img src="https://github.com/user-attachments/assets/3842df2f-d4f5-4b28-969a-1678b451ac2a">
</div>

   - 실행 또는 주소 계산(Execute or Address Calculation)
     + 적재 명령어가 ID / EX 파이프라인 레지스터에서 레지스터 1의 내용과 부호확장된 수치 필드를 읽음
     + ALU를 사용해 이 둘을 더하는 것을 보여줌
     + 합은 EX / MEM 파이프라인 레지스터에 저장
       
<div align="center">
<img src="https://github.com/user-attachments/assets/e3f854fa-a8c2-4739-af2a-cdae6da13270">
</div>

   - 메모리 접근(Memory Access)
     + 위 그림 중 윗 부분은 적재 명령어가 EX / MEM 파이프라인 레지스터에서 주소를 받아서 데이터 메모리를 읽고 이 데이터를 MEM / WB 파이프라인 레지스터에 저장하는 것을 보여줌

   - 쓰기(Write-Back)
     + 위 그림 중 아랫 부분은 마지막 단계를 보여줌
     + MEM / WB 파이프라인 레지스터에서 데이터를 읽어서 그 데이터를 그림 중앙에 있는 레지스터 파일에 씀

   - 이렇게 적재 명령어를 따라가면, 후속 파이프 단계에서 필요한 정보는 모두 파이프라인 레지스터를 통해 그 필요 단계까지 전달되어야 함

9. 두 번째 예시) 저장 명령어
    - 저장 명령어를 따라가보면 후속 파이프 단계를 위해 정보를 전달해야 하는 것 뿐만 아니라 명령어 실행 자체도 비슷함
    - 명령어 인출
      + PC의 주소를 사용해 메모리에서 명령어를 읽어서 IF / ID 파이프라인 레지스터에 저장
      + 명령어가 판별되기 전 이 단계가 실행되기 때문에 저장 명령어에도 똑같이 적용

    - 명령어 해독 및 레지스터 파일 읽기
      + IF / ID 파이프라인 레지스터에 있는 명령어에서 레지스터 번호를 받아서 레지스터 2개를 읽고 또한 16비트 수치 필드를 부호확장
      + 이 3개를 32비트 값들 모두가 ID / EX 파이프라인 레지스터에 저장
      + 적재 명령어와 동일하게 적용되며, 아직은 명령어 종류를 구별할 수 없으므로, 처음 두 단계는 어떤 명령어나 동일

    - 실행 및 주소 계산
      + 실제(Feefective Address)는 EX / MEM 파이프라인 레지스터에 저장

<div align="center">
<img src="https://github.com/user-attachments/assets/dc6068db-2d42-4996-a613-edf0d67f6399">
</div>

   - 메모리 접근
     + 위 그림의 윗 부분은 데이터가 메모리에 써지고 있는 것을 보여줌
     + 저장할 데이터를 가지고 있는 레지스터는 앞 단계에서 읽혔고, 읽힌 값이 ID / EX에 저장되어 있음
     + MEM 단계에서 데이터를 사용할 수 있게 하는 유일한 방법은 EX 단계에서 데이터를 EX / MEM 파이프라인 레지스터에 저장하는 것
     + 앞에서 실제 주소를 EX / MEM 에다 저장했던 것과 같음

   - 쓰기
     + 위 그림은 아랫 부분은 저장 명령어의 마지막 단계를 보여줌
     + 이 명령어의 경우 쓰기 단계에서는 아무 일도 일어나지 않음
     + 쓰기 단계가 비더라도 저장 명령어 뒤의 명령어들을 앞당겨서 빨리 수행할 수 없음
     + 어떤 명령어가 특정 단계에서 아무 일을 하지 않더라도 그 단계를 건너 뛸 수 없는데, 뒤따르는 명령어들이 이미 최고 속도로 진행 중이기 때문임

10. 저장 명령어의 경우, 앞선 파이프 단계에서 뒤의 단계로 무엇인가를 보내기 위해서는 그 정보가 파이프라인 레지스터에 저장되어야 한다는 것
    - 그렇지 않으면 다음 명령어가 그 파이프라인 단계에 들어올 때, 그 정보는 없어지게 됨
    - 저장 명령어의 경우, ID 단계에서 읽었던 레지스터 중 하나를 MEM 단계로 전달할 필요가 있는데, 그 값은 MEM 단계에서 메모리에 저장
    - 이 데이터가 처음에는 ID / EX 파이프라인 레지스터에 저장되고 나중에 EX / MEM 파이프라인 레지스터에 전달

11. 적재 명령어와 저장 명령어의 경우, 데이터패스의 모든 구성 요소(명령어 메모리, 레지스터 읽기 포트, ALU, 데이터 메모리, 레지스터 쓰기 포트)는 한 파이프라인 단계에서만 상요될 수 있음
    - 그렇지 않으면, 구조적 해저드를 일으키게 될 것
    - 따라서, 이 구성 요소들과 그 요소들의 제어는 파이프라인 단계 하나와 연관지을 수 있음

12. 적재 명령어 설계 상 버그
    - 적재 명령어의 최종 단계에서 값이 바뀌는 것은 어느 레지스터인가? (즉, 어느 명령어가 쓰기 레지스터 번호를 제공하는가?)
    - 이에 대한 답은 IF / ID 파이프라인에 있는 명령어가 쓰기 레지스터 번호를 제공하고 있는데, 사실 이 명령어는 적재 명령어보다 상당히 뒤에 있는 명령어
    - 따라서, 적재 명령어에 있는 목적지 레지스터 번호를 간직할 필요가 있음
      + 저장 명령어가 MEM 단계에서 사용하기 위해 ID / EX의 레지스터 내용을 EX / MEM 파이프라인 레지스터에 전달했듯이, 적재 명령어도 레지스터 번호를 ID / EX에서 EX / MEM을 거쳐 MEM / WB 파이프라인 레지스터로 보내야 WB 단계에서 사용할 수 있음
      + 레지스터 번호를 전달하는 것을 다른 관점에서 생각할 수 있는데, 파이프라인 데이터패스를 공유하기 위해 IF 단계에서 읽은 명령어를 간직할 필요가 있고, 그래서 각 파이프라인 레지스터는 현 단게나 이후 단계에서 필요한 명령어 부분을 가지고 있는 것

13. 수정된 데이터패스
<div align="center">
<img src="https://github.com/user-attachments/assets/f565871e-443b-4fa7-9fc2-39423ac5f97f">
</div>

   - 쓰기 레지스터 번호를 먼저 ID / EX 레지스터로, 그 뒤에는 EX / MEM 레지스터로, MEM / WB 레지스터로 전달
   - 이 레지스터 번호는 WB 단계에서 쓰기를 행할 레지스터를 명시하기 위해 사용

12. 워드 적재 명령어의 올바른 데이터패스를 하나로 그린 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/ebfa55ab-7171-4a10-80a8-3a45de70d865">
</div>

