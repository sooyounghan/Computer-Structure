-----
### 서론
-----
1. 클럭 사이클 시간과 명령어당 클럭 사이클 수는 프로세서 구현 방법에 따라 결정
2. 기본적인 MIPS 구현
   - 메모리 참조 명령어 : lw(load doubleword)와 sw(save doubleword)
   - 산술 / 논리 명령어 : add, sub, AND, OR, slt
   - 조건부 분기 명령어 : beq(branch equal)와 jump

3. 구현에 대한 개요
   - 프로그램 카운터(PC)를 프로그램이 저장되어 있는 메모리에 보내서 메모리로부터 명령어를 가져옴
   - 읽을 레지스터를 선택하는 명령어 필드를 사용하여 하나 또는 2개의 레지스터를 읽음
     + 워드 적재 명령어는 레지스터 하나만 읽으면 되지만, 대부분 다른 명령어는 레지스터 2개를 읽음

   - 예) 점프 명령어를 제외한 모든 명령어는 레지스터를 읽은 후 ALU를 상요
     + 메모리 참조 명령어는 주소 계산을 위해 ALU를 사용하고, 산술 / 논리 명령어는 연산을 수행하기 위해 ALU를 사용하며, 분기 명령어는 비교하기 위해 사용
     + ALU를 사용한 후에는 필요한 행동들이 명령어 종류에 따라 서로 다름
       * 메모리 참조 명령어는 메모리에 접근
       * 저장 명령어는 데이터를 기록하기 위해 접근
       * 적재 명령어는 데이터를 읽기 위해 접근
     + 산술 / 논리 명령어와 적재 명령어는 ALU나 메모리에서 온 데이터를 레지스터에 써야 함
     + 마지막으로 분기 명령어의 경우, 비교 결과에 따라서 다음 명령어의 주소를 바꿀 수 있고, PC 값을 4만큼 증가시켜서 다음 명령어의 주소를 갖게할 수 있음

4. MIPS 부분 집합 구현의 추상적 개관 : 주요 기능 유닛과 그들 사이의 연결
<div align="center">
<img src="https://github.com/user-attachments/assets/fa92166a-f2ab-497f-829a-9c952c2663d6">
</div>

  - PC에 들어갈 값은 두 덧셈기 중 하나에서 나오고, 레지스터 파일에 쓰일 데이터는 ALU나 데이터 메모리에서 나옴
  - ALU의 두 번째 입력은 레지스터나 명령어의 수치 필드에서 나옴
  - 실제 이들 데이터 선을 단순히 연결할 수 없으므로, 다수의 근원지 중 하나를 선택하여 그것만을 목적지로 보내는 구성 요소를 추가하여야 함
  - 이 같은 선택은 일반적으로 멀티플렉서(Multiplexor)라 불리는 소자를 사용하여 이루어짐 (데이터 선택기(Data Selector))
    + 멀티플렉서 : 제어선의 값에 따라 여러 개 입력 중 하나를 선택하는 소자
    + 제어선은 주로 실행 중인 명령어에서 나오는 정보에 따라 설정
  - 데이터 메모리는 적재 명령어일 때는 읽기, 저장 명령어일 때는 쓰기를 해야 함
    + 레지스터 파일은 적재 명령어나 산술 / 논리 연산 명령어일때만 쓰기를 함
    + 물론, ALU는 여러 가지 연산 중 하나를 수행해야 함
    + 멀티플렉서처럼 ALU의 제어선도 명령어 필드 값에 따라 정해지며, 제어선이 연산을 통제

5. 위 그림에서 데이터패스에 주요 기능을 유닛을 위한 제어선과 필요한 멀티플렉서 3개 추가
<div align="center">
<img src="https://github.com/user-attachments/assets/44df3eea-ea2c-4151-b386-79c38c950bee">
</div>

   - 제어 유닛(Control Unit)은 명령어 입력을 받아서 기능 유닛들과 두 멀티플렉서의 제어선 값을 결정
   - 세 번째 멀티플렉서는 PC + 4와 분기 목적지 주소 중 어느 것을 PC에 써야 할지 결정하는 것인데, ALU의 Zero 출력으로 제어 : 이 출력 값은 beq 명령어의 비교 결과로 결정

 6. MIPS 명령어 집합은 규칙적이고 단순하기 때문에, 간단한 디코딩 과정만으로 제어선의 값을 결정할 수 있음
    
