-----
### 데이터 해저드 : 전방전달 대 지연
-----
1. 종속성이 여러 개 있는 프로그램 (종속성은 파란색으로 표시)
<div align="center">
<img src="https://github.com/user-attachments/assets/feba0622-3419-439f-aeec-83a6d8cd1003">
</div>

   - 마지막 네 명령어 모두 레지스터 $2에 있는 첫 번째 명령어 결과에 종속적
   - 레지스터 $2가 뺄셈 명령어 이전에는 10이었다가 뺄셈 명령어 후에 -20이 된다면, 레지스터 $t2를 참조하는 그 다음 명령어들이 -20을 사용하도록 의도

2. 다중 클럭 사이클 파이프라인 다이어그램을 이용한 명령어들의 실행 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/73b77ed3-1deb-4c40-937d-c235cb060a59">
</div>

   - $2 값은 sub 명령어가 레지스터 결과를 쓰는 클럭 사이클 5의 중간에 변경
   - sub와 add 간의 잠재적 해저드는 레지스터 파일 하드웨어의 설계로 해결 가능
     + 같은 클럭 사이클에 한 레지스터에 대한 읽기와 쓰기가 동시에 일어날 경우(쓰기는 클럭 사이클 앞 부분에 일어나고, 읽기는 뒷 부분에 일어난다고 가정)
       * 읽기는 새로 써진 값을 읽을 수 있음
       * 따라서, 실제 레지스터 파일의 많은 구현의 경우에는 데이터 해저드가 발생하지 않음
   - 읽기가 클럭 사이클 5(CC 5)나 그 이후에 일어나지 않는 한 레지스터 $2를 읽은 값은 sub 명령어의 결과값이 아니라는 것을 보여주고 있음
   - -20이라는 올바른 값을 읽을 수 있는 명령어는 add와 sw뿐이며, AND와 OR 명령어는 10이라는 틀린 값을 읽게 됨
   - 따라서, 종속성 선이 시간 축에서 역방향으로 갈 때 문제가 발생할 수 있음을 보여줌
   - 즉, 필요한 결과가 만들어지는 것은 EX 단계, 즉 클럭 사이클 3의 끝
     + AND와 OR 명령어가 실제 데이터를 필요로 하는 시점은 ID 단계가 아닌 EX 단계, 즉 클럭 사이클 4와 5를 시작할 때 각각 필요
   - 데이터가 레지스터 파일에 읽을 수 있게 되기 전이라도, 그 값이 사용 가능해지자마자 바로 필요한 유닛으로 전방전달(Forward)하면, 이 코드들을 지연 없이 실행 가능

3. 전방 전달의 경우, 단순화를 위해 EX 단계의 연산으로 전방전달하는 문제만을 생각하면, ALU 연산이나 실제 주소 계산이 이에 해당
   - 앞선 명령어가 WB 단계에서 쓰기를 하려는 레지스터를 다른 명령어가 EX 단계에서 사용하려고 할 때, 실제로는 ALU 입력으로 그 값이 필요하다는 것을 알 수 있음

4. 파이프라인 레지스터 필드에 이름을 붙이면 종속성을 좀 더 자세히 표시할 수 있음
   - 예를 들어, ID / EX.RegisterRs는 파이프라인 레지스터 ID / EX에 있는 한 레지스터 번호, 즉 레지스터 파일의 첫 번째 읽기 포트에 실린 레지스터 번호를 나타냄
   - 이름의 첫 번쨰 부분(.의 왼쪽 부분)은 파이프라인 레지스터 이름이고, 두 번째 부분은 그 레지스터의 필드 이름으로, 이 표기법을 이용해 두 쌍의 해저드 조건을 표시하면 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/127ebf6b-95cb-492c-9e31-2d59e0393aae">
</div>

   - 앞의 코드에서 첫 번쨰 해저드는 레지스터 $2에 관한 것으로 sub $2, $1, $3의 결과와 and $12, $2, $5의 첫 번째 읽기 피연산자 사이에서 발생
   - 이런 해저드는 and 명령어가 EX 단계에 있고, 앞선 명령어(sub)가 MEM 단계에 있을 떄 검출 될 수 있음
   - 즉, 해저드 조건 1a를 만족시킴 : EX / MEM.RegisterRd = ID / EX.RegisterRs = $2

5. 예) 종속성 검출
<div align="center">
<img src="https://github.com/user-attachments/assets/fd912a10-a662-4412-90f0-31deacddb5a8">
</div>

   - sub-and의 관계 종류 1a의 해저드
   - sub-or는 종류 2b 해저드 (MEM / WB.RegisterRd = ID / EX.RegisterRt = $2)
   - sub-add의 2개 종속성은 해저드가 아님 : 레지스터 파일이 add가 ID 단계에 있을 때, 올바른 데이터를 제공함
   - Ssub-sw 사이에는 데이터 해저가 없음 : sub가 $2에 쓴 다음 클럭 사이클에서 sw가 $2를 읽기 때문임

6. 어떤 명령어들은 레지스터에 쓰기를 하지 않으므로 위 방법은 정확하지 않음
   - 필요 없을 때에도 전방전달을 하는 경우가 생기기 때문이며, 한 가지 해결책은 RegWrite 신호가 활성화되어 있는지 확인하는 것
     + EX 단계와 MEM 단계에서 파이프라인 레지스터의 WB 제어 필드를 조사하면, RegWrite 신호가 인가되었는지 알 수 있음
     + 또 MIPS의 %0는 항상 상수 0을 가지고 있어 그 값을 바꿀 수 없음
     + 파이프라인에 있는 명령어 목적지가 $0라면(예를 들어, sll $0, $1, 2), 전방 전달을 하면 안 됨
     + 레지스터 $0로 가는 값은 전방전달하지 않는 다면 어셈블리 프로그래머나 컴파일러에게 $0를 목적지 레지스터로 사용하지 말라고 강요할 필요가 없음
     + 1a와 1b 해저드 조건에 EX / MEM.RegisterRd ≠ 0을 추가하고, 2a와 2b 해저드 조건에 MEM / WB.Registerrd ≠ 0을 추가하면 위 조건들은 제대로 동작

   - 적절한 데이터를 전방전달해야 하는 문제 : 파이프라인 레지스터와 ALU 입력 사이의 종속성
<div align="center">
<img src="https://github.com/user-attachments/assets/70592fe1-8543-43c1-bfe7-e7e0192cc847">
</div>

   - 바뀐 것은 WB 단계가 레지스터 레지스터 파일에 쓸 때까지 기다리는 대신, 파이프라인 레지스터에서부터 종속성이 시작됨
   - 파이프라인 레지스터가 전방전달할 데이터를 가지고 있으므로, 필요한 데이터는 후속 명령어들이 사용할 시간에 맞추어 도착
   - ID / EX 레지스터 분만 아니라, 어느 파이프라인 레지스터에서라도 ALU 입력을 가져올 수 있다면, 적절한 데이터를 전방전달 할 수 있음
   - ALU 입력에 멀티플렉서를 추가하고, 적절한 제어를 붙이면 이 같은 데이터 종속성이 존재하더라도 파이프라인을 최고 속도로 실행 가능

7. 당분간 전방전달할 필요가 있는 명령어는 4개의 R형식 명령어 add, sub, AND, OR 뿐이라고 가정
   - 전방전달을 추가하기 전과 후의 ALU와 파이프라인 레지스터를 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/b8e3ece1-98a6-44f7-8dc8-e6fb226f4b95">
</div>

   - ALU 멀티플렉서를 위한 제어선들의 값을 보여주는데, 이를 통해 레지스터 파일 값과 전방전달된 값들 중 하나를 선택
<div align="center">
<img src="https://github.com/user-attachments/assets/a1b39c95-7ff5-471e-9b61-dcbba67c99e4">
</div>

   - ALU 전방전달 멀티플렉서가 EX 단계에 있으므로 전방전달 제어부도 EX 단계에 있음
     + 따라서, 전방 전달 여부를 결정할 수 있도록 피연산자 레지스터 번호를 ID 단계에서부터 ID / EX 파이프라인 레지스터를 거쳐 전달해줘야 함
     + rt 필드(비트 20:16)는 이미 ID / EX 파이프라인 레지스터에 저장했었음
     + 하지만, 전방 전달이 추가되기 전까지 ID / EX 레지스터 rs 필드를 저장할 필요가 없었으므로, rs 필드(비트 25:21)가 ID / EX에 추가되어야 함

   - 해저드를 검출하기 위한 조건과 이 해저드를 연결하기 위한 제어 신호
<div align="center">
<img src="https://github.com/user-attachments/assets/74ddb7f3-0bc7-4bc0-bb03-dc8db06d7b96">
</div>

   - EX / MEM.RegisterRd 필드는 ALU 명령어의 레지스터 목적지(명령어의 Rd 필드)가 될 수 있고, 적재 명령어의 레지스터 목적지(명령어의 Rt 필드)가 될 수 있음을 유의
   - 이 경우, 바로 앞 명령어의 결과를 ALU 입력 중 하나로 전방전달
     + 바로 앞 명령어가 레지스터 파일에 쓰기를 하는 명령어이고, 쓰기 레지스터 번호가 ALU 입력 A와 B의 읽기 레지스터 번호와 같다면(레지스터 0은 아니라고 가정) 파이프라인 레지스터 EX/MEM에서 값을 받도록 멀티플렉서를 제어

<div align="center">
<img src="https://github.com/user-attachments/assets/41857f8d-8822-4bd1-acf2-3475772ffde1">
</div>

   - WB 단계에는 해저드가 없음 : WB 단계에 있는 명령어가 값을 저장하는 레지스터를 ID 단계에 있는 명령어가 읽는다면, 레지스터 파일은 올바른 값을 제공한다고 가정하기 때문임
   - 그러한 레지스터 파일은 다른 형태의 전방전달을 하고 있는 셈이지만, 레지스터 파일 내에서 일어나고 있음
   - 한 가지 복잡한 문제 : WB 단계에 있는 명령어의 결과값과 MEM 단계에 있는 결과값 모두 ALU 단계에 있는 명령어의 근원지 피연산자 사이에 데이터 해저드가 일어날 수 있다는 것
     + 예를 들면, 어떤 벡터의 원소를 한 레지스터에서 합한다고 할 때, 명령어 코드 모두 같은 레지스터에 쓰려고 할 것
<div align="center">
<img src="https://github.com/user-attachments/assets/2b6637cf-c3c0-439a-9207-b9e2f3cf342f">
</div>

   - 이 경우 MEM 단계의 결과값이 더 최근의 것이므로 결과값은 MEM 단계에서 전방전달될 것이므로, MEM 해저드에 대한 제어는 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/0d68319e-d782-429d-9cb7-7813a38a4686">
</div>

   - EX 단계의 명령어를 위한 전방전달을 지원하기 위해 필요한 하드웨어
<div align="center">
<img src="https://github.com/user-attachments/assets/9baa40d6-d10a-4369-a16e-14f4d7ea6e84">
</div>

  - EX / MEM.RegisterRd 필드는 ALU 명령어의 레지스터 목적지(명령어의 Rd 필드)와 적재 명령어의 레지스터 목적지(명령어의 Rt 필드) 중 하나임

8. 저장 명령어가 다른 명령어에 종속적일 때도, 전방전달이 해저드 문제에 도움을 줄 수 있음
   - 저장 명령어는 MEM 단계에서 데이터 값 하나만을 사용하므로 전방전달이 쉬운 편
   - 그러나 저장 명령어가 적재 명령어 바로 다음에 나오는 경우에는, MIPS 구조에서 이런 코드는 메모리에서 메모리로 복사할 떄 유용할 것
     + 복사는 자주 나오므로, 이를 더 빠르게 실행할 수 있게 더 많은 전방전달 하드웨어를 추가할 필요가 있음
     + sub, AND 명령어를 lw, sw 명령어로 바꾸면 지연을 피하는 것이 가능한데, 저장 명령어가 MEM 단계에서 데이터를 사용하는 시점에 이 데이터는 MEM / WB 레지스터가 있기 때문임
     + 이 경우, 메모리 접근 단계에 전방 전달을 추가할 필요가 있음

   - 적재 명령어와 저장 명령어에서 필요한 부호있는 수치의 ALU 입력이 데이터패스에서 보이지 않음
     + 중앙 제어가 레지스터와 수치 필드 중 하나를 선택하고, 전방전달 유닛이 ALU 입력을 선택하기 때문에 가장 쉬운 해결책은 ForwardB 멀티플렉서 출력과 부호있는 수치 중 하나를 선택하는 2:1 멀티플렉서를 추가하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/7f0ca8d2-25c2-41de-a77c-0bcdbfc6f9d2">
</div>
