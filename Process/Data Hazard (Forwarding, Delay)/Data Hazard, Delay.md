-----
### 데이터 해저드와 지연
-----
1. 전방전달이 해결하지 못하는 문제 중 하나 : 적재 명령어를 뒤 따르는 명령어가 적재 명령어에서 쓰기를 행하는 레지스터를 읽으려고 시도할 때
<div align="center">
<img src="https://github.com/user-attachments/assets/6eae201d-bc5e-4451-85d9-9886b334466f">
</div>

   - 클럭 사이클 4에서 적재 명령어가 메모리를 읽고 있는데, ALU가 이미 그 다음 명령어를 위한 연산을 수행
   - 따라서, 적재 명령어 뒤에 이 결과값을 읽는 명령어가 뒤따라 나오면 누군가가 파이프라인을 지연시켜야 함

2. 전방전달 유닛 외에도 해저드 검출 유닛(Hazard Detection Unit)도 필요
   - 이 유닛은 ID 단계에서 동작하여 적재 명령어와 결과값 사용 사이에 지연을 추가할 수 있도록 함
   - 적재 명령어만 검사하면 되므로 해저드 검출 유닛에 대한 제어는 단 한가지 조건을 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/0631991e-86d7-45cc-b226-4646da4f9fd8">
</div>

   - 첫 번째 줄은 명령어가 적재 명령어인지 검사하는 것 : 데이터를 읽는 명령어는 적재 명령어 뿐이기 때문임
   - 다음 두 줄은 EX 단계에 있는 적재 명령어의 목적지 레지스터 필드가 ID 단계에 있는 명령어의 근원지 레지스터와 같은지 검사
     + 조건이 충족되면 명령어는 한 클럭 사이클만큼 지연
     + 한 클럭 사이클 지연 후에는 전방전달 회로가 종속성을 처리할 수 있으므로 실행은 계속 진행 (만약 전방전달이 없다면, 한 사이클 더 지연되어야 함)

   - ID 단계에 있는 명령어가 지연되면 IF 단계에 있는 명령어는 자동적으로 지연
     + 그렇지 않으면, 인출한 명령어를 잃게 되며, 이 두 명령어의 진행을 막으려면 PC와 IF / ID 파이프라인 레지스터만 변하지 않게 하면 됨
     + 이 레지스터 값들이 그대로 유지되면, IF 단계는 PC 값을 이용하여 똑같은 명령어를 다시 읽고, ID 단계는 IF / ID 파이프라인 레지스터의 같은 명령어 필드를 이용하여 rs, rt 레지스터를 다시 읽음
     + 즉, 세탁소 비유를 하자면, 세탁기는 같은 옷을 게속 빨고, 건조기는 빈 채로 돌리는 것과 같음

3. ID 단계의 명령어가 EX 단계로 넘어간 후에도 파이프라인을 무엇인가를 처리해야 하는데, 이 때 파이프라인이 하는 일은 아무런 효과도 없는 명령어 nop을 실행하는 것 (nop : 상태를 바꾸는 연산을 전혀 하지 않는 명령어)
   - nop을 파이프라인에 삽입하는 방법
<div align="center">
<img src="https://github.com/user-attachments/assets/16bd5ccb-57d7-469a-a5f6-a30842d4ae47">
</div>

   - EX, MEM, WB 단계의 9개 제어 신호를 모두 인가하지 않으면(즉, 0으로 만들면) 아무것도 하지 않는 명령어, 즉 nop 명령어를 만들 수 있음
   - ID 단계에서 해저드를 찾아내면 ID / EX 파이프라인 레지스터의 EX, MEM, WB 제어 필드 값을 모두 0으로 만들어서 파이프라인에 거품을 집어넣을 수 있음
   - 이 제어값들은 매 클럭마다 앞으로 전진하면서 작업을 함
   - 모든 제어값이 0이므로 레지스터나 메모리 값은 전혀 바뀌지 않음

   - AND 명령어가 들어갈 파이프라인 단계는 nop으로 바뀌며, AND 명령어는 한 사이클 씩 지연
   - 즉, 그 뒤에 있는 것을 모두 지연시키며 한 사이클에 한 단계식 명령어 파이프를 진행하고 끝에서 빠져나감
   - 이 예제에서는 해저드는 AND와 OR 명령어가 클럭 사이클 3에서 했던 것을 클럭 사이클 4에 다시 하도록 만듬
   - 즉, AND 명령어는 레지스터를 다시 읽고 다시 해독되고 OR 명령어는 명령어 메모리에서 다시 인출
   - 지연의 겉 모습은 이렇게 같은 일을 반복하는 것이지만, 이 반복의 효과는 AND와 OR 명령어 간의 시간 간격을 늘려서 add 명령어의 인출을 지연시키는 것

4. 해저드 검출 유닛과 전방전달 유닛이 어떻게 파이프라인에 연결되는지 강조해서 보여주는 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/68aa34f8-0b18-4ff9-8cf2-ef965e5f59c9">
</div>

   - 전과 같이 전방전달 유닛은 ALU 멀티플렉서를 제어하여 범용 레지스터부터 값을 받는 대신, 파이프라인 레지스터로부터 값을 받을 수 있게 함
   - 해저드 검ㅊ출 유닛은 PC와 IF / ID 레지스터에 쓰는 것을 제어할 뿐만 아니라 멀티플렉서가 실제 제어값과 0 중에서 하나를 선택하도록 함
   - 적재-사용(Load-Use) 해저드 검사가 참이면, 해저드 검출 유닛은 파이프라인을 지연시키고 제어 필드를 0으로 만듬

5. 컴파일러는 대개 하드웨어에 의존해서 해저드를 해결하고, 그렇게 함으로써 올바른 실행을 보장받지만, 최고 성능을 얻기 위해서는 컴파일러가 파이프라인을 이해해야 함
   - 그렇지 않으면, 예상하지 않았던 지연이 컴파일된 코드의 성능을 저하시킬 것

6. 레지스터나 메모리에 쓰는 것을 막기 위해 제어선들을 0으로 만든다고 한 것에서, 사실 RegWrite와 MemWrite 신호만 0으로 만들면 되고, 나머지 제어 신호들은 don't care이어도 됨
