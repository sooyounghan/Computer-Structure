-----
### 클러킹 방법론 (Clocking Methodology)
-----
1. 클러킹 방법론은 신호를 읽고 쓰는 시점을 정의
   - 클럭을 기준으로 해서 데이터가 언제 유효한 값을 가지고 언제 안정되는지를 결정하는 데 사용하는 방법
   - 신호를 읽고 있는데 동시에 누군가 새로운 값을 쓴다면, 읽은 값이 옛 값일 수 있고, 새로 쓴 값일 수 있고, 심지어는 두 값이 뒤섞인 것이 될 수 있으므로, 읽기와 쓰기 타이밍을 명확하게 지정하는 것이 중요
  
2. 에지 구동 클러킹(Edge-Triggered Clocking) 방법론
   - 에지 구동 클러킹 : 모든 상태 변화가 클럭 에지에서 일어나는 클러킹 방법
   - 즉, 순차 논리 소자에 저장된 값을 클럭 엣지에서만 바꿀 수 있다는 것을 의미
<div align="center">
<img src="https://github.com/user-attachments/assets/31329beb-3623-46bb-beaf-649b3edd160c">
</div>

   - 조합 회로를 둘러싸고 있는 2개의 상태 소자
     + 이 회로는 하나의 클럭 사이클에 동작
     + 즉, 모든 신호가 한 클럭 이내에 상태 소자 1에서 나와서 조합 회로를 거쳐 상태 소자 2까지 전달되어야 함
     + 신호가 상태 소자2에 도착하는데 필요한 시간이 클럭 사이클의 길이를 결정하게 됨

   - 클럭 에지 : 낮은 값에서 높은 값 혹은 그 반대로의 빠른 변이를 의미
   - 상태 소자들만이 데이터 값을 저장할 수 있으므로, 모든 조합 논리는 상태 소자에서 입력을 받고, 상태  소자로 출력을 내보냄
   - 조합 논리의 입력은 이전 클럭 사이클에서 상태 소자에 쓴 값들이고, 출력은 다음 클럭 사이클에서 조합 논리나 상태 소자가 사용할 수 있는 값들

3. 매 클럭 에지마다 상태 소자에 쓰기가 행해지는 경우는 앞으로 쓰기 제어 신호(Control Signal)을 표시하지 않음
   - 제어 신호 : 멀티플렉서의 입력을 선택하거나 기능 유닛의 연산을 지시하기 위해 사용되는 신호로, 기능 유닛이 연산에 사용할 정보를 가지고 있는 데이터 신호와 대비
   - 반대로, 상태 소자가 매 클럭마다 갱신되는 것이 아니라면, 쓰기 제어 신호가 분명하게 표시되어야 함
   - 클럭 신호와 쓰기 제어 신호는 상태 소자의 입력이며, 쓰기 제어 신호가 인가되고 활성화 클럭 에지일 때만 상태 소자가 변하게 됨
     + 인가된(Asserted)이라는 용어는 논리적으로 높은 신호를 의미하며, 인가(Assert)라는 용어는 신호를 높은 값으로 만든다는 뜻 (신호가 논리적으로 높은 값으로, 다른 말로는 참)
     + 논리적으로 낮은 값을 표시하기 위해서는 비인가(Deassert), 비인가된(Dasserted)이라는 용어를 사용 (신호가 논리적으로 낮은 값으로, 다른 말로는 거짓)
     + 인가, 비인가라는 용어를 사용하는 이유는 하드웨어를 구현할 때 논리적으로 1이 논리적 높은 값을 나타내기 하지만, 어떤 때는 낮은 값을 나타내기도 함

4. 에지 구동 방법론
<div align="center">
<img src="https://github.com/user-attachments/assets/08463f1b-c344-405c-9c7c-dd0a491e1b37">
</div>

   - 레지스터 내용을 읽고, 그 값을 조합 회로로 보내고, 같은 레지스터에 쓰는 작업 모두 한 클럭 사이클에 일어나는 것을 허용
   - 쓰기가 상향 클럭 에지에서 일어난다고 가정하든지, 하향 클럭 에지에서 일어난다고 가정해도 상관없는데, 조합 회로에 대한 입력은 선택된 클럭 에지에서만 변하기 때문임 (여기서는 상향 클럭 에지 사용)
   - 에지 구동 타이밍 방법론에서는 한 클럭 사이클 내 피드백(Feedback)이 되지 않으므로, 위 회로는 정상 동작

5. 32비트 MIPS가 취급하는 거의 모든 데이터가 32비트 폭을 가지므로, 이 프로세서의 상태 소자와 논리 소자 입력과 출력 폭은 거의 다 32비트
   - 어떤 입력이나 출력의 폭이 32비트가 아니면, 반드시 이를 명시할 것
   - 위 그림에서 버스(Bus)는 굵은 선으로 표시 : 버스는 폭이 2비트 이상인 신호
     + 어떤 때는 여러 버스들을 합쳐서 더 넓은 버스들을 만들기도 함
     + 예를 들면 16비트 버스 2개를 합하여 32비트 버스로 만들 수 있음
     + 이럴 경우, 버스 선에 레이블을 붙여서 더 넓을 버스를 만들기 위해 버스들을 합쳤다는 것을 명확하게 나타냄
   - 소자 간 데이터 흐름 방향을 명확히 하기 위해 화살표를 붙이기도 함
   - 끝으로 데이터를 운반하는 신호와 구별하기 위해 제어 신호는 파란색으로 나타냄

6. MIPS 구조는 64비트 버전도 있는데, 당연히 대부분 경로 폭이 64비트
