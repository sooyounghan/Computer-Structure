-----
### 데이터패스
-----
1. 데이터패스 설계를 시작하는 적절한 방법 : MIPS 명령어 종류 각각을 실행하는 데 필요한 주요 구성 요소를 살펴보는 것
2. 각 명령어들이 어떤 데이터패스 구성요소(Datapath Element)들을 필요로 하는지 살펴보는 추상화 최상위 단계부터 시작
   - 데이터패스 구성 요소 : 프로세서 안에서 데이터를 가지고 연산하거나, 데이터를 저장하는 기능 유닛
     + MIPS 구현에서는 명령어 메모리, 데이터 메모리, 레지스터 파일, ALU, 덧셈기 등 데이터 패스 구성 요소에 포함

3. 첫 번째 구성 요소
<div align="center">
<img src="https://github.com/user-attachments/assets/99b5dbd1-36b5-4d08-b8cf-60eea50639b4">
</div>

   - 명령어 메모리(Instruction Memory) : 프로그램 명령어를 저장하고 있다가 주소가 주어지면 명령어를 읽어서 보내 주는 메모리 유닛
   - 프로그램 카운터(Program Counter, PC) : PC는 현재 명령어의 주소를 가지고 있는 레지스터
   - 덧셈기 (Adder) : PC를 다음 명령어 주소로 증가시키는 덧셈기
     + 이 덧셈기는 조합 회로로서 ALU를 가지고 쉽게 만들 수 있음
     + ALU가 항상 덧셈을 하도록 제어선을 고정시키기만 하면 됨
     + 이런 ALU는 영구히 덧셈기로 만들어져서 다른 ALU 기능은 수행할 수 없으므로 Add라는 레이블을 붙이도록 함

4. 어느 명령어든지 실행하기 위해서는 메모리에서 명령어를 가져오는 것으로부터 시작해야 함
   - 그리고 다음 명령어 실행 준비를 위해 프로그램 카운터가 다음 명령어를 가리키도록 4만큼 증가
   - 세 구성 요소를 합쳐 명령어를 인출하고, PC를 증가시켜, 다음 명령어 주소를 구하는 데이터패스를 만드는 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/e94fa1b9-9444-4b3b-922d-7fdddaee8e3b">
</div>

5. R형식 명령어
   - 모든 R형식 명령어들은 2개의 레지스터를 읽고, 레지스터 내용에 ALU 연산을 수행한 후, 그 결과를 레지스터에 작성 : R형식 명령어 또는 산술 / 논리 명령어
     + 이 명령어들은 산술 연산이나 논리 연산을 행하기 때문이며, 이 명령어의 종류는 add, sub, AND, OR, slt 명령어를 포함하고 있음
     + 이러한 명령어의 전형적인 예 : add $t1, $t2, $t3 (= $t2와 $t3를 읽고 $t1에 씀)
   - 프로세서의 범용 레지스터 32개는 레지스터 파일(Register File)이라고 하는 구조 속에 존재
     + 레지스터 파일 : 접근할 레지스터 번호를 지정함으로써 읽고 쓸 수 있는 레지스터들의 집합으로 구성된 상태 소자
     + 레지스터 파일은 레지스터들을 모아 놓은 것인데, 파일 내 레지스터 번호를 지정하면 어느 레지스터라도 읽고 쓸 수 있음
     + 레지스터 파일은 컴퓨터의 레지스터 상태를 갖고 있으며, 레지스터에서 읽어들인 값을 연산하려면 ALU가 필요
   - R형식 명령어들은 레지스터 피연산자 3개를 가지고 있기 때문에, 매 명령어마다 레지스터 파일에서 데이터 워드 2개를 읽고 데이터 워드 하나를 써야 함
     + 레지스터에서 데이터 워드를 읽기 위해서는 레지스터 입력과 출력이 하나씩 필요
     + 읽을 레지스터 번호를 지정하는 입력과 레지스터에 읽은 값을 내보내는 출력이며, 데이터 워드를 쓰기 위해서는 입력이 2개 필요
     + 한 입력은 쓸 레지스터 번호를 지정하고, 다른 입력은 레지스터에 쓸 데이터 값을 제공
     + 레지스터 파일은 Read register 입력에 실리는 번호에 해당하는 레지스터 내용을 항상 출력
     + 그러나 쓰기는 쓰기 제어 신호에 의해 제어되므로 클럭 에지에서 쓰기가 일어나려면 이 제어 신호가 인가되어야 함
   - 따라서 전체적으로 4개의 입력(레지스터 번호 3개, 데이터 1개)과 2개의 출력(모두 데이터)
<div align="center">
<img src="https://github.com/user-attachments/assets/702cec0b-810b-4ef5-ad26-ed7210e4c254">
</div>

   - 레지스터 번호 입력은 32개의 레지스터 중 하나를 지정해야하므로 5비트 크기(32 = $2^{5}$)인 반면, 데이터 입력과 데이터 출력 버스 모두 32비트 폭을 가짐
   - ALU의 경우, ALU는 32비트 입력 2개를 받아서, 32비트 결과와 결과가 0이 아닌지 나타내는 1비트 신호를 만듬

6. MIPS의 워드 적재 명령어와 워드 저장 명령어
   - 이 두 가지 명령어는 일반적으로 lw $t1, offset_value($t2) 또는 sw $t1, offset_value($t2)와 같은 형식을 가짐
   - 이 명령어들은 베이스 레지스터(여기서는 $t2)와 명령어에 포함되어 있는 16비트 부호있는 변위 필드를 더하여 메모리 주소를 계산
   - 저장 명령어이면 저장할 값을 레지스터 파일에서 읽어와야 하는데, 이 값은 $t1에 존재
   - 적재 명령어이면 메모리로부터 읽어들인 값을 지정된 레지스터($t1)에 써야 함
   - 따라서, 레지스터 파일과 ALU 모두 필요

7. 그 외에도 명령어 16비트 변위 필드 값을 32비트 부호있는 값으로 부호확장(Sign-Extension, 데이터 크기를 증가시키기 위해 원래 데이터 값의 최상위 부호 비트를 폭이 더 큰 목적지 데이터 상위비트들에 복사하는 것)하기 위한 유닛이 필요하며, 또 읽고 쓸 데이터 메모리가 필요
   - 데이터 메모리는 저장 명령어 일 때만 쓰기를 해야 함
   - 따라서, 데이터 메모리는 읽기와 쓰기 제어 신호, 주소 입력, 메모리에 쓸 데이터 입력이 필요
   - 부호 확장 유닛과 데이터 메모리
<div align="center">
<img src="https://github.com/user-attachments/assets/7904a31f-65dc-44c9-83bb-01ef3cbbf0f1">
</div>

8. beq 명령어는 비교할 레지스터 2개와 16비트 변위의 세 피연산자를 가짐
   - 변위는 분기 목적지 주소(Branch Target Address)를 분기 명령어 주소에 대한 상대적인 값을 표현하는 데 사용
   - 명령어 형태 : beq $t1, $t2, offset
     + 이 명령어를 구현하기 위해서는 부호확장한 명령어 변위 필드의 값을 PC에 더해서 분기 목적지 주소를 계산해야 함
     + 분기 명령어 정의에 주의를 기울여야 할 점
       * 명령어 집합 구조는 분기 주소 계산의 베이스 주소가 분기 명령어의 다음 명령어 주소라고 명기 : 명령어 인출 데이터패스에서 PC + 4(다음 명령어 주소)를 계산하기 때문에, 이 값을 분기 목적지 주소 계산의 베이스로 사용하는 것은 어렵지 않음
       * 명령어 집합 구조는 변위 필드를 2비트만큼 오른쪽 자리이동하여 워드 변위로 만든다고 서술 : 변위 필드의 유효 범위를 4배만큼 증가
      
   - 두 번째 문제를 다루기 위해서는 필드를 왼쪽으로 2비트 자리이동해야 함
     + 분기 목적지 주소만 계산하면 되는 것이 아니고, 실행할 다음 명령어가 분기 명령어 뒤에 있는 명령어가 될지 아니면 분기 목적지 주소에 있는 명령어가 될지 판단해야 함
     + 조건이 사실일 때(즉, 두 피연산자의 값이 같을 때) 분기 목적지 주소가 새로운 PC 값이 되며 분기가 일어났다(Branch Taken)라고 말함
     + 피연산자 값이 같지 않으면 증가된 PC 값이 새 PC값이 됨 (다른 보통 명령어와 같이) : 이 경우에는 분기가 일어나지 않았다(Branch Not Taken)라고 말함
       + 분기가 일어났음 : 분기 조건이 충족되어서 분기 목적지 주소가 새 PC 값이 되며, 무조건 분기 명령어는 모두 이 범주에 넣음
       + 분기가 일어나지 않았음 : 분기 조건이 거짓이어서 분기 명령어 다음에 나오는 명령어 주소가 새 PC 값이 됨

9. 따라서 분기 데이터패스는 분기 목적지 주소를 계산하고 레지스터 내용을 비교하는 두 가지 일을 해야 함
    - 분기는 데이터패스의 명령어 인출 부분에도 영향을 미침
    - 분기를 다루는 데이터패스 부분
<div align="center">
<img src="https://github.com/user-attachments/assets/87263975-b9ba-4a3d-bacf-b5593cfc08d5">
</div>

   - 분기 목적지 주소를 계산하기 위해서 분기 데이터패스에는 부호 확장 유닛과 덧셈기가 있음
   - 비교 연산을 수행하기 위해서는 레지스터 피연산자 2개가 필요하고, 이들을 읽기 위해서는 레지스터 파일이 필요
   - 비교 연산은 이 외에도 설계한 ALU를 사용 : ALU는 결과가 0인지를 나타내는 출력 신호를 제공하므로, 두 레지스터 피연산자를 제어 신호와 함께 ALU에 보내 뺄셈을 함
     + ALU의 Zero 신호가 인가되면 두 값이 같다는 것을 의미
     + Zero 출력은 연산 결과가 0인지 아닌지를 항상 표시하지만, 분기 명령어의 같은지 여부 테스트에서만 사용하도록 함

10. 점프(Jump) 명령어는 명령어의 하위 26비트를 2비트만큼 왼쪽으로 자리이동한 값으로 PC의 하위 28비트를 대체
    - 이 자리 이동은 점프 변위 뒤에 00만 덧붙이면 됨

11. MIPS 명령어 집합 분기 : 지연 분기(Delayed Branch)
    - 분기 조건이 참이건, 거짓이건 상관없이 다음 명령어를 항상 실행하는 분기 종류
    - 조건이 거짓이면 보통 분기처럼 실행
    - 조건이 참이면 지연 분기 명령어 바로 다음 명령어를 먼저 실행하고, 지정된 분기 목적지 주소로 건너뜀
    - 지연 분기를 사용하게 된 동기는 파이프라이닝이 분기에 미치는 영향 때문임
      
