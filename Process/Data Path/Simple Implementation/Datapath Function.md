-----
### 데이터패스 동작
-----
1. 제어 신호가 0인 멀티플렉서는 제어선이 진하게 표시되지 않는다고 아무 일도 안하는 것이 아닌, 0번 입력을 선택하는 분명한 동작만 취한다는 점
2. R형식 명령어 add $t1, $t2, $t3를 실행하는 데이터패스 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/e69c12e5-f932-451c-a95c-aef8c59b74ab">
</div>

   - 실제로는 모든 일이 한 클럭 사이클 내에서 발생
   - 명령어 실행 과정을 네 단계로 나눌 수 있음
     + 명령어를 인출하고 PC를 증가
     + 레지스터 파일에서 두 레지스터 $t2, $t3을 읽음, 동시에 주 제어 유닛은 제어선의 값들을 결정
     + ALU는 레지스터 파일에서 읽어들인 값들에 대해 연산을 하는데, 기능 코드(명령어 funct 필드인 5:0)를 사용하여 ALU 제어 신호를 만듬
     + ALU 결과값을 레지스터 파일에 쓰되, 명령어 비트 15:11를 이용해 목적지 레지스터($t1)를 선택

3. 워드 적재 명령어 실행 : lw $t1, offset($t2)
<div align="center">
<img src="https://github.com/user-attachments/assets/1435f959-021f-4f76-a257-22877e67c725">
</div>

   - 적재 명령어를 위한 활성화된 기능 유닛과 인가된 제어선들을 보줌
   - 적재 명령어는 다섯 단계로 동작
     + 명령어는 명령어 메모리에서 인출하고 PC 값을 증가
     + 레지스터 파일에서 레지스터 $t2를 읽음
     + ALU는 레지스터 파일에서 읽어들인 값과 명령어의 하위 16비트(offset)를 부호확장한 값의 합을 구함
     + 이 합을 데이터 메모리 접근을 위한 주소로 사용
     + 메모리 유닛에서 가져온 데이터를 레지스터 파일에 쓰며, 목적지 레지스터($t1)는 명령어의 비트 20:16이 지정

4. beq $t1, $t2, offset과 같은, 같을 시 분기 명령어의 동작 (R형식 명령어와 비슷하게 동작)
   - 그러나 PC에 PC + 4를 넣을 것인지, 아니면 분기 목적지 주소를 넣을 것인지 결정하기 위해 ALU 출력을 사용하는 것이 다름
<div align="center">
<img src="https://github.com/user-attachments/assets/036806e3-3cd9-4fbb-982b-eed1ed002afe">
</div>

   - 실행의 네 단계
     + 명령어를 명령어 메모리에서 인출하고 PC 값 증가
     + 레지스터 파일에서 두 레지스터 $t1과 $t2를 읽음
     + ALU는 레지스터 파일에서 읽어 들인 값들에 대해 뺄셈을 함 : 명령어의 하위 16비트(offset)를 부호확장 한 후, 2비트 왼쪽 자리이동한 값에다 PC + 4 값을 더하는데, 이 값이 분기 목적지 주소
     + 어떤 덧셈기의 결과를 PC에 저장할지 ALU의 Zero 출력을 이용해 결정
