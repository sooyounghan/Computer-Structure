-----
### 단순한 구현
-----
1. 데이터패스에 단순한 제어 기능 추가 : 워드 적재(lw), 워드 저장(sw), 같을 시 분기(beq), 산술 / 논리 연산 명령어인 add, sub, AND, OR, set on less than 명령어 포함
2. 차후 점프 명령어(j) 포함

-----
### ALU 제어
-----
1. MIPS ALU는 제어 입력 4개의 다음 여섯 가지 조합 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/47781631-06b2-4e65-9460-b07936789fee">
</div>

2. ALU는 명령어 종류에 따라 첫 다섯 가지 기능 중 하나 수행 (NOR은 구현하는 부분집합에 포함되지 않은 다른 MIPS 명령어 구현에 필요)
   - 워드 적재, 워드 저장 명령어의 경우에는 메모리 주소를 계산하기 위해 덧셈을 하는 데 ALU 사용
   - R형식 명령어의 경우 명령어 하위 6비트의 funct 필드 값에 따라 다섯 가지 연산(AND, OR, subtract, add, set on less than) 중 하나 수행
   - 같을 시, 분기 명령어의 경우에 ALU는 밸셈을 수행

3. 명령어의 funct 필드와 2비트 제어 필드(ALUOp이라 불림)를 입력으로 갖는 제어 유닛을 만들어 4비트 ALU 제어 입력을 발생시킬 수 있음
   - ALUOp은 수행할 연산이 덧셈(00)인지(lw와 sw 명령어), 뺄셈(01)인지(beq 명령어), 아니면 funct 필드에 따라 달라지는지(10)를 표시
   - ALU 제어 유닛 출력은 4비트 신호인데, 이 신호가 앞서 말한 4비트 조합 중 하나가 되어서 ALU를 직접 제어

4. ALUOp 제어와 6비트 funct 필드를 사용해 어떻게 ALU 제어 입력을 만드는 지 보여주는 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/e748e534-3913-4eb9-ac68-e6572f7df430">
</div>

   - 주 제어 유닛이 ALUOp 비트를 생성하고, ALU 제어 유닛은 이것을 입력으로 받아 ALU를 제어하는 실제 신호를 만들어 내는 다단계 해독은 많이 쓰이는 구현 기법
   - 다단계 제어를 사용하면 주 제어 유닛의 크기를 줄일 수 있으며, 또한, 여러 개의 작은 제어 유닛을 사용하는 것은 제어 유닛 속도를 증가시킬 수 있음
   - 제어 유닛 속도가 클럭 사이클 시간에 가장 큰 영향을 미치는 경우가 많으므로, 이러한 최적화는 중요함

5. 2비트 ALUOp와 6비트 funct 필드를 4비트 ALU 연산 제어 비트로 사상시키는 방법
   - funct 필드가 가질 수 있는 값 64개 중에서 겨우 몇 개만이 사용되며, 그것도 ALUOp가 $10_{2}$일 때만 사용되므로, 가능한 값들 중 일부만 받아들여 ALU 제어 비트를 만들어 내는 조그만 논리 회로를 사용할 수 있음
   - 4비트 ALU 제어 신호(Operation)를 위한 진리표 (입력이 가질 수 있는 모든 값을 나열하고 각 경우의 출력값을 보이는 논리 연산 표현 방법)
<div align="center">
<img src="https://github.com/user-attachments/assets/339007fe-d555-40f8-9089-08135645db25">
</div>

   - 이 진리표(Truth Table)는 두 가지 입력 필드 값에 따라 4비트 ALU 제어값이 어떻게 설정되는지 보여줌
     + 완전한 진리표는 매우 클 뿐만 아닐($2^{8} = 256$개), 많은 입력 값에 대해 ALU 제어값이 전혀 상관없기(Don't care) 때문에, ALU 제어가 반드시 특정한 값을 가져야 하는 경우에만 표시
     + 출력이 모두 0이나 Don't care인 엔트리는 빼고 출력이 1이 되어야 하는 엔트리만을 진리표에 나타내는 이 방법을 게속 사용

   - 일부 입력 값에 대해서는 관심이 없는 경우가 많고, 표는 작게 유지하는 것이 좋음 : don't care 항 사용 (입력에 어떤 값이 되더라도 출력에 영향을 미치지 않는 논리 함수 요소, don't care 항은 여러 가지 방법으로 표시될 수 있음)
     + 이 진리표의 don't care 항(입력 열에 X로 표시)은 출력이 이 열에 해당하는 입력과 상관없다는 뜻
     + 에를 들어, 위 표의 첫 행이 ALUOp 비트값이 00이면, funct 필드 값에 상관 없이 ALU 제어 신호가 0010 : 이 경우 이 행의 funct 필드 입력은 don't care

   - 진리표가 만들어지면 이를 최적화하고, 그 다음에 게이트로 변경
