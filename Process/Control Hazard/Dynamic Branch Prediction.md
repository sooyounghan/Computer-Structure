-----
### 동적 분기 예측
-----
1. 분기가 일어나지 않는다고 가정하는 것도 분기 예측의 한 방법
   - 이 경우에는 분기가 일어나지 않을 것이라고 에측하는 것이며, 예측이 틀렸을 경우에는 파이프라인을 쓸어내는 것
   - 단순한 다섯 단계 파이프라인의 경우에는 이러한 방법이 적당할 것이며, 컴파일러 기반 예측 방법과 함께 사용할 수 있음
   - 하지만, 파이프라인이 더 깊어지면 분기 손실이 증가하며, 이 때의 손실은 클럭 사이클 단위로 계산함
   - 다중 내보내기 파이프라인의 경우에도 분기 손실이 증가하는데, 이 때의 손실은 잃어버린 명령어 수로 계산
   - 이 둘을 같이 생각하면 공격적인 파이프라인에서 단순한 정적 예측 방법은 너무나 많은 성능 손실을 초래할 것으로 보임
   - 이 외에도 더 많은 하드웨어를 사용하여 프로그램 실행 중 분기 행동을 예측하는 방법을 시도해볼 수 있음

2. 한 가지 방법은 명령어 주소를 조사해 이 분기 명령어가 지난번에 실행되었을 때 분기했는지 알아보는 것
   - 만약 분기가 일어났다면, 지난번과 같은 주소에서 새로운 명령어를 가져오도록 하는데, 이 기법을 동적 분기 예측(Dynamic Branch Prediction)
   - 동적 분기 예측 : 실행 정보를 이용해 실행 중에 분기를 예측하는 것

3. 동적 분기 예측을 구현하는 한 가지 방법은 분기 예측 버퍼(Branch Prediction Buffer) 또는 분기 이력표(Branch History Table)라고 하는 자료 구조를 이용하는 것
   - 분기 예측 버퍼 : 분기 이력표라고도 하며, 분기 명령어의 하위 주소에 의해 인덱스 되는 조그만 메모리로, 분기 명령어의 최근 분기 여부를 나타내는 하나 이상의 비트를 가지고 있음
   - 이 메모리에는 지난번 실행 시에 분기가 일어났는지, 안 일어났는지를 나타내는 비트가 존재
   - 이는 가장 간단한 종류의 버퍼로, 사실상 에측이 옳은지, 그른지는 모름
   - 심지어 하위 주소 비트만 같은 전혀 다른 분기 명령어의 분기 정보가 버퍼에 저장되었을 수 있음 : 그렇다 하더라도, 프로그램 실행 결과의 정확성(Correctness)에는 영향을 미치지 않음
   - 예측은 단지 맞기를 바라고 사용하는 힌트이므로, 예측된 방향에서 명령어를 가져올 뿐임
     + 만일 힌트가 잘못된 것으로 판명되면, 잘못 가져온 명령어는 삭제하고, 예측 비트를 바꾼 후 올바른 순서의 명령어를 인출하여 실행
   - 이 간단한 1비트 예측 방법은 성능에 문제가 존재 : 거의 매번 분기하다가 어쩌다 한 번 분기하지 않을 때, 한 번이 아닌 두 번의 잘못된 에측을 할 수 있음

4. 예) 순환문과 예측 : 아홉 번 연속해서 분기한 후 한 번 분기하지 않은 순환문 분기 가정할 때, 이 분기를 위한 예측 비트가 예측 버퍼에 있을 때, 이 분기의 예측 정확도
   - 안정 상태의 예측 행위는 첫 번째와 마지막 순환문 반복에서 예측을 잘못한 것
   - 마지막 반복에서의 예측 잘못은 예측 비트가 분기가 일어날 것이라고 말해주기 때문에 피할 수 없음
   - 왜냐하면, 분기가 이 시점까지 연속해서 아홉 번 일어났기 때문이며, 순환문에서 빠져나오는 마지막 실행에서는 분기하지 않았으므로, 예측 비트가 반전되었고, 이 때문에 첫 번째 반복에서의 예측이 틀리지 않는 것
   - 따라서, 실제는 90%의 분기가 일어나지만 예측의 정확도는 80%에 지나지 않음 (두 번의 예측 잘못과, 여덟 번의 정확한 예측)

5. 이상적으로 이렇게 아주 규칙적인 분기에 대한 예측기 정확도는 실제 분기 횟수와 일치해야 함
   - 이 같은 약점을 보완하기 위해 예측 비트를 더 많이 사용할 수 있음
   - 2비트를 사용하는 예측 방법에서는 예측이 두 번 연속 잘못되었을 때, 예측 값이 변경
   - 2비트 예측 방법을 위한 유한 상태기
<div align="center">
<img src="https://github.com/user-attachments/assets/41aae0fe-e0e0-4108-ae14-2d730ccff7ee">
</div>

   - 분기 예측 버퍼는 작은 특수 버퍼로 구현될 수 있는데, 이 버퍼는 IF 파이프라인 단계에서 명령어 주소로 접근
   - 분기가 일어난다고 예측되면 PC 값이 구해지자마자 목적지 주소에서 명령어를 가져옴
   - ID 단계처럼 이른 시기에 일어날 수 있으며, 분기가 일어나지 않는다고 예측되면 순차 주소에서 명령어를 가져오고 실행이 계속됨
   - 예측이 잘못된 된 것으로 판명되면, 예측 비트값이 변경

6. 다섯 단계의 파이프라인에서 분기 명령어를 다시 정의함으로써 제어 해저드를 하나의 특성으로 만들 수 있음
   - 지연 분기(Delayed Branch)는 항상 분기 다음 명령어를 실행하지만, 분기 명령어 다음의 다음 명령어는 분기 명령어에 의해 영향을 받음
   - 컴파일러와 어셈블러는 분기 명령어 후에도 항상 실행되는 명령어를 분기 지연 슬롯(Branch Delay Slot)에 넣으려고 노력
   - 분기 지연 슬롯을 스케줄할 수 있는 세 가지 방법
     + 분기 지연 슬롯 : 분기 명령어 바로 뒤의 슬롯, MIPS 구조에서 이 슬롯은 분기 명령어에 영향을 주지 않는 명령어로 채워짐
<div align="center">
<img src="https://github.com/user-attachments/assets/d8548fe2-62a4-4d4e-b835-1dc53d6bedb4">
</div>

   - 지연 분기 스케줄링을 제약하는 원인 : 지연 슬롯에 스케줄링되는 명령어에 대한 제약 / 분기가 일어날 것이냐, 안 일어날 것이냐를 컴파일 시에 예측하는 능력의 한계 ㄷ 가지
   - 지연 분기는 매 클럭 사이클마다 하나의 명령어를 내보내는 다섯 단계 파이프라인의 경우에도 간단하면서도 효과적인 해결책
   - 하지만 프로세서들이 더 긴 파이프라인과 한 클럭 사이클에 다수의 명령어를 보내는 쪽으로 발전하면서 분기 지연이 길어져서 지연 슬롯 하나만으로 충분하지 않게 됨
   - 따라서 좀 더 비싸지만 유연성 있는 동적 접근 방법들에 대해 지연 분기는 인기를 잃어가고 있으며, 칩당 가능한 트랜지스터 개수가 증가함으로 동적 예측 방법으로 상대적으로 싸짐
     + MIPS 칩 전체에 있었던 트랜지스터 개수보다 최신 마이크로프로세서 분기 예측기에 더욱 많은 트랜지스터가 들어가있음

6. 분기 예측기가 분기가 일어날 것인지, 아닌지는 알려주지만, 분기 목적지는 따로 계산해야 함
   - 다섯 단계 파이프라인에서는 이 계싼이 한 사이클이 걸림 : 이는 분기가 일어나는 경우 한 사이클 손실이 발생했다는 것을 의미
   - 지연 분기는 이러한 손실을 없애는 한 가지 방법
   - 이 외에 분기 목적지 버퍼(Branch Target Buffer)를 사용해 목적지 프로그램 카운터나 목적지 명령어를 가지고 있는 캐시를 사용하는 방법도 존재
     + 분기 목적지 버퍼 : 분기 명령어의 목적지 PC 값이나 목적지 명령어를 저장하는 구조, 보통 태그가 있는 캐시로 구성되기 때문에 단순 예측 버퍼보다 구현 비용이 더욱 비쌈

   - 2비트 동적 예측 기법은 에측하려는 분기 명령어에 대한 정보만을 이용
     + 해당 분기 명령어에 대한 지역적 정보 외에 최근에 실행된 분기 명령어들의 전역적 행동에 대한 정보를 함께 이용하면 같은 크기의 예측 비트들을 사용하고도 더 정확한 예측을 할 수 있음
     + 이러한 예측기를 연관 예측기(Correlating Prediector)라 부르며, 전형적인 연관 예측기는 각 분기에 대해 2개의 2비트 예측기를 사용하는데, 직전에 실행된 분기 명령어가 분기를 했느냐, 하지 않았느냐에 따라 두 에측기 중 하나를 선택
       * 연관 예측기 : 해당 분기 명령어의 지역적 행동과 최근에 실행된 분기 명령어 및 몇 개의 행동에 대한 전역적 정보를 조합하는 분기 예측기
     + 따라서, 전역적 분기 행동은 예측값 조회에 사용할 인덱스 비트를 추가하는 것으로 생각할 수 있음

   - 더 최근에 개발된 분기 예측 기술은 토너먼트 예측기(Tourament Predictor)를 사용하는 것
     + 토너먼트 예측기 : 각 분기에 대해 여러 개의 예측기와 그 중 어느 예측기를 사용할 것인지 결정하는 선택 매커니즘을 가지고 있는 분기 예측기 (즉, 각 분기에 대해 다수의 예측기를 사용하며, 어떤 예측기가 가장 좋은 결과를 내는지 추적)
     + 전형적인 토너먼트 예측기는 각 분기 인덱스에 대해 2개의 예측을 함
       * 하나는 지역적 정보에 기인한 예측
       * 다른 하나는 전역적 분기 행동에 기반한 예측
     + 선택기는 어느 예측기를 사용할 것인지 결정하며, 1비트 예측기든, 2비트 예측기든 똑같이 작용하는데, 두 예측기 중 더 정확했던 예측기를 선택
     + 최근에 개발된 많은 마이크로프로세서들은 이 같은 정교한 예측기들을 사용

7. 조건부 분기 명령어의 수를 줄이는 한 가지 방법은 조건부 이동(Conditional Move) 명령어를 추가하는 것
   - 조건부 분기 명령어로 PC 값을 바꾸는 대신에 이 명령어는 move의 목적지 레지스터를 조건부로 변경
   - 만약 조건이 실패하면 move 명령어는 nop처럼 행동
   - 예를 들어, MIPS 명령어 집합 구조의 어떤 버전은 movn(move if not zero)과 movz(move if zero)라는 새로운 2개 명령어를 가지고 있는데, 가령 movn $8, $11, $4라는 명령어는 레지스터 4의 값이 0이 아니면, 레지스터 11의 내용을 8에 복사하고, 0이면 아무런 일을 하지 않음
   - ARMv7 명령어 집합은 거의 모든 명령어가 조건부 필드를 가지므로, ARM 프로그램들은 MIPS 프로그램보다 적은 수 조건부 분기 명령어를 갖게 됨
