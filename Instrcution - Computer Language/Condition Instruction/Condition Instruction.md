-----
### 판단을 위한 명령어
-----
1. 컴퓨터가 단순한 계산기와 다른 점은 판단 기능이 있는 것
   - 입력 데이터나 연산 결과에 따라 다른 명령어를 실행할 수 있음
   - 프로그래밍 언어에서 보통 if 문장으로 (때에 따라서 go to문과 레이블을 함께 써서) 판단 기능을 표현
```
beq register1, regsiter2, L1
```
   - register1과 register2의 값이 같으면 L1에 해당하는 문장으로 가라는 뜻
   - beq는 branch if equal을 의미
```
bne register1, register2, L1
```
   - register1과 register2의 값이 같지 않으면 L2으로 가라는 뜻
   - bne는 branch if not equal을 의미

2. beq와 bne 두 명령어는 조건부 분기(Conditional Branch)
   - 조건부 분기 : 두 값의 비교가 필요한 명령어로 비교 결과에 따라 프로그램 내 새로운 주소로 제어를 넘길 수 있음

3. 예제) if-then-else 조건부 분기로 번역
   - f, g, h, i, j는 변수이고, 각각은 레지스터 $s0부터 $s4에 해당
```c
if (i == j) f = g + h: else f = g + h;
```
  - MIPS 코드가 해야되는 순서도
<div align="center">
<img src="https://github.com/user-attachments/assets/920a9d09-88d9-4ebd-87c3-e0852ecea38d">
</div>

   - 첫 번째 부분은 같은지를 비교하는 것으로 : beq로 번역
   - 그러나 실제로 조건을 반대로 검사해서 then 부분을 건너뛰게 하는 것이 더 효율적이므로 ben을 사용
```
ben $s3, $s4, Else    # i ≠ j 진행
```
   - 다음 치환문은 연산 하나를 실행하는 것이므로 피연산자가 모두 레지스터에 있다면 명령어 하나로 번역
```
add $s0, $s1, $s2     # f = g + h (만약 i ≠ j라면, 넘김)
```
   - 이 문장을 실행한 후에는 if 문 끝부분으로 이동 : 무조건 분기(Unconditional Branch)라는 새로운 종류의 분기 명령으로 해결
     + 이 명령어는 프로세서에게 항상 분기하라고 말함
     + MIPS에서는 이 같은 명령어에 jump 라는 이름을 붙이고 간략하게 j로 사용
```
j Exit    # Exit로이동
```
   - else 부분 치환문도 역시 명령어 하나로 번역 : 단, 이 명령어에는 Else라는 레이블을 붙여야 함
     + 이 명령어 뒤에는 if-then-else 문장의 끝을 표시하는 Exit란 레이블을 붙임
```
Else: sub  $s0, $s1, $s2    # f = g - h (만약 i = j라면, 넘김
Exit:
```
   - 어셈블러가 컴파일러나 어셈블러 언어 프로그래머가 귀찮은 분기 주소 계산을 하지 않도록 해줌
   - 이는 마치 적재와 저장 명령어의 데이터 주소를 계산해주는 것과 같음

4. 컴파일러가 소스 프로그램에는 없는 분기 명령이나 레이블을 만드는 경우가 많음
   - 필요한 레이블과 분기 명령을 일일히 표시하지 않아도 되는 것이 상위 수준 프로그래밍 언어의 장점 중 하나
   - 상위 수준의 언어를 사용하면 코딩이 더 빨라짐
