-----
### 순환문
-----
1. 판단 기능은 둘 중 하나를 선택하는데도 중요하지만, 계산의 반복에도 중요
2. 순환문 역시 판단 기능과 같은 어셈블리 명령어가 사용
3. 예) while 순환문의 번역
```c
while (save[i] == k)
    i += 1;
```
   - i와 k가 레지스터 $s3와 $s5에 할당되었고, 배열 save의 시작 주소가 $s6에 저장되었다고 가정
   - save[i]를 임시 레지스터로 가져오는 것 : save[i]를 임시 레지스터에 적재하려면 먼저 그 주소를 구해야 함
     + 바이트 주소를 사용하므로 인덱스 i에 4를 곱해서 save의 시작 주소에 더해야 주소가 만들어짐
     + 2비트씩 왼쪽 자리이동을 하면 4를 곱한것과 같으므로, sll 연산을 사용할 수 있음
     + 순환의 끝에서 처음 명령어 되돌아갈 수 있도록 Loop 라는 레이블 추가
```
Loop: sll  $t1, $s3, 2    # 임시레지스터 $t1 = i * 4
```
   - save[i]의 주소를 계산하기 위해 $t1 값에다 $s6에 있는 save 시작 주소 값을 더함
```
add  $t1, $t1, $s6        # $t1 = save[i]의 주소
```
   - 이 주소를 이용해 save[i]를 임시 레지스터에 넣을 수 있음
```
lw   $t0, 0($t1)          # 임시 레지스터 $t0 = save[i]
```
   - 반복 검사를 수행해서 save[i] = k이면 순환에서 빠져나가는 부분
```
bne  $t0, $s5    # save[i] = k라면, Exit로 이동
```
   - i에 1을 더하는 명령어
```
addi $s3, $s3, 1 # i = i + 1
```
   - 순환문의 끝에서는 맨 앞의 while 조건 검사로 되돌아가야 하며, 그리고 이 명령의 다음에 Exit 레이블을 두면 번역이 끝남
```
j    Loop        # Loop로 이동
Exit:
```

4. 기본 블록(Basic Clock)
   - 분기 명령어로 끝나는 명령어 시퀀스는 컴파일러에 특히 중요한 의미가 있으므로 기본 블록이라는 별칭이 존재
   - 기본 블럭이란 분기 명령을 포함하지 않으며(맨 끝에 있을 수 있음), 분기 목적지나 분기 레이블도 없는(맨 앞에 있는 것은 허용) 시퀀스
   - 컴파일의 초기 단계 작업 중 하나는 프로그램을 기본 블록으로 나누는 일

5. 같은지 다른지 비교하는 것이 아마도 가장 흔한 검사이지만, 경우에 따라서는 두 변수 간의 대소 비교가 필요할 때도 존재
   - 예를 들어, for 순환문에서 인덱스 변수 값이 0보다 작은지 검사하는 것은 흔한일
   - MIPS에서는 slt(set on less than) 명령어로 이런일을 처리
     + slt는 두 레지스터의 값을 비교한 후, 첫 번째 레지스터 값이 두 번째 레지스터의 값보다 작으면 세 번째 레지스터 값을 1, 아니면 0으로 하는 명령어
```
slt   $t0, $s3, $s4    # $s3 < $s4라면, $t0 = 1
```
   - 상수 피연산자는 비교에서도 많이 이용 : 따라서, 상수 피연산자를 갖는 slt 명령어가 필요
     + 레지스터 $s2가 상수 10보다 작은지 검사하려면 다음과 같이 쓰면 됨
```
slti $t0, $s2, 10      # $s2 < 10라면, $t0 = 1
```

6. MIPS 컴파일러는 slt, slti, beq, bne와 레지스터 $zero에 있는 상수 0을 이용해서 모든 비교 조건(같다, 다르다, 작다, 작거나 같다, 크다, 크거나 같다)을 만들 수 있음 (레지스터 $zero는 0번 레지스터를 가리킴)
7. 하드웨어는 간단헤야 하는 MIPS 구조에서 구현하기에 너무 복잡한 blt(branch on less than) 명령어를 제외시킴
   - 이 명령어를 구현하면, 클럭 속도가 느려지거나 이 명령 실행에 별도의 클럭 사이클이 더 필요하게 되므로, 빠른 명령어 2개를 사용하는 것이 더 유리

8. 비교 명령은 부호있는 수와 부호없는 수 두 가지를 다룰 수 있어야 함
   - 어떤 때는 MSB가 1인 수가 음수를 나타내며, 이 때는 당연히 MSB가 0인 어떤 양수보다도 작음
   - 하지만, 부호없는 정수의 경우에는 MSB가 1인 수가 MSB가 0인 어떤 수보다 더 큼
   - MIPS는 이 두 가지 비교를 다 처리할 수 있도록 두 종류의 set on less than을 제공
     + slt(set on less than)와 slti(set on less than immediate)는 부호있는 정수 비교
     + sltu(set on less than unsigned)와 sltiu(set on less than immediate unsigned)는 부호없는 정수 비교에 사용

9. 예) 부호 있는 수의 비교와 부호없는 수의 비교
   - 레지스터 $s0
<div align="center">
<img src="https://github.com/user-attachments/assets/0a7ad8ad-09ec-4539-980f-cd2b17df3ae5">
</div>

   - $s1
<div align="center">
<img src="https://github.com/user-attachments/assets/7bac4725-2c2f-491d-8a16-e688c535d78e">
</div>

   - 다음 두 명령어의 실행 후 $t0와 $t1의 값
<div align="center">
<img src="https://github.com/user-attachments/assets/ee3fe0b4-80da-4628-a104-fcc46ae3446e">
</div>

   - $s0의 값을 부호있는 정수로 보면 -1이고, 부호없는 정수로 보면 4,294,967,295
   - $s1의 값은 두 경우 모두 1
   - -1 < 1이므로, $t0의 값은 1이고, 4,294,967,295 > 1이므로 $t1의 값은 0

10. 부호있는 정수를 부호없는 정수처럼 다루면 0 ≤ x < y의 검사 비용을 낮출 수 있는데, 이 검사는 인덱스가 배열의 한계를 벗어났는지 확인하는 검사에 적합
    - 핵심은 2의 보수로 표현된 음수가 부호없는 정수로 보면, 매우 큰 수 처럼 보임
    - 즉, 2의 보수 표현에서는 MSB가 부호 비트이지만, 부호 없는 정수에서는 크 값을 의미
    - 따라서, 부호없는 비교 x < y를 하면, x가 y보다 작은지 뿐만 아니라 x가 y보다 작은지뿐만 아니라 x가 음수인지도 검사할 수 있음

11. 빠른 경계 검사 방법
    - 인덱스가 경계를 넘는지 검사하는 데 필요한 명령어 수
    - $s1 ≥ $t2 이거나 $s1이 음수이면 IndexOutOfBounds로 분기
    - sltu를 이용하면 두 가지를 동시에 검사할 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/04a2d6d8-16e0-470c-a7d7-45eaa3730e44">
</div>
 
