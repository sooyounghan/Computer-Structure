-----
### 병행성과 명령어 : 동기화
-----
1. 테스크가 서로 독립적일 때는 병렬 처리가 쉽지만, 협력해야 하는 경우가 존재
   - 협력은 보통 다른 테스크들이 읽어야 하는 새로운 값을 어떤 테스크가 쓰고 있음을 의미
   - 테스크가 언제까지 쓰기를 마쳐야 다른 테스크들이 안전하게 읽을 수 있는지 알려면 테스크 동기화가 필요
   - 테스크들이 동기화되지 않으면, 데이터 경쟁 관계(Data Race)의 위험이 존재
   - 이벤트가 일어나는 순서에 따라 프로그램 결과가 달라질 수 있는 상황을 데이터 경쟁관계라고 함
     + 즉, 다른 스레드에서 나온 두 메모리 접근이 같은 위치를 향하고, 그 중 적어도 하나가 쓰기이며, 이들이 잇따라서 일어날 때 데이터 경쟁 관계 형성

2. 컴퓨팅에서 동기화 메커니즘은 일반적으로 사용자 수준 소프트웨어 루틴에서 제공되는데, 이 소프트웨어 루틴들은 하드웨어가 제공하는 동기화 명령어들을 사용
   - lock과 unlock을 그대로 이용하여 단 하나의 프로세서만이 작업할 수 있는 영역을 생성할 수 있으며(상호 배제(Mutual Exlcusion), 더 복잡한 동기화 메커니즘을 구현할 수 있는데도 사용

3. 멀티프로세서에서 동기화를 구현하기 위해서는 메모리 주소에서 읽고 수정하는 것을 원자적으로(Atomically) 처리할 능력을 가진 하드웨어 프리미티브가 있어야 함
   - 즉, 메모리에서 읽고 쓰는 중간에 아무것도 끼어들 수 없어야 함

4. 기본 하드웨어 프리미티브를 대신해서 사용하는 여러 방법이 존재
   - 메모리 주소에서 읽고 수정하는 것을 원자적으로 처리하는 방법을 제공하고 있으며, 읽고 쓰는 것이 원자적으로 처리되었는지 알려 주는 방법도 함께 가지고 있음
   - 일반적으로, 컴퓨터 설계자는 기본 하드웨어 프리미티브를 일반 사용자가 쓸 것이라 생각하지 않고, 시스템 프로그래머가 동기화 라이브러리를 구축하는 데 사용할 것이라고 생각

5. 동기화 연산 구축을 위한 전형적인 연산은 원자적 교환(Atomic Exchange 또는 Atomic Swap)인데, 이 연산은 레지스터의 값을 메모리 값과 서로 맞바꾸는 것
   - lock은 0이면 사용가능하고, 1이면 사용할 수 없음을 표시한다고 가정
   - 프로세서는 레지스터에 있는 값 1과 lock에 해당하는 메모리 내용을 맞바꿈으로써 lock을 1로 만들고자 할 것
   - 만약, 다른 프로세서에서 이미 접근을 주장하였다면, 교환 명령어가 가져온 값은 1(사용 불가능)일 것이며, 그렇지 않은 경우 0(사용 가능)일 것
     + 후자의 경우에는 lock이 1로 바뀌는 일도 같이 일어나서, 다른 프로세서에 있는 경쟁관계의 교환 명령이 0을 읽어가지 못하게 함
   - 예를 들어, 동시에 교환을 시도하는 두 프로세스 가정
     + 둘 중 한 프로세서가 교환을 먼저 수행해서 0을 가져오면, 나머지 프로세스는 1을 읽을 것
     + 교환 프리미티브를 사용해서 동기화를 구현하는 핵심은 연산이 원자적이라는 것
     + 즉, 교환은 나뉠 수 없는(Indivisible) 것이라서, 교환 2개가 동시에 발생하더라도 하드웨어에 의해 순서가 결정
     + 프로세서 2개가 동시에 이런 방법으로 동기화 변수를 1로 만들려고 시도할 때, 둘 다 자기가 성공했다고 되는 경우는 발생하지 않음

   - 단일 원자적 메모리 연산을 하기 위해서는, 메모리 읽기와 쓰기를 방해가 불가능한 명령어 하나로 처리해야 하므로, 이를 구현하려면 프로세서 설계에 어려운 문제가 발생

6. 또 다른 방법은 명령어 하나가 아닌 2개로 처리하는 것
   - 두 번째 명령어는 한 쌍의 명령어가 원자적인 것처럼 실행되었는지 나타내는 값을 반환
   - 어느 프로세서에서 실행된 연산이라도 이 명령어 쌍보다 먼저 실행되든지, 나중에 실행에 실행되게 한다면, 이 한 쌍의 명령어는 실질적으로 원자적이라 말할 수 있음
   - 이 명령어 쌍이 실질적으로 원자적이라면 다른 어느 프로세서도 두 명령어 사이에서 값을 바꿀 수 없음

7. MIPS에서 이러한 명령어 쌍으로 load linked라 불리는 특수 적재 명령어와 store conditional이라 불리는 특수 저장 명령어가 존재
   - 이 명령어 쌍은 순차적으로 사용되는데, 만약 load linked 명령어에 의해 명시된 메모리 주소의 내용에 같은 주소에 대한 store conditional 명령어가 실행되기 전에 바뀐다면, store conditional 명령은 실패하게 됨
   - store conditional 명령어의 역할
     + 레지스터 값을 메모리에 저장
     + 성공하면 레지스터 값을 1로 아니면 0으로 바꾸는 일두가지를 동시에 진행

   - load linked 명령어는 초기값을 반환하고 store conditional은 성공할 때만 1을 반환하므로, 다음 명령어 시퀀스는 $s1에 있는 주소의 메모리 내용에 대해 원자적 교환을 구현하게 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/c6fe225c-3426-454a-88ab-2856737c5332">
</div>

   - ll 명령어와 sc 명령어 사이 어떤 프로세스가 끼어들어 메모리 값을 수정하면, sc는 $t0에 0을 반환하므로, again으로 가서 코드 시퀀스를 다시 실행하게 됨
   - 그러므로 이 시퀀스는 결국 $s1에 있는 메모리 주소의 내용과 $s4 사이의 원자적 교환 실시

8. 원자적 교환은 멀티프로세서 동기화를 위해 제시된 것이지만, 운영체제가 단일프로세서 내 다중 프로세스를 다루는 데도 유용
   - 단일프로세서에서 두명령어 사이 아무것도 끼어들지 못하게 하기 위해, 두 명령어 사이에서 문맥 교환이 이루어지는 경우에도 sc는 실패

9. load linked / store conditional 메커니즘의 또 다른 장점 : atomic compare and swap 또는 atomic fetch-and-increment 같은 다른 동기화 프리미티브들을 만드는 데 사용 가능
    - 이러한 프리미티브들은 여러 가지 병렬 프로그래밍 모델에서 사용됨
    - 이 모델에서는 load linked와 store conditional 사이에 명령어가 추가로 필요한 경우도 있지만, 많이 추가되지 않음
    - load linked 주소에 또 다른 저장이 시도되거나 예외가 일어나면 store conditional은 실패하기 때문에, 두 명령어 사이에 들어갈 명령어들을 고르는데 신중해야 함
    - 하지만, 레지스터-레지스터 명령어만은 안심하고 사용 가능
    - 다른 명령어들은 계속 페이지 부재를 일으켜서 프로세서가 sc를 완료할 수 없는 교착 상태(Deadlock)을 일으킬 수 있음
    - load linked와 store conditional 사이에 들어가는 명령어는 되도록 적게 해서 관련 없는 이벤트나 경쟁 프로세서가 store conditional이 자꾸 실패하게 만드는 일이 없도록 해야함
