-----
### 오류 및 함정
-----
1. 강력한 명령어를 사용하더라도 성능이 좋아지지 않는 것
   - Intel x86 명령어가 강력한 이유 중 하나는 명령어 실행 방식을 변경하는 접두사를 가지고 있기 때문임
   - 그 중 한 접두사는 카운터 값이 0이 될때까지 명령어를 반복 실행시킬 수 있음
   - 메모리 내 데이터 블록을 복사할 때 32비트 move 명령에 이 반복 접두사를 붙이면 편함
   - 접두사를 사용하지 않고, 표준 명령어만 사용해서 데이터를 레지스터에 적재했다가 다시 메모리에 저장하는 방식을 사용할 수 있음
     + 공평한 비교를 위해 순환문 오버헤드가 없도록 순환문으로 만들지 말고 명령어를 반복적으로 늘어놓는 방법을 쓰면 접두사를 쓴 것보다 1.5배 빠름
     + x86의 정수 레지스터 대신 이보다 더 큰 부동 소수점 레지스터를 사용하면 복잡한 move 명령어보다 2배 빨라짐

2. 최고 성능을 얻기 위해 어셈블리 언어로 프로그램을 작성하는 것은 옳지 않음
   - 어셈블리 언어로 프로그램을 작성하더라도 코딩과 디버깅에 더 많은 시간이 걸리고, 이식성이 없으며, 유지 보수가 어려운 문제 존재

3. 상업용 프로그램의 이진 호환성이 중요하다는 것은 성공적 명령어 집합은 변하지 않는다는 것을 의미

4. 바이트 주소를 사용하는 컴퓨터에서 인접 워드 간 주소 차이가 1이 아니라는 사실을 잊지 않을 것
   - 어셈블리 언어에서 주소를 하나 증가시키면 다음 워드를 찾을 수 있다고 생각할 수 있음

5. 자동 변수가 정의된 프로시저 외부에서 자동 변수에 대한 포인터를 사용하지 않아야 함
   - 포인터를 사용할 때, 프로시저 결과를 전달할 때 프로시저 내에서 지역 변수로 선언된 배열을 가리키는 포인터를 포함하는 것을 자주 실수할 수 있음
   - 스택 동작에 따르면, 지역 배열이 저장된 메모리 영역은 프로시저가 종료되자마자 다른 용도로 재사용
   - 따라서, 이미 없어진 자동 변수에 대한 포인터를 사용하면 예기치 못한 일이 발생할 수 있음
