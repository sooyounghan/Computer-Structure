-----
### 프로시저 레지스터
-----
1. 컴파일러가 프로시저를 번역하는 데 인수 레지스터 4개, 결과값 레지스터 2개만으로 부족한 경우
   - 프로시저 호출이 다른 부분에 영향을 미쳐서는 안 되므로, 호출 프로그램이 사용하는 모든 레지스터는 복귀하기 전 프로시저 호출 전 상태로 되돌려 놓아야 함

2. 레지스터 스필링에 이상적인 자료 구조 : 스택(Stack)
   - 스택은 나중에 들어간 것이 먼저 나오는 구조로, 스택에는 다음 프로시저가 스필할 레지스터를 저장할 장소나 레지스터의 옛날 값이 저장된 장소를 표시하기 위해 최근에 할당된 주소를 가리키는 포인터가 필요
   - 스택 포인터(Stack Pointer)는 레지스터 값 하나가 스택에 저장되거나 스택에서 복구될 때마다 한 워드씩 조정
     + 스택 포인터 : 가장 최근에 스택에 할당된 주소를 가리키는 값, 레지스터가 스필될 장소 또는 레지스터의 옛날 값을 찾을 수 있는 장소를 표시 (MIPS에서는 $sp)
     + MIPS 소프트웨어는 스택 포인터를 위해 29번 레지스터를 할당해놓고 있는데, $sp
     + 스택에 데이터를 넣는 작업을 푸시(Push), 스택에서 데이터를 꺼내는 작업을 팝(Pop)
   - 스택은 높은 주소에서 낮은 주소 쪽으로 성장 : 그러므로, 스택에 푸시를 할 때는 스택 포인터 값을 감소시켜야 하고, 스택에서 팝할 때는 스택 포인터 값을 증가시켜야 함

3. 예제) 다른 프로시저를 호출하지 않는 C 프로시저의 컴파일
```c
int leaf_example (int g, int h, int i, int j)
{
    int f;

    f = (g + h) - (i + j);
    return f;
}
```
   - 인수 g, h, i, j는 인수 레지스터 $a0, $a1, $a2, $a3에 해당하고, f는 $s0에 해당
   - 컴파일된 프로그램은 다음과 같은 프로시저 레이블로부터 시작
```
leaf_example;
```
   - 프로시저가 사용할 레지스터 값을 저장하는 것
   - 임시 레지스터 2개를 사용 : 따라서, 저장해야 할 레지스터는 $s0, $t0, $t1 3개
     + 스택에 세 워드를 저장할 자리를 만든 후, 값을 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/f14d281f-a1a7-4e61-9790-0ff72c8389ca">
</div>

   - 프로시저 본문은 명령어 3개로 번역
<div align="center">
<img src="https://github.com/user-attachments/assets/340f7093-3a76-4f49-bccf-02fe47001024">
</div>

   - 계산 결과 f를 보내주기 위해 f를 결과값 레지스터에 복사
<div align="center">
<img src="https://github.com/user-attachments/assets/fc6bbf24-998c-438d-b58e-8341adae0f09">
</div>

   - 호출 프로그램으로 되돌아가기 전 저장해두었던 값을 스택에서 꺼내 레지스터를 원상 복구
<div align="center">
<img src="https://github.com/user-attachments/assets/04d4467e-aa90-475c-9b4f-cbe5da6ffdf5">
</div>

   - 이 프로시저는 복귀 주소를 사용하는 점프 명령(jr)로 종료
<div align="center">
<img src="https://github.com/user-attachments/assets/0660853b-8ecb-46c7-aec5-faf945a87bf5">
</div>

4. 위 예제에서 임시 레지스터를 사용했는데, 임시 레지스터 값도 저장했다가 원상 복구해야 한다고 가정
5. 이를 예방하기 위해 MIPS 소프트웨어는 레지스터 18개를 두 종류로 나눔
   - $t0 ~ $t9 : 프로시저 호출 시, 피호출 프로그램이 값을 보존해 주지 않는 임시 레지스터
   - $s0 ~ $s7 : 프로시저 호출 전과 후의 값이 같게 유지되어야 하는 변수 레지스터(피호출 프로그램이 이 레지스터를 사용하면 원래 값을 저장했다가 원상 복구)

6. 이런 간단한 관계를 정함으로써, 레지스터 스필링을 많이 줄일 수 있음
   - 위 예에서 $t0과 $t1 값이 호출 전후에 같은 값을 유지할 필요가 없으므로 저장 명령 2개와 적재 명령 2개를 없앨 수 있음
   - 그러나 $s0는 피호출 프로그램 입장에서는 호출 프로그램이 이 값을 필요로 할 것을 가정하므로 저장했다가 원상 복구

