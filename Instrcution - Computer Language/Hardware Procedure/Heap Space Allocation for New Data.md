-----
### 새 데이터를 위한 힙 공간 할당
-----
1. C 프로그래머는 프로시저 내에서만 정의되는 자동 변수 외에도 정적 변수와 동적 자료구조를 위한 메모리 공간 필요
2. MIPS의 메모리 할당 방식
<div align="center">
<img src="https://github.com/user-attachments/assets/10f43912-3b78-4471-95ae-629772090cd3">
</div>

   - 스택은 최상위 주소에서부터 시작해서 아래쪽으로 자람
   - 최하의 주소 부분은 사용이 유보되어 있으며, 그 다음은 MIPS 기계어 코드가 들어가는 부분 : 이 부분은 전통적으로 텍스트 세그먼트(Text Segment)라고 부름
     + 텍스트 세그먼트 : UNIX 목적 파일에서 소스 파일 루틴의 기계어가 수록된 부분
   - 코드 위쪽에는 정덕 데이터 세그먼트(Static Data Segment)라는 부분이 존재 : 상수와 기타 정적 변수들이 들어가는 부분
     + 배열은 크기가 고정되어 있어서 정적 데이터 세그먼트에 잘 맞음
   - 그러나 링크 리스트(Linked List) 같은 자료구조는 늘어났다 줄어들엇다 하는데, 이러한 동적 자료구조를 위한 세그먼트를 전통적으로 힙(Heap)이라 부름
     + 스택과 힙이 서로 마주보면서 자라도록 할당하므로 메모리 효율적 사용 가능

3. C는 함수를 사용해 힙의 공간을 할당받기도 하고, 사용하지 않는 공간은 되돌려주기도 함
   - malloc() : 힙에 공간을 할당한 후, 이 공간을 가리키는 포인터를 결과값으로 보내줌
   - free() : 포인터가 가리키는 힙 공간을 반납
   - C에서 메모리 할당을 프로그램이 통제하는데, 사용이 끝난 공간을 반납하는 것을 잊어버리면 메모리 누출(Memory Leak)이 발생하여, 결국 메모리 부족으로 운영체제가 붕괴될 수 있음
     + 반면, 공간을 너무 일찍 반납하면 프로그램 의도와 상관없이 '매달린 포인터(Dangling Pointer)'가 발생
     + 그래서 자바는 자동 메모리 할당과 가비지 컬렉션(Garbage Collection)을 사용

4. MIPS 어셈블리 언어의 레지스터 사용 관례
<div align="center">
<img src="https://github.com/user-attachments/assets/c819999e-da79-4568-bc4a-0261824c27d1">
</div>

   - 인자 레지스터 4개와 리턴 값 레지스터 2개, 저장 레지스터 8개, 임시 레지스터 10개면 대부분의 프로시저를 충족시킬 수 있으므로, 거의 메모리에 갈 일이 없으므로 속도가 빨라짐

5. 인수가 4개 보다 많을 경우?
   - MIPS 관례는 나머지 인수를 프레임 포인터 바로 위 스택에 넣는 것
   - 프로시저는 처음 네 인수가 $a0 ~ $a3에 있고, 나머지는 프레임 포인터를 통해 접근할 수 있는 메모리에 있다고 생각
   - 프레임 포인터를 사용하여 스택 변수에 접근하면 변위값이 항상 같으므로 매우 편리
   - 그러나 프레임 포인터가 꼭 있어야 되는 것은 아니며, GNU MIPS C 컴파일러는 프레임 포인터를 사용하지만, MIPS가 만든 C 컴파일러는 프레임 포인터를 사용하지 않음 : 30번 레지스터를 아홉 번째 저장 레지스터($s8)로 사용

6. 재귀 프로시저 중 재귀 호출을 사용하지 않고, 반복 기법으로 구현할 수 있는 것도 존재
   - 반복 기법은 프로시저 호출과 관련된 오버헤드를 제거하여 성능을 상당히 향상시킬 수 있음
   - 예) 합을 누적시키는 프로시저
<div align="center">
<img src="https://github.com/user-attachments/assets/5e97055f-0516-4c98-a3e8-599478fa600b">
</div>

   - 프로시저 호출 sum(3, 0) : sum(2, 3), sum(1, 5), sum(0, 6)의 재귀적 호출이 일어나 결과 6이 네 번 반환될 것
   - 이 같은 재귀적 호출을 꼬리 호출(Tall Call)이라고 하는데, 꼬리 재귀(Tail Recursion)는 효율적으로 구현될 수 있음 ($a0 = n, $a1 = acc라 가정)
<div align="center">
<img src="https://github.com/user-attachments/assets/3e5c08e4-0ca2-4ad3-be22-ef10ffab14c0">
</div>
