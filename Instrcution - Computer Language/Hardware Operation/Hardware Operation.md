-----
### 하드웨어 연산
-----
1. 기본적으로 모든 컴퓨터는 산술 연산을 할 수 있어야 함
   - 예) MIPS 어셈블리 언어는 두 변수 b, c를 더해 그 합을 a에 넣으라고 컴퓨터에 지시
```
add a, b, c
```
   - 💡 MIPS 산술 명령어는 반드시 한 종류의 연산만 지시하며, 항상 변수 3개를 갖는 형식을 가짐
   - 예) 네 변수 b, c, d, e의 합을 a에 넣는 예를 생각 : 네 변수 합을 구하는 명령어
```
add a, b, c   #b와 c의 합을 a에 저장
add a, a, d   #b와 c, d의 합을 a에 저장
add a, a, e   #b, c, d, e의 합을 a에 저장
```
   - 네 변수의 합을 구하려면 명령어 3개가 필요
   - ```#``` : 주석(Comment)로, 컴퓨터는 이를 무시
     + 고급 프로그래밍 언어와 달리 한 줄에 명령어 하나만 쓸 수 있으며, 줄이 끝나면 주석도 끝남

   - 덧셈 같은 연산의 피연산자(Operand)는 더해질 숫자 2개와 합을 기억할 장소 하나, 모두 3개임
   - 모든 명령어가 피연산자를 반드시 3개씩 갖도록 제한하는 것은 하드웨어를 단순하게 하는 원칙과 부합
     + 피연산자의 개수가 가변적이면 하드웨어가 복잡해짐

2. MIPS 어셈블리 언어
<div align="center">
<img src="https://github.com/user-attachments/assets/734df488-1e95-41c5-80fc-8b0c34dfe40d">
</div>

3. 예) C 치환문 2개의 번역
   - C 프로그램은 a, b, c, d, e 5개의 변수 사용
```c
a = b + c;
d = a - e;
```
   - C 명령어에서 MIPS 어셈블리 언어 명령어로의 변환은 컴파일러에 의해 이루어짐
   - MIPS 명령어는 근원지 피연산자 2개를 연산하여 그 결과를 목적지 피연산자에 넣음
```
add a, b, c
sub d, a, e
```

4. 예) 복잡한 C 치환문의 번역
```c
f = (g + h) - (i + j);
```
   - MIPS 명령어는 한 번에 하나의 연산만 하므로 컴파일러는 이 문장을 여러 개 어셈블리 명령으로 나눠야 함
   - 첫 MIPS 명령어는 g와 h의 합을 구하고 결과를 어딘가에 저장해야 하는데, 컴파일러는 t0이라는 임시 변수 생성
```
add t0, g, h   # 임시 변수 t0에 g + h 값 저장
```
   - 다음 연산은 뺄셈 이지만, i와 j의 합을 먼저 구해야 함
```
add t1, i, j   # 임시 변수 t1에 i + j 값 저장
```
   - 마지막으로 뺄셈 명령어가 첫 번째 합에서 두 뻔재 합을 빼고 결과를 f 변수에 저장
```
sub f, t0, t1  # t0 - t1 = (g + h) - (i + j)의 값을 f에 저장
```

5. 자바는 이식성(Portability)를 높이기 위해 소프트웨어 인터프리터(Interpreter) 사용하도록 설계 : 이 인터프리터 명령어 집합을 Java 바이트코드(Bytecode)라 부르는데, MIPS 명령어와 다른 점이 많음
   - 자바 시스템은 C 프로그램과 비슷한 성능을 얻기 위해 자바 바이트 코드를 기계어로 컴파일
   - C 프로그램보다 컴파일이 훨씬 늦게 일어나므로 자바 컴파일러는 JIT(Just In Time) 컴파일러라고도 불림


