-----
### 부호있는 수와 부호없는 수
-----
1. 숫자는 어떤 수를 기수로 사용해서도 나타낼 수 있음 (예를 들어, 123(기수 10) = 173(기수 8) = 443(기수 5) = 11120(기수 3) = 11111011(기수 2) 등의 표현이 가능)
2. 컴퓨터 내에서 일련의 높고 낮은 전기의 신호의 형태로 숫자를 저장하므로 결국 기수 2인 수로 볼 수 있음 (기수가 10인 수를 십진수라고 하듯, 기수가 2인 수를 이진수라고 함)
   - 모든 정보는 이진 자릿수(Binary Digit), 즉 비트(Bit)로 구성되므로 비트가 계산의 기본 단위가 됨
   - 이 기본 단위는 높음 / 낮음, 온 / 오프, 참 / 거짓, 1 / 0 등 두 값 중 한 값을 갖게 됨
   - 어떤 기수의 숫자에서 i번쨰 자릿수 d의 값 : $d × Base^{i}$
     + 여기서 i는 0에서 시작해서 왼쪽으로 갈수록 증가
     + 이 방식으로 워드 내 비트에 번호를 물어볼 수 있음
     + 그 비트에 해당하는 기수의 멱수(Power)를 번호로 사용하는 것
   - 예) $1011_{2}$는 다음 값을 나타냄
<div align="center">
<img src="https://github.com/user-attachments/assets/8ae63392-d41d-4a4f-928e-51e049713729">
</div>

   - 워드 내 각 비트에 오른쪽에서 왼쪽으로 0, 1, 2, 3, ...과 같이 번호를 붙임
   - 그림은 MIPS 워드 내 비트에 번호를 붙이는 방식과 숫자 $1011_{2}$의 표현을 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/6d64b6d2-8a56-4277-9675-264d0c2f42f8">
</div>

   - 워드는 수평으로뿐만 아니라 수직으로도 그릴 수 있으므로, 가장 오른쪽 혹은 가장 왼쪽 비트라고 말하는 것보다 LSB, MSB 사용
     + LSB(Least Significant Bit) : MIPS 워드에서 가장 오른쪽의 비트 (비트 0)
     + MSB(Most Significant Bit) : MIPS 워드에서 가장 왼쪽의 비트 (비트 31)
     + MIPS 워드의 길이는 32비트이므로 $2^{32}$가지의 서로 다른 32비트 패턴 표현 가능 : 0 ~ $2^{32} - 1 (4,294,967,295)$까지 숫자 표시 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/ec83038d-d011-4740-9f18-9991362a8470">
</div>

3. 32비트 이진수는 비트값과 2의 멱수를 곱한 값으로 표현 가능 (여기서 xi는 x의 i번쨰 비트)
<div align="center">
<img src="https://github.com/user-attachments/assets/20582b08-0492-426e-b205-0d6a09249f1a">
</div>

4. 이진 비트 패턴은 단순히 수의 표기 방법
   - 실제 수는 무한히 많은 자릿수를 갖고 있으며, 그 중 오른쪽 몇 자리만 제외하고 대부분은 0이며, 보통 앞의 0들은 표시하지 않음
   - 이진 비트 패턴들 더하고 빼고 곱하고 나누는 하드웨어를 설계할 수 있음
     + 만약 이러한 연산 결과가 하드웨어에 구현된 오른쪽 비트들만으로는 표현이 불가능하면, 오버플로우(Overflow)가 발생했다고 말함
     + 오버플로우가 발생했을 때 어떻게 대처해야 할지는 프로그래밍 언어와 운영체제 프로그램 몫

   - 컴퓨터 프로그램은 양수와 음수를 모두 계산 : 따라서 양수와 음수를 구별하는 표현 방법이 필요
     + 가장 확실한 방법은 별도의 부호를 덧붙이는 것인데, 부호는 한 비트면 표현이 가능 : 부호와 크기(Sign and Magnitutde) 표현법
     + 단점
       *  어디에 부호 비트를 붙어야 하는지 명확하지 않음
       *  부호와 크기 표현법의 덧셈기는 부호를 결정하기 위해 한 단계가 더 필요 (최종 부호가 무엇이 될지 알 수 없음)
       *  부호 비트가 따로 붙으므로 양의 0과 음의 0을 가짐

     + 작은 수에서 큰 수를 뺄 때 부호없는 수의 경우, 0들로 시작되는 수에서 빌림을 수행하게 되어 그 결과는 1들로 시작하는 수가 되는 것
     + 최종적으로 하드웨어를 간략하게 하는 표현 방식 선택 : 그 결과 0들이 앞에 나오면 음수, 1들이 앞에 나오면 음수
     + 부호있는 이진수를 표현하는 이러한 방식은 2의 보수법(Two's Complement)이라고 함
<div align="center">
<img src="https://github.com/user-attachments/assets/92c47cc0-bc7f-4422-904e-bea1ef3d9e2a">
</div>

   - 전체 절반인 양수 0부터 2,147,483,647($2^{31} - 1$)까지의 앞의 부호 없는 정수와 같은 표현법을 사용
   - 그 다음 비트 패턴($1000...0000_{2}$)은 가장 큰 음수 -2,147,483,648($-2^{31}$)을 나타내고, 그 다음부터는 크기가 하나씩 줄어들어 -1($1111...1111_{2}$)까지 감소
   - 2의 보수에는 대응되는 양수(+2,147,483,647)가 없는 음수 -2,147,483,648가 존재
     + 이러한 비대칭 문제가 있지만, 부호와 크기 표현법은 프로그래머와 하드웨어 설계자 모두에게 문제를 일으키므로 오늘날 2의 보수로 부호있는 수로 컴퓨터는 표현
     + 2의 보수 표현에서 모든 음수는 MSB는 1이라는 장점이 존재 : 따라서, 하드웨어가 양수인지, 음수인지 알아보려면 MSB만 검사하면 됨(0은 양수로 취급)
     + 그러므로 MSB를 부호 비트(Signe Bit)라고 부르며, 비트값에 2의 멱수를 곱한 값으로 32비트의 양수와 음수 모두 표현 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/abe5fe74-e945-4372-ad74-737df9013726">
</div>

   - 부호 비트에는 $-2^{31}$을 곱하고, 나머지 비트들은 각각의 위치에 해당하는 양의 기수 값을 곱합

5. 예) 이진수를 십진수로 변환
```
1111 1111 1111 1111 1111 1111 1111 1100₂
```
<div align="center">
<img src="https://github.com/user-attachments/assets/e0edee03-7b1d-4a8e-850c-a913a5e1787e">
</div>

   - 부호 없는 수의 연산 결과가 오버플로우를 발생시킬 수 있는 것처럼 2의 보수 연산에서도 오버플로우가 발생
   - 무한히 많은 비트로 표현한다면, 왼쪽에 무수히 나타날 비트와 실제 이진 비트 패턴의 제일 왼쪽 비트가 서로 다르면(즉, 부호 비트가 다를 때) 오버플로우가 발생한 것
   - 즉, 숫자가 음수인데 MSB가 0이거나, 양수인데 MSB가 1인 경우

6. 부호 확장(Sign Extension)
   - 부호 없는 수와 부호 있는 수는 산술 연산 뿐만 아니라 적재 명령어와도 상관이 존재
   - 부호있는 적재의 경우 레지스터의 남는 곳을 채우기 위해 부호를 반복하여 복사, 즉, 부호 확장이라고 불리는 것을 하게 되는데, 레지스터 길이에 맞춰 그 값을 정확하게 표현하기 위함
   - 부호없는 적재의 경우에는 데이터의 왼쪽 부분을 그냥 0으로 채움
   - 32비트 레지스터에서 32비트 워드를 적재할 경우 부호있는 적재나 부호없는 적재는 동일
     + 그래서 MIPS에 워드 적재 명령어는 하나이지만, 바이트 적재 명령어는 2개가 존재
     + lb(Load Byte) 명령어는 바이트를 부호있는 수로 간주하고 남은 24비트를 부호 확장하여 채움
     + 반면, lbu (Load Byte Unsigned) 명령어는 8비트를 부호없는 정수로 간주해 왼쪽 24비트 0으로 채움
     + C프로그램에서 바이트 데이터가 부호있는 8비트 정수를 표현하기 위해 사용되는 경우는 거의 없고, 대부분 문자 표시에 사용되므로, 바이트 적재에 lb 명령어는 잘 사용하지 않고, 거의 lbu 명령어만 사용

7. 메모리 번지는 자연스럽게 0에서부터 시작해 가장 큰 주소까지 이어짐
   - 즉, 음수 주소는 없으며, 따라서 프로그램이 어떤 때는 양수도 될 수 있고, 음수도 될 수 있는 수를 다루기도 하며, 어떤떄는 양수값만 갖는 수를 다루기도 함
   - 예를 들어, C언어에서는 전자를 정수(Integer, 프로그램에서는 int / singed int)라고 부르며, 후자를 부호없는 정수(Unsigned Int, unsigned int)라고 부름

8. 2의 보수 연산에서 사용할 수 있는 두 가지 빠른 계산법 : 첫 번째는 2의 보수 이진수를 역부호화하는 빠른 방법
   - 모든 0을 1로, 1은 0으로 바꾸고, 거기에 1을 더함
   - 이 방식은 원래 수(x)와 모든 비트를 역전 시킨 수($\overline{x}$)의 합은 $111...111_{2}$, 즉 -1이라는데 기초하고 있음
   - $x + \overline{x} = -1$이므로, $x + \overline{x} + 1 = 0$ 또는 $\overline{x} + 1 = -x$ ($\overline{x}$는 x에서 각 비트를 역전, 즉 0은 1로, 1은 0으로 역전한 것을 의미)

   - 빠른 역부호화 방법 : 2를 역부호화하고, -2를 다시 역부호화해 결과 확인
<div align="center">
<img src="https://github.com/user-attachments/assets/522de495-e929-40a4-b0b6-b83f865a59fe">
</div>

   - 0은 1로, 1은 0으로 바꾸고 1을 더하여 부호를 바꿈
<div align="center">
<img src="https://github.com/user-attachments/assets/e631cb52-0e04-4f6c-bf5d-2abfab049715">
</div>

   - 반대의 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/3f61ef04-32a9-4c80-9ff8-a3830dece2c8">
</div>

   - 먼저 0은 1로, 1은 0으로 바꾸고 1을 더함
<div align="center">
<img src="https://github.com/user-attachments/assets/5b233a87-5358-478f-a0c5-86e9f65ba5fa">
</div>

9. 2의 보수 연산에서 사용할 수 있는 두 가지 빠른 계산법 : 두 번째는 n비트로 표현된 이진수를 n비트보다 큰 수로 바꾸는 방법
    - 예를 들어, load / store / branch / add 그리고 set on less than 명령어의 수치값 필드에는 2의 보수 16비트 이진수가 들어가므로, -32,768($-2^{15})에서 32,767($2^{15} - 1)까지 값을 표현할 수 있음
    - 이 값을 32비트 레지스터와 더하려면 컴퓨터는 16비트 수를 같은 값의 32비트로 변환해야 함
    - 변환하는 가장 빠른 방법은 16비트 이진수의 최상위 비트(부호 비트)로 비어 있는 왼쪽 부분을 채우고, 원래 16비트 값은 32비트 수의 오른쪽 부분에 그대로 복사 : 이러한 방법을 부호 확장이라고 부름
    - 빠른 부호 확장 예시 : 16비트 이진수 2와 -2를 32비트 이진수로 변환
      + 2의 16비트 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/d615e989-cf3b-40c1-8d9e-3a59c7f0e142">
</div>

   - 최상위 비트(0)을 취해서 워드의 왼쪽 부분에 16번 복사하고, 워드의 오른쪽 부분에는 원래의 값을 그대로 복사해서 32비트 이진수로 만듬
<div align="center">
<img src="https://github.com/user-attachments/assets/213f0c43-4c29-41ec-9def-45d3e8742198">
</div>

   - 16비트 이진수 2를 앞의 빠른 계산 방법으로 역부호화하여 -2 만들기
<div align="center">
<img src="https://github.com/user-attachments/assets/1bfa6740-c69c-49eb-802f-182bc170f457">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/942d08f6-2ed9-4907-b5cb-889c389aaa94">
</div>

   - 음수를 32비트로 변환하려면 부호 비트를 16번 복사하여 왼쪽에 넣음
<div align="center">
<img src="https://github.com/user-attachments/assets/f81c745b-8922-4298-8848-08c86cb9cc41">
</div>

9. 2의 보수법으로 표현된 양수가 실제로는 왼쪽에 끝없이 많은 0을 가지고 있고, 음수는 끝없이 많은 1을 가지고 있으므로 가능
    - 수를 나타내는 이진 비트 패턴은 하드웨어 폭을 맞추기 위해 왼쪽 비트들을 숨기고 있는데, 부호 확장은 이들 중 일부를 복원하는 것이라고 생각할 수 있음

10. 요약
    - 컴퓨터 워드에 양수와 음수를 모두 나타낼 필요가 있음
    - 2의 보수 표현법이 주로 사용

11. 십진수는 크기에 대한 제한 사항이 없으므로 음수를 표현하기 위해 -를 사용하지만, 이진수와 16진수의 비트열은 고정된 크기 내 부호를 표시할 수 잇으므로, + 나 -를 사용하지 않음
12. 2의 보수법이란 이름은 n비트의 수와 그 음수의 합을 부호없는 수로 나타내는 $2^{n}$이 된다는 법칙에 비롯
    - 즉, 2의 보수법 숫자 x의 보수, 즉 음수는 $2^{n} - x$

13. 1의 보수법(One's Complement) : 절대값이 가장 큰 음수를 $10..00_{2}$로 나타내고, 가장 큰 양수를 $01..11_{2}$로 나타내며, 같은 개수의 양수와 음수를 나타내는 표현 방법
14. - 양의 0과 음의 0, 2개의 0이 존재
    - 이 용어는 비트 패턴의 모든 0은 1로, 1은 0으로 바꾸는 작업을 지칭하는데 사용
    - 1의 보수법에서는 모든 비트의 0과 1을 맞바꾸어($\overline{x}$) 음수를 만들 수 있는데, x의 보수 $\overline{x}$의 값은 ${2^{n} - x - 1$에 해당
    - 이 방식 또한 부호와 크기 표현 방법보다 더 좋은 방법을 찾기 위한 노력의 결과
    - 0이 두 가지로 표현되는 것을 제외하면 2의 보수법과 비슷 : $00..00_{2}$은 +0이고, $11..11_{2}$은 -0
      + 가장 작은 음수 $10..00_{2}$는 -2,147,483,647를 나타내며, 따라서 양수와 음수의 개수는 같음
      + 1의 보수 덧셈기는 맨 끝의 올림수를 처리하기 위해 한 단계를 더 필요로 함
      + 따라서, 오늘날 2의 보수법이 가장 많이 사용

15. 바이어스된 표현법(Biased Notation) : 절대값이 가장 큰 음수를 $00..00_{2}$로 나타내고, 가장 큰 양수를 $11..11_{2}$로 나타내며, 0은 $10..00_{2}$로 나타내는 표현 방법으로, 원 숫자에 일정한 바이어스 값을 더해 항상 0보다 크거나 같은 값이 되도록 함
    - 부동 소수점을 다룰 때 사용되며, 숫자에 일정한 값(Bias)를 더하여 항상 양수로 표현
