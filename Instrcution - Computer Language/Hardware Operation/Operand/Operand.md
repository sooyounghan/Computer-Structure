------
### 피연산자
------
1. 상위 수준 언어 프로그램과 달리 산술 명령어의 피연산자에는 제약이 존재
   - 레지스터(Register)라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만 사용 가능
   - 레지스터는 하드웨어 설계의 기본 요소인 동시에 컴퓨터를 구성하고 있음
   - MIPS 구조에서 레지스터 크기는 32비트로, MIPS에서는 32비트가 한 덩어리로 처리되는 일이 매우 빈번하므로 워드(Word)라고 불림
     + 워드 : 컴퓨터에서 자연스러운 접근 단위 (보통 32비트이며, MIPS 구조에서 레지스터 크기에 해당)

2. 프로그래밍 언어에서 사용하는 변수와 레지스터의 큰 차이점은 레지스터는 개수가 한정적
   - 현대 컴퓨터에는 MIPS처럼 보통 32개의 레지스터가 존재
   - 그러므로 기호 형태로 표현된 MIPS 언어를 단계적으로 구체화할 때, 산술 명령어의 각 피여난자는 32개의 32비트 레지스터 중 하나이어야 한다는 제약이 추가
   - 레지스터 개수를 32개로 제한하는 이유는, 레지스터가 아주 많아지면 전기 신호가 더 멀리 전달되어야하므로 클럭 사이클이 길어짐
   - 하지만 레지스터를 31개 한다고 해서 32개보다 빨리지지 않음
  
3. 명령어를 작성할 때 단순하게 레지스터 번호 0부터 31까지 사용할 수 있지만, 레지스터를 표현하는 MIPS의 관례는 $ 기호 뒤 두 글자가 따라 나오는 이름을 사용하는 것
   - C나 자바의 변수에 해당하는 레지스터들은 $s0, $s1 등으로  표기
   - 컴파일 과정에서 필요한 임시 레지스터는 $t0, $t1 등으로 표기

4. 레지스터를 상요하여 C 치환문 번역
   - 프로그램 변수를 레지스터와 연관시키는 것은 컴파일러의 임무
```
f = (g + h) - (i + j);
```
   - 컴파일러가 f, g, h, i, j를 레지스터 $s0, $s1, $s2, $s3, $s4에 각각 할당
```
add $t0, $s1, $s2    # 레지스터 t0에 g + h 값 저장
add $t1, $s3, $s4    # 레지스터 t1에 i + j 값 저장
sub $s0, $t0, $t1    # $t0 - $t1의 값을 f에 저장 (g + h) - (i - j)
```
