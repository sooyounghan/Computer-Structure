-----
### 메모리 피연산자
-----
1. 프로그래밍 언어에는 값 하나만 기억하는 단순 변수 외에도 배열(Array)이나 구조체(Structure) 같은 복잡한 자료구조가 존재하며, 복잡한 자료구조 하나에는 레지스터 개수보다 훨씬 많은 데이터 원소가 존재할 수 있음
2. 프로세서는 소량의 데이터만 레지스터에 저장할 수 있지만, 컴퓨터 메모리는 수십억 개의 데이터를 저장할 수 있으므로, 배열이나 구조체 같은 자료구조는 메모리에 보관
3. MIPS의 산술 연산은 레지스터에서만 실행되므로 메모리와 레지스터 간에 주고받는 명령어가 있어야 함
   - 이런 명령어를 데이터 전송 명령어(Data Transfer Instruction) : 메모리와 레지스터 사이에서 데이터를 이동하는 명령어
   - 메모리에 기억된 데이터 워드에 접근하려면 명령어가 메모리 주소(Memory Address)를 지정해야 함
     + 메모리 주소 : 메모리 배열 내 특정 데이터 요소를 표시하는 데 사용하는 값
     + 메모리는 주소가 인덱스 역할을 하는 큰 1차원 배열로, 주소는 0부터 시작
<div align="center">
<img src="https://github.com/user-attachments/assets/8c0432b6-4504-4b53-8f7c-9c6082634aa1">
</div>

   - 세 번째 데이터 원소의 주소는 2이고, Memory[2]의 값은 1

4. 메모리에서 레지스터로 데이터를 복사해오는 데이터 전송 명령을 적재(Load)라고 함
   - 적재 명령은 연산자 이름과 메모리에서 읽어온 값을 저장할 레지스터, 메모리 접근에 사용할 상수와 레지스터로 구성
   - 메모리 주소는 명령어의 상수 부분과 두 번째 레지스터 값의 합으로 구해짐
   - MIPS에서 이 명령의 실제 이름은 lw(Load Word)

5. 메모리 피연산자를 사용하는 치환문
   - A는 100워드 배열이고, 변수 g, h는 레지스터 $s1, $s2에 할당되었다고 가정
   - 또, 배열 A의 시작 주소(Base Address)가 $s3에 기억되고 있다고 가정
```c
g = h + A[8];
```
   - 피연산자 중 하나가 변수에 있으므로, 먼저 A[8]을 레지스터로 옮긴 후 연산을 시작
   - 이 배열 원소의 주소는 $3에 있는 배열의 시작 주소에 인덱스 8을 더한 값
   - 따라서, 이 데이터는 다음 명령어가 사용할 수 있도록 임시 레지스터에 넣어야 함
```
lw $t0, 8($s3)    #A[8]의 값을 임시 레지스터 $t0에 적재
```
   - A[8]의 값을 레지스터 $t0에 넣었으므로 덧셈 수행 가능
   - 덧셈 명령어는 h($s2)를 A[8]($t0 값)에 더해서 g에 해당하는 레지스터($t1)에 넣음
```
add $s1, $s2, $t0    # g = h + A[8]
```
   - 데이터 전송 명령어의 상수 부분(8) : 변위(Offest)
   - 주소 계산을 위해 더해지는 레지스터 ($s3) : 베이스 레지스터(Base Register)

6. 변수를 레지스터와 연관 짓는 일뿐 아니라 배열이나 구조체 같은 자료구조를 메모리에 할당하는 것도 컴파일러의 임무
   - 컴파일러는 자료구조의 시작 주소를 데이터 전송 명령에 넣을 수 있음
   - 프로그램에서 8비트로 구성된 바이트를 많이 사용하므로 대부분 커퓨터는 바이트 단위로 주소를 지정
   - 워드 주소는 워드를 구성하는 4바이트 중 하나를 사용하므로, 연속된 워드의 주소는 4씩 차이가 발생
   - 실제 MIPS의 주소
<div align="center">
<img src="https://github.com/user-attachments/assets/97c10e45-fb60-4a09-b471-924611464339">
</div>

   - 예) 세 번째 워드의 바이트 주소 8
   - MIPS에서 워드의 시작 주소는 항상 4의 배수이어야 함 : 이러한 요구 사항을 정랼 제약(Alignment Restriction, 메모리 내에서 데이터는 자연스러운 경계를 지켜서 정렬되어야 한다는 요구 조건)이라고 하며, 많은 컴퓨터에서 이러한 방법 사용
   - 컴퓨터는 제일 왼쪽, 즉, 최상위(Big End) 바이트 주소를 워드 주소로 사용하는 것과 제일 오른쪽, 즉 최하위(Little End) 바이트 주소를 워드 주소로 사용하는 것 두 종류로 나눠짐
     + MIPS는 최상위 주소를 사용하는 빅 엔디안(Big Endian) 계열에 속함
   - 바이트 주소의 사용은 배열의 인덱스에도 영향을 미침 : 위 코드에서 바이트 주소를 제대로 구하려면 베이스 레지스터 $s3에 변위 4 X 8 = 32를 더해야 함
     + A[8] 주소를 구하는 것
   
7. 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령을 저장(Store)이라고 함
   - 저장 명령의 생김새는 적재와 동일하며, 즉, 연산자 이름, 저장할 데이터를 갖고 있는 레지스터, 배열 원소에 선택할 변위, 베이스 레지스터로 구성
   - 주소의 일부는 상수 형태로 명령어에 포함되고 있어, 일부는 레지스터에 기억
   - MIPS에서 이 명령어의 이름은 sw(Store Word)

8. 적재 / 저장 명령어에서 주소가 이진수이므로 DRAM 메모리 주소는 십진수 단위가 아닌 이진수 단위로 표시 (예) GB($10^{9}$), TB($10^{12}$)가 아닌 GiB($2^{30}$) 또는 TiB($2^{40}$)로 표시)

9. 적재와 저장을 사용한 번역
   - 변수 h가 레지스터 $s2에 할당되어있으며, 배열 A의 시작 주소는 $s3에 들어있다고 가정
```
A[12] = h + A[8];
```
   - 연산자는 하나, 피연산자는 2개이므로, MIPS 명령어가 더 필요
   - 적재 명령어의 변위가 바이트 주소에 맞는 적절한 값(32)으로 바뀐 것과 add 명령어가 합을 $t0에 넣는 것을 제외하면 동일
```
lw $t0, 32($s3)      #A[8]의 값을 임시 레지스터 t0에 적재
add $t0, %s2, $t0    #h + A[8]의 값을 임시 레지스터 $t0과 더함
```
   - 마지막 명령어는 48(4 X 12)을 변위로, $s3을 베이스 레지스터로 사용하여 합을 A[12]에 저장
```
sw $t0, 48($s3)      #h + A[8]의 값을 A[12]에 저장
```
   - MIPS에서 메모리와 레지스터 사이 워드 복사 명령어는 lw, sw 2개뿐임
   - 다른 컴퓨터에서는 적재와 저장 명령어 외 다른 명령어들을 데이터 전송에 사용하기도 함

10. 컴퓨터가 갖고 있는 레지스터보다 프로그램에 사용하는 변수가 더 많은 경우가 자주 있음
    - 컴파일러는 자주 사용되는 변를 가능한 한 많이 레지스터에 넣고, 나머지 변수는 메모리에 저장했다가 필요할 때 꺼내서 레지스터에 넣음
    - 자주 사용하지 않는(또는 한참 후에 사용할) 변수를 메모리에 넣는 일을 레지스터 스필링(Spilling Register)
    - 메모리는 레지스터보다 속도가 느리며, 데이터가 레지스터에 있으면 더 빨리 접근 가능
    - 레지스터에 저장된 데이터는 메모리 데이터봐 사용하기도 편리
      + MIPS의 산술 연산 명령은 레지스터 2개를 읽어서 연산 후, 결과를 레지스터에 씀
      + 하지만, 데이터 전송 명령은 피연산자를 하나만 읽거나 쓰는 일만 할 뿐 데이터에 대한 연산은 못함
    - 레지스터는 메모리보다 접근시간이 짧고 처리량도 많으므로, 레지스터에 저장된 데이터를 사용하면 시간 절약 및 사용이 간편
      + 그 뿐만 아니라 레지스터 접근은 메모리 접근보다 에너지가 적게됨
      + 그러므로 성능을 얻고, 에너지 절약을 위해서 컴파일러가 레지스터를 효율적으로 써야함
