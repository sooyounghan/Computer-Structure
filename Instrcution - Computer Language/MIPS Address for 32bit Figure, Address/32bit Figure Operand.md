-----
### 32비트 수치 피연산자
-----
1. 프로그램에서 사용하는 상수는 대체로 크기가 작음
   - 그러므로 대부분 16비트 필드면 충분하지만, 때에 따라서는 더 큰 상수가 필요한 경우도 존재
   - 이럴 때 MIPS는 레지스터의 상위 16비트에 상수를 넣는 lui(load upper immediate) 명령어를 제공
   - 하위 16비트는 그 다음에 나오는 다른 명령으로 채울 수 있음
   - lui의 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/6b1cfe10-d987-40de-963e-4362d326640d">
</div>

2. 32비트 상수의 로딩
   - 레지스터 $s0에 다음 32비트 상수를 채우는 MIPS 어셈블리 코드
```
0000 0000 0011 1101 0000 1001 0000 0000
```
  - 먼저 lui를 이용해 상위 16비트를 채움 : 상위 16비트의 값은 십진수로 61
```
lui $s0, 61   # 61 = 0000 0000 0011 1101
```
   - 이 명령을 실행한 후 레지스터의 $s0의 값
```
0000 0000 0011 1101 0000 0000 0000 0000
```
   - 다음 하위 16비트를 채우면 됨 : 하위 16비트의 값은 십진수로 2304
```
ori $s0, $s0, 2304    # 2304 = 0000 1101 0000 0000
```
   - 레지스터 $s0의 값
```
0000 0000 0011 1101 0000 1001 0000 0000
```

3. 컴파일러나 어셈블러는 큰 숫자를 직접 다룰 수 없으므로 몇 조각으로 나눈 후 레지스터에서 재조립해야 함
   - 수치 명령어의 상수는 물론 적재나 저장 명령어의 메모리 주소도 상수 필드 크기의 제약이 문제가 됨
   - MIPS 소프트웨어처럼 이 문제를 어셈블러가 해결하도록 하려면 큰 값을 만드는 데 사용할 임시 레지스터를 제공해야 함
   - 어셈블러를 위해 예약된 레지스터 $at가 이런 용도로 사용
   - 그러므로 MIPS 기계어의 기호 표현은 하드웨어에 의해 제한된다기 보다 어셈블러를 만든 사람이 어떤 것을 포함시키기로 했느냐에 따라 달려 있음

4. 32비트 상수를 만들 때 주의점
   - addi 명령어는 16비트 상수 필드의 MSB를 상위 16비트에 복사해 32비트 상수를 만들어(즉, 부호확장) 연산에 사용
   - ori 명령은 상위 16비트를 0으로 채운 뒤 0으로 연산하므로, ori 명령어를 lui와 함께 사용해 32비트 상수를 만듬
