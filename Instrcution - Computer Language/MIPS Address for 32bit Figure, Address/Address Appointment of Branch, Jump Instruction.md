-----
### 분기와 점프 명령에서의 주소 지정
-----
1. MIPS에서 가장 간단한 주소 지정 방식은 점프 명령에서 사용하는 것
   - 점프 명령은 6비트의 op코드와 26비트의 주소 필드로 구성된 J 타입 명령어를 사용
```
j 10000    # 10000 주소로 이동
```
<div align="center">
<img src="https://github.com/user-attachments/assets/1a57a01e-7658-4a8d-b2b5-d8d595d64d8a">
</div>

   - 여기서 점프(jump)의 op 코드는 2이고, 분기 주소는 10000

2. 점프와 달리 조건부 분기 명령에는 분기 주소 외 2개의 피연산자가 있음
```
bne  $s0, $s1, Exit    # $s0 ≠ s1라면, Exit로 이동
```
   - 다음과 같이 어셈블되어 분기 주소로 16비트만 쓸 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/8baf37b2-6e29-4d73-97f1-9d4a04dc043b">
</div>

   - 만일 프로그램에서 사용하는 모든 주소가 이 16비트 필드에 들어가야 한다면, 어떤 프로그램도 $2^{16}$보다 더 커질 수 없음
   - 하지만, 이는 현실적으로 너무 작은 크기이므로, 어떤 레지스터를 지정해 그 값을 분기 주소와 더하도록 하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/b3132020-37f9-44e9-b40f-8ab592baef5d">
</div>

   - 이 방식은 프로그램 크기가 $2^{32}$까지 커지는 것을 허용하면서 조건부 분기도 지원함으로써, 분기 주소의 크기 제한을 극복

3. 조건부 분기는 주로 순환문이나 if문에서 사용되므로 가까이 있는 명령어 분기하는 경향이 있음
   - 예를 들면, SPEC 벤치마크에서 사용된 조건부 분기의 절반가량이 16개 명령어 이상 떨어지지 않은 위치로 분기
   - PC(Program Counter)는 현 명령어 주소를 갖고 있으므로, 분기 주소를 더할 레지스터에 PC를 선택하면 현 위치에서 $±2^{15}$워드 내 떨어진 곳은 어디든지 분기할 수 있음
   - 거의 모든 순환문과 if문의 분기 범위가 $2^{16}$워드 이내이므로 PC는 이상적 선택
   - 이런 분기 주소지정 방식을 PC 상대 주소지정(PC-Relative Addressing) 방식이라 함
     + PC 상대 주소지정 : PC와 명령어 내 상수의 합이 실제 주소가 되는 주소시정
     + 하드웨어 입장에서는 PC를 일찍 증가시켜 다음 명령어를 가리키게 하는 것이 편리
     + 그러므로 실제 MIPS 주소는 현재 명령어 주소(PC)를 기준으로 하는 것이 아니라, 다음 명령어 주소(PC + 4)를 기준으로 하게 됨
     + 최근 모든 컴퓨터와 MIPS는 모든 조건부 분기 명령에 PC 상대 주소를 사용 : 조건부 분기의 목적지는 대체로 가까운 곳에 있음
     + 반면 프로시저들은 가까이 붙어있어야 할 이유가 없으므로 jal 명령은 다른 주소 지정 방식 사용 : MIPS 구조는 j 명령어나 jal 명령어가 긴 주소를 사용할 수 있도록 J 타입 형식 사용

4. MIPS 명령어의 길이는 항상 4바이트이므로, 분기할 거리를 바이트 단위가 아니라 워드 단위로 나타내면 더 먼 거리까지 분기 가능
   - 바이트 주소 대신 워드 주소를 사용함으로써, PC 상대 주소지정 방식의 분기 거리를 4배로 늘릴 수 있음
   - 마찬가지로 점프 명령어의 26비트 필드도 워드 주소이며, 바이트 주소로는 28비트에 해당

5. PC는 32비트이므로, 28비트 점프 주소를 사용하더라도, 나머지 4비트를 채우는 방법이 있어야 함
   - MIPS의 점프 명령은 PC의 상위 4비트는 바꾸지 않고, 하위 28비트만 바꾸는 방법 사용
   - 단, 로더와 링커는 한 프로그램이 256 MB(명령어 6,400만개) 경계를 넘어가지 않도록 조심해야 함
   - 부득이, 경계를 넘어가야 하는 경우 레지스터에 32비트 주소를 넣은 후 jr 명령을 사용해야 함

6. 예) 기계어에서의 분기 변위
   - while 순환문의 MIPS 어셈블리 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/96d5b9bb-eb53-499e-8a15-bcfabf2bdec1">
</div>

   - Loop 주소가 80000번지라고 할 때, 프로그램에 해당하는 MIPS 기계어 코드
   - 어셈블 된 명령어와 그 주소
<div align="center">
<img src="https://github.com/user-attachments/assets/91c194d7-07e9-4e66-bcf6-4e92407b7cc7">
</div>

   - MIPS 명령어는 바이트 주소를 사용하므로 이웃한 워드의 주소는 4씩 차이남
   - 네 번쨰 줄의 bne 명령은 다음 명령어의 주소인 (80016)에 8을 더해서 목적지 주소를 구함
   - 현재 명령어 기준의 상대적 위치(12 + 80012)나 목적지 주소 전체(80024)가 아니라 다음 명령어를 기준으로 한 상대적 위치(80016 + 8)로 분기 주소를 나타냄
   - 마지막 줄의 점프 명령어는 Loop에 해당하는 주소 전체(20000 X 4 = 80000)를 사용

7. 거의 모든 조건부 분기 목적지는 가까운 곳이지만, 가끔 16비트로 나타낼 수 없는 먼 곳으로 분기하는 경우도 존재
   - 이런 경우 어셈블러는 큰 주소나 상수를 처리할 때와 같은 방법으로 해결
   - 분기 목적지로 가는 무조건 점프를 삽입한 후, 분기 조건을 반대로 만들어 이 점프를 건너뛸 것인지, 말 것인지 결정

8. 아주 먼 거리로의 분기
   - 레지스터 $s0가 레지스터 $s1와 같으면 분기하는 코드
```
beq $s0, $s1 ,L1
```
   - L1이 아주 멀어도 분기가 가능하도록 바뀌도 명령어 2개 사용
```
bne $s0, $s1, L2
j   L1
L2:
```
