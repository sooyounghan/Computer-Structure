-----
### 동적 링크 라이브러리
-----
1. 프로그램 실행 전 라이브러리를 링크하는 전통적 방법은 라이브러리 루틴을 호출하는 가장 빠른 방법이지만, 몇 가지 단점 존재
   - 라이브러리 루틴이 실행 코드의 일부가 됨 : 버그가 제거되었거나 새로운 하드웨어 장치를 지원하는 신판 라이브러리가 나오더라도 정적으로 링크된 프로그램은 옛날 라이브러리를 사용해야 함
   - 실행 파일에서 한 번이라도 호출되는 라이브러리는 모든 루틴을 다 적재해야 함 : 심지어 이 호출이 실제 실행되지 않더라도 모두 적재해야 하며, 라이브러리가 프로그램에 비해 클 수 있음

2. 이러한 단점 때문에, 동적 링크 라이브러리(Dynamic Linked Library, DLL)가 등장
   - 동적 링크 라이브러리(DLL) : 실행 시 프로그램과 링크되는 라이브러리 루틴
   - 이 방식은 프로그램 실행 전에는 라이브러리가 링크되지도 않고, 적재되지도 않지만, 대신 프로그램과 라이브러리 루틴은 전역 프로시저 위치와 이름에 대한 정보를 추가로 가지고 있음
   - 초기의 DLL에서는 로더가 동적 링커를 실행시킴 : 동적 링커는 파일에 저장된 추가 정보를 이용해 적절한 라이브러리를 찾고 모든 외부 참조를 갱신

3. 이 초기 DLL의 단점은 호출될 가능성이 있는 모든 라이브러리 루틴을 링크시킨다는 것
   - 실제로 호출되는 것만 링크시키면 더 좋으므로, 이런 관점에서 지연(Lazy) 프로시저 링키지형의 DLL 개발
   - 여기서는 모든 루틴을 실제로 호출된 후에 링크시킴
   - 여기서 사용되는 트릭은 간접접근(Indirection) 기법
<div align="center">
<img src="https://github.com/user-attachments/assets/a66957ba-3513-43fa-b6e2-1023b26da678">
</div>

   - 이 과정은 프로그램 끝에 있는 더미 루틴(Dummy Routine)들을 호출하는 전역 루틴에서부터 시작
   - 전역 루틴 하나당 더미 엔트리가 하나씩 있는데, 이 더미 엔트리에는 간접 점프가 하나씩 있음

4. 라이브러리 루틴을 처음 호출할 때는 프로그램이 더미 엔트리를 호출하고 간접 점프를 따라감
   - 더미 엔트리는 원하는 라이브러리 루틴을 표시하기 위해 레지스터에 숫자를 넣고 동적 링커 / 로더로 점프하는 코드를 가리킴
   - 링커 / 로더는 원하는 루틴을 찾아서 재사상하고, 이 루틴을 가리키도록 간접 점프 위치에 있는 주소를 바꿈
   - 그러고 나서, 그 주소로 점프하고, 루틴의 실행이 끝나면 원래 호출한 위치로 돌아옴
   - 그 이후에 다시 라이브러리를 호출하면 추가로 돌아다니는 일 없이 해당 루틴으로 바로 간접점프
   - 요약하면, DLL은 동적 링킹에 필요한 정보를 위한 추가 공간을 필요로 하지만, 전체 라이브러리를 복사하거나 링크할 필요는 없음
   - 어떤 루틴을 처음 호출할 때는 오버헤드가 매우 크지만, 그다음부터는 간접 점프 하나만 하면 됨
   - Microsoft Windows는 동적 링크 라이브러리에 크게 의존하고 있으며, 오늘날 UNIX 시스템에서 프로그램을 실행할 때도 DLL이 디폴트
