-----
### 링커
-----
1. 각 프로시저를 따로 컴파일, 어셈블하는 것 : 즉, 어떤 프로시저가 바뀌면, 바뀐 프로시저만 다시 번역
   - 이렇게 하려면 링크 에디터(Link Editor) 또는 링커(Linker)라고 부르는 시스템 프로그램이 추가로 필요
     + 링커 : 링크 에디터라고도 하며, 따로 어셈블된 기계어 프로그램을 결합하고 정의가 안 된 레이블의 주소를 찾아내서 실행 파일을 만드는 시스템 프로그램
   - 이 프로그램은 다로 어셈블된 기계어 프로그램을 하나로 연결해주는 일을 함
   - 링커의 동작
     + 코드와 데이터 모듈을 메모리에 심벌 형태로 올려 놓음
     + 데이터와 명령어 레이블 주소를 결정
     + 외부 및 내부 참조를 해결

2. 링커는 각 목적 모듈의 재배치 정보와 심벌 테이블을 이용해서 미정의 레이블의 주소를 결정
   - 분기 명령어, 점프 명령어, 데이터 주소 등에 나타나는 구주소를 신주소를 바꾸는 일을 하므로 에디터와 유사한 점이 존재
   - 이런 이유로, 이 프로그램을 링크 에디터라고 부르며, 줄여서 링커라고도 함
   - 프로그램 전체를 다시 컴파일하고, 어셈블하는 대신 링커를 써서 번역된 모듈을 연결하면 시간이 절약

3. 링커와 외부 참조를 모두 해결하고 나면, 각 모듈의 메모리 주소를 결정
   - 각 파일을 독립적으로 어셈블하기 때문에, 어셈블러는 어떤 모듈의 명령어와 데이터가 다른 모듈과 상대적으로 어떤 위치에 있게 될는지 알 수 없음
   - 링커가 모듈을 메모리에 적재할 때, 절대 참조(레지스터에 더해지는 것이 아닌 실제 메모리 주소)는 모두 실제 위치에 해당하는 값으로 재설정되어야 함

4. 링커는 컴퓨터에서 실행될 수 있는 실행 파일(Executable File)을 생성
   - 실행 파일 : 목적 파일 형식의 기능 프로그램으로, 미해결 참조를 갖고 있지 않으며, 심벌 테이블과 디버깅 정보를 가지고 있을 수 있음
     + 디버깅 정보가 없는 파일은 "stripped exectuable"이라 하며, 실행 파일은 로더를 위해 재배치 정보를 가지고 있을 수 있음
   - 이 파일은 대개 목적 파일과 같은 형식을 갖는데, 다만 미해결된 참조는 없음
   - 라이브러리 루틴같이 일부만 링크된 파일이 있을 수 있음 : 이런 파일은 아직도 미해결 주소를 갖고 있으므로 목적 파일에 속함

5. 예) 목적 파일의 링크
<div align="center">
<img src="https://github.com/user-attachments/assets/e2a292f6-53d9-48d1-9c41-fb6c3f672b23">
</div>

   - 프로시저 A는 변수 레이블 X와 프로시저 B의 주소를 찾아서 lw와 jal 명령을 처리
   - 프로시저 B는 변수 레이블 Y와 프로시저 A의 주소를 찾아내어 sw와 jal 명령을 처리
   - 텍스트 세그먼트는 $40 0000_{16}$번지에서 시작되고, 데이터 세그먼트는 $1000 0000_{16}$번지에서 시작
   - 따라서, $40 0000_{16}$번지에 프로시저 A의 텍스트가 들어가고, $1000 0000_{16}$번지에 그 데이터가 들어감
   - 프로시저 A의 목적 파일 헤더에 의하면 텍스트는 $100_{16}$바이트이고, 데이터는 $20_{16}$ 바이트이므로, 프로시저 B의 텍스트 시작 주소는 $40 0100_{16}$이고, 데이터 시작 주소는 $1000 0020_{16}$
<div align="center">
<img src="https://github.com/user-attachments/assets/052aacdb-d29e-4714-b7e4-6c8a6a3c7ba3">
</div>

   - 링커가 명령어의 주소 필드를 고침 : 명령어의 op 필드를 보고 수정할 명령어의 주소 형식을 판별
     + 첫째는 jal 명령어 : 이 명령은 의사직접 주소지정 방식을 사용하므로, $40 0004_{16}$번지에 있는 jal 명령 주소 필드는 $40 0100_{16}$번지(프로시저 B의 주소), $40 0104_{16}$ 번지의 jal 명령 주소 필드는 $40 0000_{16}$(프로시저 A의 주소)가 됨
     + 두번째는 lw와 sw인데, 이들은 레지스터를 사용
       * $sp는 $1000 8000_{16}$으로 초기화
       * $40 0000_{16}$번지의 lw 명령은 워드 X의 주소 $1000 0000_{16}$번지를 사용하므로, 주소 필드에 $8000_{16}$을 넣어야 함
       * lw의 주소 필드는 부호 확장 되므로, $8000_{16}$는 FFFF $8000_{16}(=-32768)$이 됨
       * 같은 방법으로 $40 0100_{16}$번지의 sw 명령의 주소 필드에는 $8020_{16}$를 넣어 변수 Y의 주소 $1000 0020_{16}$를 만듬

6. MIPS 명령어는 워드 단위로 정렬되므로 jal 명령어는 명령어 주소 영역을 넓히기 위해 오른쪽 두 비트를 사용하지 않음
   - 즉, 28비트의 바이트 주소를 생성하기 위해 26비트를 사용
   - 따라서, 위 예제에서는 명령어의 하위 26비트에 있는 실제 주소는 $40 0100_{16}$가 아닌 $10 0040_{16}$ ($40 0004_{16}$번지의 jal), $40 0000_{16}$가 아닌 $10 0000_{16}$($40 0104_{16}$번지의 jal)
   
