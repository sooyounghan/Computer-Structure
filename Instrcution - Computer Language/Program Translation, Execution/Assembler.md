-----
### 어셈블러
-----
1. 어셈블리 언어는 상위 수준 소프트웨어와의 인터페이스이므로 원래는 없는 명령어를 어셈블러가 독자적으로 제공할 수 있음
   - 이 명령어들은 하드웨어로 구현되어 있지 않더라도 어셈블러가 처리하여 번역과 프로그래밍을 간단하게 해주는데, 이런 명령어들을 의사명령어(Pseudoinstruction)
   - 즉, 하드웨어가 지원하지 않지만, 어셈블러가 처리해서 마치 실제 명령어처럼 사용되는 어셈블리 언어의 변형

2. MIPS 하드웨어는 레지스터 $zero의 값이 항상 0이 되도록 함
   - 즉, $zero를 사용하면 그 값은 항상 0이며, $zero의 값은 바꿀 수 없음
   - 그러므로, $zero는 한 레지스터의 내용을 다른 레지스터로 복사하는 move 명령어를 구현하는 데 사용 가능
   - MIPS 하드웨어에는 move 명령어가 없지만 MIPS 어셈블러는 이 명령을 받아들임
```
move   $t0,  $t1    # 레지스터 $t1의 값을 $t0로 이동
```
   - 어셈블러는 이 명령어를 다음 명령에 해당하는 기계어로 바꿈
```
add $t0, $zero, $t1  # 레지스터 $t0의 값은 0 + 레지스터 $t1의 값을 더함
```

3. MIPS 어셈블러는 blt(branch on less than) 명령어를 slt와 bne 2개의 명령어로 바꿈
4. 이 외에도 bgt, bge, ble 명령어가 이렇게 처리됨
5. 먼 거기로 분기하는 명령어는 분기와 점프 명령어로 바꾸기도 함
6. 명령어의 수치 필드 크기는 16비트로 제한되어 있지만, MIPS 어셈블러는 레지스터는 32비트 상수를 넣는 일도 해줄 수 있음
7. 결과적으로 의사명령어는 실제의 하드웨어 구현보다 훨씬 더 풍부한 어셈블리 언어 명령어 집합을 제공
   - 이에 대한 대가는 레지스터 하나($at)를 어셈블러 전용으로 유보해둬야 함
   - 어셈블리 프로그램을 작성할 때 의사명령어를 적절히 사용하면 쉬워짐

8. 어셈블러는 여러 진수의 숫자를 받아들임 : 이진수와 십진수 뿐만 아니라, 이진수보다 간결하면서 이진수로 쉽게 바꿀 수 있는 그 외 진수도 사용 가능 (MIPS 어셈블러는 16진수 사용)
9. 어셈블러의 주 임무는 어셈블리 프로그램을 기계어로 번역하는 일
    - 어셈블러는 어셈블리 언어 프로그램을 목적 파일(Object File)로 바꾸며, 목적 파일에는 기계어 명령어, 데이터, 명령어를 메모리에 적절하게 배치하기 위해 필요한 각종 정보들이 혼합되어 있음
    - 어셈블리 언어 프로그램의 각 명령어를 이진수로 바꾸기 위해 레이블에 해당하는 주소를 모두 알아야함 : 어셈블러는 분기나 데이터 전송 명령에서 사용된 모든 레이블을 심벌 테이블(Symbol Table)에 저장되며, 이 테이블은 심벌과 그 주소를 저장
      + 심벌 테이블 : 레이블 이름을 명령어가 기억된 메모리 워드의 주소와 짝지어주는 테이블

10. UNIX 시스템 목적 파일은 다음과 같이 6개의 부분으로 구성
    - 목적 파일 헤더 : 목적 파일을 구성하는 각 부분의 크기와 위치 서술
    - 텍스트 세그먼트 : 기계어 코드가 들어있음
    - 정적 데이터 세그먼트 : 프로그램 수명 동안 할당되는 데이터가 들어있음 (UNIX는 프로그램 실행이 끝날 때까지 계속 할당되는 정적 데이터와 프로그램의 요구에 따라 커졌다 작아졌다하는 동적 데이터 두 가지 프로그램 사용)
    - 재배치(Relocation) 정보 : 프로그램이 메모리에 적재될 때, 절대 주소를 사용해야 하는 명령어와 데이터 워드 표시
    - 심벌 테이블 : 외부 참조같이 아직 정의되지 않고, 남아있는 레이블들을 저장
    - 디버깅 정보 : 각 모듈이 어떻게 번역되었는지에 대한 간단한 설명이 존재, 디버거는 이 정보를 이용해서 기계어와 C 소스 파일을 연관 짓고 자료 구조를 판단
    
