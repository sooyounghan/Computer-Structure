-----
### MIPS 명령어 필드
-----
1. MIPS 명령어 각 필드의 이름
<div align="center">
<img src="https://github.com/user-attachments/assets/ef2d5d60-84d4-483a-a9ef-c7bba61aa99c">
</div>

  - op : 명령어가 실행한 연산의 종류, 연산자(Opcode) (명령어가 수행할 연산과 형식을 나타내는 필드)
  - rs : 첫 번째 근원지(Resource) 피연산자 레지스터
  - rt : 두 번째 근원지 피연산자 레지스터
  - rd : 목적지(Destination) 레지스터, 연산 결과 기억
  - shamt : 자리이동(Shift)량
  - funct : 기능(Function), op 필드에서 연산의 종류를 표시하고 funct 필드에서 그 중 한 연산을 구체적으로 지정하는, 기능 코드(Function Code)라고 부름

2. 이것보다 필드 길이가 더 길어야 하는 경우 문제 발생 가능
   - 예를 들어 lw 명령어에는 레지스터 필드 2개와 상수 필드 1개가 필요 : 만약 위 5비트 필드 중 하나를 주소로 쓴다면, $2^{5} = 32$보다 작은 값만 사용 가능
     + 이 필드는 큰 배열이나 자료구조에 한 원소를 선택하는 데 사용
     + 따라서 32보다 큰 값이 필요할 경우가 많으므로 5비트 필드로는 부족

   - 이런 문제로 모든 명령어의 길이를 같게 하고 싶은 생각과 명령어 형식을 한 가지로 통일하고 싶은 생각에 대한 협상이 필요
   - MIPS 설계자들은 모든 명령어의 길이를 같게 하되, 명령어 종류에 따라 형식을 다르게 하는 방식 선택
     + 예를 들어, 위 명령어 형식은 R 타입 또는 R 형식(R = Register)이라 하는데, 이것만으로 불충하므로 I 타입 또는 I 형식이라는 두 번째 형식을 만듬
     + I 타입은 수치 연산과 데이터 전송 명령에 사용되며 모양은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/adf68bd9-9b5d-4a83-880a-a1aac626e22a">
</div>

   - 16비트 주소를 사용하므로 lw 명령은 베이스 레지스터 rs에 저장된 주소를 기준으로 $±2^{15} = ±32,768$바이트($±2^{13} = ±8192$워드)를 지정 가능
   - 마찬가지로 addi에서 사용할 수 있는 상수는 $±2^{15}$보다 더 클 수 없음
   - 이 명령어 형식에서는 레지스터를 32개 이상 사용하기가 어려움
   - 32개보다 많으면 rs와 rt 필드가 더 커져서 한 워드에 모든 정보를 담을 수 없게 됨
   - 예시
```
lw $t0, 32($s3)    # 임시 레지스터 $t0에 A[8] 값을 적재
```
   - 여기서 rs 필드는 19($s3의 번호), rt 필드에는 8($t0의 번호), 주소 필드에는 32가 들어감
   -  💡이 명령어에서는 rt 필드의 의미가 바뀌어 적재 결과가 들어갈 목적지 레지스터 번호를 표시하는 것으로 변경

3. 명령어 형식이 여러 가지가 되면 하드웨어가 복잡해지지만 모든 형식을 비슷하게 하면 복잡도를 낮출 수 있음
   - 예를 들어, R 타입과 I 타입의 처음 세 필드는 이름과 크기가 같고, I 타입의 네 번째 필드 길이는 R 타입의 나머지 세 필드 길이를 더한 것과 같게함
   - 명령어 형식은 첫 번째 필드의 값을 보고 구분할 수 있음
     + 형식별로 op 필드가 가질 수 있는 값들이 다르므로, 하드웨어는 op 필드를 보고 명령어의 오른쪽 절반 필드 3개로 볼 것인지(R타입), 필드 하나로 볼 것인지(I타입) 결정
   - MIPS 명령어의 각 필드 내용
<div align="center">
<img src="https://github.com/user-attachments/assets/6f11d662-57a0-4426-b326-250933399d4c">
</div>

4. 예제) MIPS 어셈블리 언어를 기계어로 번역
   - $t1에 배열 A의 시작 주소가 기억, $s2는 변수 h에 대응된다고 할 때, 다음 C 문장
```c
A[300] = h + A[300];
```
   - 컴파일
<div align="center">
<img src="https://github.com/user-attachments/assets/58dc70cc-4ea7-40a0-a804-46f90bbfc2eb">
</div>

   - 편의를 위해 기계어 명령어를 십진수로 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/ed55bcd5-9318-48f9-ba16-a42e5360194d">
</div>

   - lw 명령어의 op 필드 값은 35
     + rs 필드에는 베이스 레지스터 번호 9($t1), rt 필드에느 목적지 레지스터 번호 8($t0)이 지정
     + A[300]을 선택하기 위한 변위값(1200 = 300 X 4)은 마지막 필드인 address에 존재
   - 두 번째 명령어인 add 명령어
     + op 필드값이 0, funct 필드 값이 32
     + 레지스터 피연산자 3개(18, 8, 8)가 각각 두 번째, 세 번쨰, 네 번째 필드에 있으며 각각 $s2, $t0, $t0에 대응
   - sw 명령어의 op 필드 값은 43이며, 나머지 부분은 lw와 동일
   - 이 명령어를 이진수로 표현 (십진수 1200의 이진수 : 0000 0100 1011 0000)
<div align="center">
<img src="https://github.com/user-attachments/assets/42b86074-1a7a-4c78-a285-b7f892a2491a">
</div>

   - 첫 번째와 세 번쨰 명령어의 이진수 표현이 매우 유사하며, 유일한 차이점은 왼쪽에서 세번째 비트값

5. 모든 명령어의 길이를 같게하려는 것과 더 많은 레지스터를 가지려는 충돌이 지속적 발생
   - 레지스터 갯수를 늘리게 되면, 명령어 형식에서 각 레지스터 필드는 적어도 1비트가 더 필요하게 됨
   - 오늘날 대부분 명령어 집합은 16개 또는 32개의 범용 레지스터를 가짐

6. MIPS 어셈블리 언어
<div align="center">
<img src="https://github.com/user-attachments/assets/557037c1-cb88-4ae2-83e1-90a457fb3403">
</div>

7. 요약
   - 오늘날 컴퓨터는 두 가지 중요한 원리에 바탕을 둠
     + 명령어는 숫자로 표현
     + 프로그램은 메모리에 기억되어 있어, 데이터처럼 읽고 쓸 수 있음

   - 이는 내장 프로그램의 개념
   - 내장 프로그램의 장점 : 메모리에는 편집기가 편집중인 소스 코드, 컴파일된 기계어 프로그램, 실행 프로그램이 사용하는 텍스트 데이터, 심지어는 기계어를 생성하는 컴파일러까지 기억될 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/ac58c582-d97d-4e5b-8e6c-c78bd9e2b2e6">
</div>
