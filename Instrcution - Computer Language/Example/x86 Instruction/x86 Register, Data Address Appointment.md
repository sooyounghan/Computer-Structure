-----
### x86 명령어
-----
1. ARM이나 MIPS, RISC-V보다 강력한 연산을 제공하는 명령어 집합도 존재
   - 목적 : 프로그램이 실행하는 명령어의 개수를 줄이는 것
   - 하지만, 이는 명령어 처리 시간이 길어져서 프로그램 실행에 걸리는 시간이 오히려 늘어날 수 있음
   - 이렇게 느려지는 이유는 클럭 사이클 시간이 길어지거나 필요한 클럭 사이클 개수가 더 많아지기 때문임

2. x86 레지스터와 데이터 주소 지정 방식
   - 80386 레지스터 : 명령어 집합의 발달 과정을 알 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/594ab0ce-0dae-47e5-92bf-81554cbadab1">
</div>

   - 80386 레지스터는 모든 16비트 레지스터(세그먼트 레지스터 제외)를 32비트로 확장하고, 레지스터 이름 앞에 E를 붙임
     + 이 레지스터들을 범용 레지스터(General Purpose Register, GPR)라고 부름
     + 80386에는 GPR이 8개 밖에 없지만, MIPS는 이보다 4배나 더 많고, ARMv7은 2배가 많음

   - 산술 / 논리 / 데이터 전송 명령은 피연산자를 2개씩 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/c96f4309-c115-4269-a31c-6d3c3cb716a5">
</div>

   - ARM 및 MIPS와 비교하면 중요한 차이점이 두 가지 존재
     + ARMv7과 MIPS의 산술 및 논리 명령은 근원지와 목적지 레지스터를 독립적으로 지정할 수 있음
       * x86에서 피연산자 하나는 근원지이면서 동시에 목적지가 됨
       * 레지스터 개수도 충분하지 못한데다가 두 근원 레지스터 중 하나는 값이 변해야 하므로 매우 불편
     + 피연산자 중 하나가 메모리에 있을 수 있다는 것
       * MIPS나 ARMv7과 달리 거의 모든 명령어가 메모리 피연산자를 사용할 수 있음

   - 데이터 메모리 주소지정 방식은 명령어 내 두 가지 크기의 주소를 둘 수 있음
     + 변위(Displacement)라 부르는 이 주소는 8비트와 32비트 두 종류가 존재
     + 메모리 피연산자는 모든 주소 지정 방식을 사용할 수 있지만, 특정 주소 지정 방식에서 사용할 수 있는 레지스터에는 제한이 있음
     + x86의 주소 지정 방식과 각 주소 지정 방식에서 사용할 수 없는 레지스터
<div align="center">
<img src="https://github.com/user-attachments/assets/99db7ce1-deaa-4723-9692-4fb6775228a4">
</div>

