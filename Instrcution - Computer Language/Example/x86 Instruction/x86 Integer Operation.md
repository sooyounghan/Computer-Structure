-----
### x86의 정수 연산
-----
1. 8086은 8비트(바이트)와 16비트(워드) 데이터형을 지원하며, 80386은 여기에 32비트 주소와 32비트 데이터(더블워드)를 추가 (AMD64에서는 64비트 주소와 64비트 워드(쿼드워드)를 추가)
   - 이 데이터형 구분은 메모리 접근할 때 뿐만 아니라 레지스터 연산을 할 때도 적용

2. 거의 모든 연산이 두 데이터 모두 8비트인 경우와 둘 중 하나가 8비트보다 긴 경우를 모두 지원
   - 긴 데이터의 크기는 주소지정 방식에 따라 16비트와 32비트 중 하나로 정해짐
   - 세 가지 크기의 데이터를 모두 다뤄야하는 프로그램도 존재하므로, 80386 설계자들은 코드 길이를 많이 늘리지 않으면서, 데이터 크기를 간편하게 지정할 수 있는 방법 고안
   - 대부분 프로그램이 16비트나 32비트 데이터 중 한 가지를 주로 사용하는 경향이 있음을 착안해, 디폴트 데이터 크기를 선언하는 방법 사용
     + 디폴트 데이터 크기는 코드 세그먼트 레지스터의 비트 하나를 이용하여 설정
     + 디폴트 크기가 아닌 데이터를 사용할 때는 명령어에 8비트짜리 접두사를 붙여 다른 크기의 데이터를 사용하는 것을 알림

   - 이러한 접두사 사용법은 8086에서 차용한 것으로, 몇 가지 접두사를 사용해 명령어 동작에 변형을 가할 수 있게 됨 (본래 3가지 접두사)
     + 디폴트가 아닌 다른 세그먼트 레지스터의 사용
     + 동기화 지원을 위한 버스 잠금
     + ECX 레지스터가 0이 될 때까지 명령어 반복 실행 : 바이트 복사 명령어에 붙여서 가변 개수의 바이트 데이터를 복사하는 데 사용

   - 80386은 이 세 가지에 디폴트 크기가 아닌 주소를 사용하기 위해 접두사 하나 추가
   - x86의 정수 명령은 크게 네 가지 종류
     + move, push, pop을 포함하는 데이터 전송 명령
     + 검사와 정수 및 십진수 연산을 포함하는 산술 및 논리 명령
     + 조건부 분기, 무조건 점프, call, return 등을 포함하는 제어 흐름 명령
     + 문자열 이동 및 문자열 비교 등을 포함하는 문자열 명령

   - 산술 및 논리 명령의 목적지가 레지스터, 메모리 어느 쪽도 가능하다는 점을 제외하면 처음 두 종류는 특별한 것이 없음

3. 전형적인 x86 명령어와 그 기능
<div align="center">
<img src="https://github.com/user-attachments/assets/dad772b1-a414-4cad-a3b5-a0cfd0d500d6">
</div>

4. x86의 조건부 분기는 ARMv7처럼 조건 코드(또는 플래그)에 의해 결정
   - 조건 코드는 연산 결과에 따라 자동적으로 값이 결정되는데, 연산 결과가 0과 같은지 비교하는 데 가장 많이 사용
   - 분기 명령어는 조건 코드를 검사
   - ARMv7이나 MIPS와 달리 80386 명령어는 길이가 일정하지 않으므로 PC 상대 주소지정 방식에서 워드 주소를 사용하지 못하고, 바이트 주소를 사용해야 함

5. 문자열 명령어는 8080에서부터 있었던 것인데, 많이 사용되지 않음
   - 소프트웨어 루틴으로 처리하는 것보다 오히려 더 느린 경우가 많음

6. x86의 정수 명령어
<div align="center">
<img src="https://github.com/user-attachments/assets/adc616a9-0f09-44e3-8e2b-edd340610659">
</div>

   - 많은 명령어가 바이트와 워드 데이터 양쪽 다 지원
