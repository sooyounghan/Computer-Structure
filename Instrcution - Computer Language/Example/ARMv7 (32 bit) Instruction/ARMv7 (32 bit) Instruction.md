-----
### ARMv7 (32비트) 명령어
-----
1. ARM은 임베디드용으로 가장 인기 있는 명령어 집합 구조
   - ARM : Acorn RISC Machine의 약자로, Advanced RISC Machine으로 변경
   - ARM은 MIPS와 같은 해에 나옴

2. ARM와 MIPS, 두 프로세서 사이의 유사성
<div align="center">
<img src="https://github.com/user-attachments/assets/db9f711f-7c46-4714-bd06-34aeccba2312">
</div>

   - MIPS는 레지스터가 더 많고, ARM은 주소 지정 방식이 더 많음

<img width="1345" height="1500" alt="image" src="https://github.com/user-attachments/assets/d05b9973-a703-44d7-a0b2-254dc9ad094a" />

   - 산술-논리 명령어와 데이터 전송 명령어의 핵심은 MIPS와 ARM이나 비슷

3. 주소 지정 방식
<div align="center">
<img src="https://github.com/user-attachments/assets/36df1a84-0e8e-4caf-bb47-5ff73ab37d75">
</div>

   - MIPS와 달리 ARM에는 상수 0을 갖는 레지스터가 없음
   - MIPS는 겨우 3개의 단순한 데이터 주소지정 방식을 갖고 있는데 반해, ARM은 9개의 주소 지정 방식을 갖고 있으며, 이 중에는 상당히 복잡한 계산을 하는 방식도 포함
   - 예를 들면, 레지스터를 원하는 만큼 자리이동 한 후, 다른 레지스터 값에 더하여 주소를 만든 다음, 이 주소를 이용해 레지스터 값을 바꾸는 주소 지정 방식을 갖고 있음

4. 비교 및 조건부 분기
   - 조건부 분기 여부를 판단하기 위해 MIPS는 레지스터 값을 사용
   - 반면에 ARM은 프로그램 상태 워드에 저장되는 4개의 전통적인 조건 코드 negative, zero, carry, overflow 비트를 사용
     + 이 조건 비트들은 어느 산술 또는 논리 연산 명령 실행 시에도 설정될 수 있음
     + 초기 구조에서는 그렇지 않았지만, 현재는 명령어마다 조건 코드를 설정할지 말지 선택 가능
     + 명시적 선택 사항이 파이프라인 구현 문제를 덜 일으킴
     + ARM은 조건부 분기 명령어로 조건 코드를 검사해서 모든 부호없는 비교와 부호있는 비교를 수행

   - CMP는 한 피연산자에서 다른 피연산자를 뺀 후, 그 차이에 따라 조건 코드를 설정
   - CMN(Compare Natvie)은 한 피연산자에다 다른 피연산자를 더하여 그 결과로 조건 코드를 설정
     + TST : 두 피연산자에 논리적 AND 연산을 수행하여 overflow를 제외한 모든 조건 코드를 설정
     + TEQ : 두 피연산자에 Exclusive OR 연산을 하여 overflow를 제외한 나머지 조건 코드를 설정하게 됨

   - ARM의 특이한 점 중 하나는 모든 명령어가 조건부로 실행
     + 실행 여부는 지정된 조건 코드 값에 따라 결정
     + 모든 명령어의 첫 4비트 필드는 실행 여부를 결정하기 위해 검사할 조건 코드를 지정
     + 검사 결과에 따라 이 명령어가 nop (no operation) 명령어로 작동할지 아니면, 실제 명령어로 작동할지 결정
     + 따라서, 조건부 분기는 무조건 분기 명령어를 조건부 실행하는 것으로 생각해도 무리가 없을 것

   - 조건부 실행은 명령어 하나를 건너뛰기 위해 분기 명령어를 사용하는 일을 피할 수 있게 하며, 간단하게 명령어 하나만 조건부 실행하면되므로 코드 길이와 시간이 짧아짐

5. ARM과 MIPS 명령어 형식
<div align="center">
<img src="https://github.com/user-attachments/assets/b4430c11-35db-4d29-b1ba-7c9675bf8b15">
</div>

   - 주된 차이점은 모든 명령어가 4비트 조건부 실행 필드를 갖고 있으며, 레지스터 필드가 짧다는 것
   - ARM 레지스터 개수가 MIPS의 절반밖에 되지 않음

6. ARM의 고유한 특징
   - MIPS에는 없는 몇 가지 산술 / 논리 명령어
<div align="center">
<img src="https://github.com/user-attachments/assets/d487da21-5af8-44bc-913d-7bdf1217ba1e">
</div>

   - ARM은 0값을 갖는 전용 레지스터가 없으므로 MIPS가 $zero를 가지고 할 수 있는 연산을 수행할 수 있는 별도의 op 코드를 갖고 있음
   - ARM은 다중 워드 산술도 지원
   - ARM의 12비트 수치 필드는 처리 과정이 복잡 : 이 필드의 하위 8비트 앞에 0을 24개 붙여 32비트 수로 만든 다음, 이 필드의 왼쪽 4비트에 2를 곱한 값에 해당되는 비트만큼 오른쪽으로 회전
     + 이 방법의 장점은 32비트 워드로 나타낼 수 있는 모든 2의 멱승을 12비트로 표현 가능

   - 피연산자 자리이동이 수치에만 국한 되는 것이 아님
     + 모든 산술 및 논리 연산의 두 번째 레지스터는 연산이 취해지기 전 자리이동을 할 것인지, 말 것인지에 대해 선택 사항을 갖고 있음
     + 자리 이동 선택 사항은 shift left logicla, shift right logical, shift right arithmetic, rotate right

   - ARM에는 레지스터 여러 개를 저장하기 위한 명령어도 존재하는데, 이들 명령어는 block loads 및 block stores라 불림
     + 명령어에 있는 16비트 마스크를 사용하여 16개 레지스터 중 어느 것들도 명령어 하나로 적재하거나 메모리 저장 가능
     + 이 명령어들은 프로시저에 진입하거나 프로시저에 복귀할 때, 레지스터들을 저장하고 복원하는 데 사용되어, 프로시저 진입과 프로시저에서 빠져나가는 코드의 크기를 줄여줌
     + 그 외에 블록 메모리 복사에도 사용 가능
