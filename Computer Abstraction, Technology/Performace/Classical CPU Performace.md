-----
### 고전적인 CPU 성능식
-----
1. 성능식을 명령어 개수(프로그램이 실행한 명령어의 개수), CPI, 클럭 사이클 시간으로 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/50a370b8-5492-4da4-a52b-22ba76ff3316">
</div>

2. 클럭 속도는 클럭 사이클 시간의 역수
<div align="center">
<img src="https://github.com/user-attachments/assets/5bf22265-1cb0-44d5-bb5d-5b5529ef2599">
</div>

3. 이 식은 CPU 시간을 성능에 영향을 미치는 세 가지 핵심 인자로 표현했으므로 매우 유용
   - 이 공식을 이용해 두 가지 서로 다른 구현을 비교할 수 있음
   - 또한, 어떤 설계 대안이 세 인자에 미치는 영향을 알 수 있다면, 설계 대안을 평가하는 것도 가능

4. 예제) 코드의 비교
   - 어떤 컴파일러 설계자가 같은 상위 수준 언어 문장에 대해 두 가지 코드 1과 2 중 하나를 선택하려고 함
   - 하드웨어 설계자가 제공한 사실은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/1d8bdc3c-bc0a-4112-a7cd-5a26325f17e9">
</div>

   - 컴파일러 작성자가 어떤 상위 수준 언어 문장을 다음과 같은 두 가지 코드로 변환하는 방법을 고려
<div align="center">
<img src="https://github.com/user-attachments/assets/67058e09-28d9-4b83-b0a9-48f9a210251b">
</div>

   - 어떤 코드가 더 많은 명령어를 실행하고, 더 빠르고, 각 코드의 CPI는 얼마인가?
   - 코드 1 : 2 + 1 + 2 = 5 명령어 실행 /  코드 2 : 4 + 1 + 1 = 6 명령어 실행 - 따라서 코드 1이 더 적은 명령어 실행
   - 명령어의 개수와 CPI를 사용해 CPU 클럭 사이클 수 계산하는 공식 : 코드 2가 비록 명령어 하나를 더 실행하지만 실행 속도는 더 빠름
<div align="center">
<img src="https://github.com/user-attachments/assets/b468731a-03be-4638-8ddc-b7e1ec7464c2">
</div>

   - 코드 2의 경우 필요한 클럭 사이클 수는 적으면서 명령어는 더 많이 실행하므로 CPI가 낮음
<div align="center">
<img src="https://github.com/user-attachments/assets/232b758d-b4ff-4058-888f-6ab6b0ed734f">
</div>

   - 컴퓨터의 성능을 결정하는 기본 구성 요소와 각 측정에서 얻어지는 값
<div align="center">
<img src="https://github.com/user-attachments/assets/c13e1aef-cb79-4e52-a1c9-eeaeba9d44fb">
</div>

   - 이 인자들로부터 프로그램의 실행 시간 구하기
<div align="center">
<img src="https://github.com/user-attachments/assets/3656a004-a7d9-48fd-b69f-b6e3c6a649ed">
</div>

   - 컴퓨터 성능에 대한 완벽하고 믿을만한 척도는 실행시간 밖에 없음
     + 예를 들어, 명령어 개수를 줄이기 위해 명령어 집합을 바꾸었을 때 클럭 속도가 느려지거나 CPI가 커져서 오히려 성능이 더 나빠질 수 있음
     + 마찬가지로 CPI는 실행되는 명령어 종류에 따라 달라지므로 실행 명령어 수가 적은 코드가 항상 가장 빠른 것은 아님

5. 성능식의 세 가지 인자값 구하기
   - CPU 실행시간 : 실제 프로그램을 실행시켜 얻을 수 있음
   - 클럭 사이클 시간 : 보통 컴퓨터 하드웨어 메뉴얼에 기록
   - 명령어 개수와 CPI
     + 명령어 개수는 실행 과정을 추적하는 소프트웨어 도구나 컴퓨터 구조 시뮬레이터를 이용해 측정 가능
       * 그 외, 하드웨어 카운터(프로세서에 장착)를 사용하면 실행 명령어 수나 평균 CPI, 성능 저하의 원인까지 찾을 수 있음
       * 명령어 개수는 구조에 따라 결정될 뿐 구현 방법과 상관없음
     + CPI는 프로그램 실행에 사용되는 명령어 배합 뿐만 아니라 메모리 시스템과 프로세서 구조를 포함하는 여러 가지 컴퓨터 세부 설계에 따라 달라짐
       * 따라서 CPI는 명령어 집합이 같더라도 구현 방식에 따라서 달라질 뿐 아니라 응용 프로그램에 따라서도 달라짐

6. 두 컴퓨터를 비교할 때는 실행 시간에 영향을 미치는 세 가지 인자를 모두 고려해야 함
   - 어떤 인자(예) 클럭 속도)가 같으면 다른 인자들을 비교해 성능을 평가해야 함
   - CPI는 명령어 배합(Instruction Mix, 하나 또는 여러 개의 프로그램에서 수행된 명령어들의 동적 빈도수에 대한 척도)에 따라 달라지므로 클럭 속도가 같더라도 명령어 개수와 CPI는 반드시 비교해야함

7. 프로그램의 성능은 알고리즘 / 언어 / 컴파일러 / 컴퓨터 구조 / 실제 하드웨어의 영향을 받음
   - 이러한 요소들이 CPU 성능식 인자에 어떤 영향을 미치는지 보여주는 표
<div align="center">
<img src="https://github.com/user-attachments/assets/23d83faf-de2a-4fc5-93ab-9fc54a4cedb8">
</div>

   - CPI의 최소값이 1.0일 것이라고 생각하지만, 어떤 프로세서는 매 클럭 사이클마다 여러 개의 명령어를 인출하고 수행 : 이런 방식을 반영하기 위해 CPI의 역수인 IPC(Instruction per Clock-cycle, 클럭 사이클 당 명령어 수)를 제시
     + 어떤 프로세서가 클럭 사이클 당 평균 2개의 명령어를 수행한다면, IPC는 2가 되고, CPI는 0.5

   - 전통적으로 클럭 사이클 시간은 고정값으로 사용했지만, 오늘날 프로세서는 에너지 절약, 일시적 성능 향상을 위해 클럭 속도를 변경시키기도 하므로, 프로그램에 대한 평균 클럭 속도를 사용할 필요가 있음
     + Intel Core i7은 칩이 너무 뜨거워지기 전까지 한시적으로 클럭 속도를 10% 향상 : 이를 터보 모드(Turbo Mode)라고 함
