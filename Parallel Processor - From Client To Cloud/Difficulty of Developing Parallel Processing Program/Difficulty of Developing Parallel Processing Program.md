-----
### 병렬 처리 프로그램 개발의 어려움
-----
1. 멀티프로세서를 사용하여 1개의 태스크를 더 빨리 수행하는 소프트웨어를 작성하는 것은 어려운 일이며, 프로세서 개수가 증가하면 문제가 더 심각해짐
   - 병렬 프로그램을 사용할 때는 더 높은 성능과 에너지 효율을 얻어야 함 : 그렇지 못하면, 단일프로세서에서 프로그래밍하기 쉬운 순차 프로그램을 사용하는 편이 나음
     + 실제로 프로그래머의 개입이 전혀 없어도 명령어 수준의 병렬성(Instruction-Level Parallelism, ILP)을 활용하는 슈퍼스칼라나 비순차 실행 같은 단일프로세서 설계 기술이 이미 개발되어 사용도고 있음
     + 이러한 혁식전인 기법 때문에 멀티프로세서를 위해 프로그램을 다시 작성할 필요가 크지 않음

   - 빠르게 수행되는 병렬 처리 프로그램을 작성하기 힘든 이유 (그 중 프로세서 개수가 증가할수록 어려워지는 이유)
     + 작업의 스케줄링 / 작업을 병렬 조각으로 나누는 일 / 부하를 균등하게 하는 일 / 동기화 시간을 줄이는 일 / 서로 통신하는 오버헤드를 줄이는 일 등 더 많은 프로세서를 사용할수록, 이러한 문제는 어려워짐

2. 예) 속도 제한의 어려움 : 100개의 프로세서를 가지고 90배의 속도 개선을 얻기를 원한다고 가정할 때, 원 프로그램에서 최대 몇 %까지 순차적으로 실행되도 좋은가?
   - Amdahl의 법칙
<div align="center">
<img src="https://github.com/user-attachments/assets/3d54cd54-875b-423c-83c1-cc5e8a618ad4">
</div>

   - 이 법칙을 속도 개선과 원 실행시간의 관계식으로 다시 작성
<div align="center">
<img src="https://github.com/user-attachments/assets/308502f3-3ed7-43dc-a50a-6a9e10b51aa5">
</div>

   - 원 실행 시간을 1이라고 가정하고, 이 식을 다시 정리하면 개선된 부분의 시간이 원 실행시간에 대한 비율로 변경
<div align="center">
<img src="https://github.com/user-attachments/assets/1a8c32ba-3a22-4a68-b4b9-9f58354693e9">
</div>

   - 기대하는 속도 개선 90을 식에 대입하고, 개선의 크기에 100을 대입
<div align="center">
<img src="https://github.com/user-attachments/assets/3b1353a4-5b01-4d0c-a984-ee2e884415af">
</div>

   - 이 식을 풀어서 개선된 부분의 비율을 구하면 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/ccab6b70-8f91-4497-befb-d4bf25c9802a">
</div>

   - 따라서 100개 프로세서를 이용해 90배 속도 개선을 얻기 위해서는 전체 프로그램에서 순차적인 부분 비율이 0.1% 이하가 되어야 함

3. 예) 속도 개선의 어려움 : 큰 문제
   - 다음 두 가지 덧셈을 수행한다고 가정 : 하나는 10개의 스칼라 변수의 합을 구하는 것이고, 다른 하나는 10 X 10 2차원 행렬의 합을 구하는 것
     + 행렬의 합 계산을 병렬화할 수 있다고 가정
     + 10개의 프로세서를 사용하는 경우와 40개의  프로세서를 사용하는 경우의 속도 개선
     + 또한, 행렬의 크기를 20 X 20로 늘렸을 때 속도 개선

   - 덧셈 연산을 수행하는 시간을 t라고 가정하고, 성능이 t의 함수라고 가정
     + 이 때, 스칼라 변수 변수 10개의 덧셈은 병렬 프로세서를 사용해도 좋아지지 않지만, 100번 덧셈은 병렬 프로세서를 사용하면 좋아질 수 있음
     + 단일프로세서에서의 실행 시간은 110t이고, 10개의 프로세서를 사용하는 경우 실행시간
<div align="center">
<img src="https://github.com/user-attachments/assets/77e853fe-1a70-4489-bf92-5c13558d401a">
</div>

   - 따라서 10개의 프로세서를 사용하는 경우 속도 개선은 110t / 20t = 5.5
   - 40개의 프로세서를 사용하는 경우 실행시간
<div align="center">
<img src="https://github.com/user-attachments/assets/6472ca0a-040f-476b-9465-e6622812a174">
</div>

   - 그러므로 40개의 프로세서를 사용하는 경우 속도 개선은 110t / 12.5t = 8.8
   - 이 크기의 문제에서 프로세서 10개를 사용한다면 이상적인 경우 55%가 해당되는 만큼 속도 개선을 얻는다면, 40개를 사용하면 이상적인 경우 22%에 해당하는 만큼만 속도 개선을 얻음
   - 행렬 크기를 키울 경우
     + 순차적으로 수행하는 경우 10t + 400t = 410t이며, 프로세서 10개를 사용하는 경우 실행 시간 (크기 40 → 10으로 수정되어야 함)
<div align="center">
<img src="https://github.com/user-attachments/assets/64d46746-49cc-4795-9721-b4938b6afd5e">
</div>

   - 따라서 속도 개선은 410t / 50t = 8.2이며, 프로세서 40개를 사용하는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/4d740d02-9276-43b4-be62-867801ab3d8d">
</div>

   - 속도 개선은 410t / 20t = 20.5
   - 이렇게 큰 프로그램의 경우 프로세서 10개를 사용할 때는 이상적인 경우 82%, 40개를 사용할 때는 이상적으로 51%의 속도 개선을 볼 수 있음

4. 문제의 크기를 고정시킨 상태에서 속도 개선을 얻는 것이 문제의 크기를 증가시키면서 속도 개선을 얻는 것보다 어려움
5. 그 차이를 구별하기 위해 스케일링 방법을 표시하는 두 가지 용어를 사용
   - 경성 스케일링(Strong Scaling) : 문제의 크기를 고정시킨 상태에서 멀티프로세서에서 얻을 수 있는 속도 개선
   - 연성 스케일링(Weak Scaling) : 프로세스 개수에 비례해 문제의 크기를 증가시킬 때 멀티프로세서에서 얻을 수 있는 속도 개선
   - 문제의 크기 M이 메인 메모리 내 워킹셋(Working Set)과 같고 프로세스 P개가 있다고 가정
     + 경성 스케일링의 경우 프로세서당 메모리는 M / P이고, 연성 스케일링의 경우 대략 M
   - 경성 스케일링보다 연성 스케일링이 더 쉽다는 것이 일반적인 통념이지만 메모리 계층구조 떄문에 반대 현상이 생길 수 있음
     + 예를 들어, 연성 스케일링 문제가 너무 커져서 멀티코어 마이크로프로세서의 마지막 단계 캐시에서 다 들어가지 않으면, 경성 스케일링을 사용하는 경우보다 성능이 훨씬 나빠질 수 있음

6. 응용에 따라 어떤 스케일링 방식이 좋은지 달라질 수 있음
   - 예를 들어 TPC-C 차변-대변(Debit-Credit) 데이터베이스 벤치마크에서 분당 트랜잭션 성능이 높아지면 이에 맞추어 고객의 계좌의 수도 늘려야 함
   - 즉, 문제의 크기를 키우려면 데이터의 양을 늘려야 하는데, 이런 경우가 연성 스케일링이 적합한 경우

7. 예) 속도 개선의 어려움 - 부하 균형(Load Balancing)
   - 40개 프로세서를 사용하여 20.5배의 속도 개선을 얻기 위해 부하가 완전히 균형을 이룬 것으로 가정
     + 즉, 각 프로세서가 2.5%씩 부하를 나누어 가졌다고 생각
     + 이 예제에서는 어떤 프로세서의 부하가 나머지 프로세서들보다 더 크면 속도 개선에 영향을 미치는 것을 확인하기 위해 한 프로세서의 부하가 2배로 증가하는 경우(5%)와 5배로 증가하는 경우(12.5%)의 속도 개선 계산

   - 한 프로세서가 병렬로 수행될 부분의 5%를 담당하면 5% X 400, 즉, 20개의 덧셈을 수행하고 나머지 39개의 프로세서가 380개의 덧셈을 나누어 수행
   - 이 연산들이 동시에 수행되므로 실행시간이 가장 많이 걸리는 경우에만 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/f5a03049-b2cd-46b2-9a1d-2c1eca7c8f9e">
</div>

   - 속도 개선이 20.5에서 410t / 30t = 14로 감소
   - 한 프로세서가 20t 동안 쉬지 않고 일을 수행하는 동안 나머지 39개 프로세서는 380t / 39 = 9.7t 시간만 일하고 나머지 반 이상의 시간을 놀게 됨
   - 만약 한 프로세서가 12.5%의 부하를 갖는다면 이 프로세서는 50개의 덧셈을 수행해야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/01956ff0-a0dc-4941-a5c9-e8f1d0556c28">
</div>

   - 속도 개선은 더 떨어져서 410t / 60t = 7이 되며, 나머지 프로세서는 20% 이하(90t / 50t)만 활용하게 됨
   - 이 예제는 부하 균형의 중요성을 보여주며, 한 프로세서의 부하가 다른 프로세서들보다 2배 커지면 속도 개선이 1/3만큼 줄어들어, 원래의 2/3 정도가 되고, 5배 커지면 속도 개선이 1/3 수준으로 떨어짐
