-----
### 하드웨어 멀티스레딩
-----
1. 한 스레드가 실행할 수 없게 되면, 다른 스레드로 전환되도록 하여 프로세서의 이용률을 높이는 기법
2. MIMD가 여러 프로세서들을 바쁘게 만들기 위해 여러 개의 프로세스(Process) 또는 스레드(Thread)를 사용하는 반면, 하드웨어 멀티스레딩은 여러 스레드가 단일프로세서의 기능 유닛들을 겹쳐서 사용함으로써 하드웨어 자원을 효율적으로 사용
   - 프로세스 : 프로세스는 1개 이상 스레드와 주소 공간, 운영체제 상태를 가지므로, 프로세스 전환은 보통 운영체제를 호출하지만, 스레드 전환은 운영체제를 부르지 않음
   - 스레드 : 스레드는 프로그램 카운터와 레지스터 상태, 스택을 가지며, 경량 프로세스이므로 주소 공간을 공유하지 않지만, 프로세스는 그렇지 않음


3. 이와 같은 방식의 공유를 위해 프로세서는 각 스레드의 독립적 상태를 복제해야 함
   - 예를 들어, 모든 스레드는 레지스터 파일과 프로그램 카운터의 복사본을 따로 가지고 있음
   - 메모리는 가상 메모리 메커니즘을 통해 공유됨
   - 이 외에도 하드웨어는 스레드를 빨리 전환하는 기능을 지원해야 함 (특히 스레드 전환은 수백, 순천 사이클이 소모되는 프로세스 전환보다 훨씬 효율적으로 수행되어 순식간에 이루어져야 함)

4. 하드웨어 밀티스레딩의 두 가지 주요 방식
   - 작은 단위 멀티스레딩 (Fine-grained Multithreading) : 한 명령어를 실행하고 난 후에는 다른 스레드로 전환하는 하드웨어 멀티스레딩의 한 방식
     + 즉, 매 명령어마다 스레드를 전환하여 여러 개의 스레드를 인터리빙하는 방식
     + 해당 사이클에 지연 상태에 있는 스레드는 건너뛰면서 라운드 로빈(Round-Robin) 방식으로 인터리빙하는 것이 일반적
     + 작은 단위 멀티 스레딩이 실용성을 가지려면 클럭 사이클마다 스레드를 전환할 수 있어야 함
     + 작은 단위 멀티스레딩의 핵심적인 장점은 한 스레드가 지연되고 있는 동안 다른 스레드 명령어를 수행함으로써 짧은 지연, 혹은 긴 지연으로 인한 처리량의 손실을 감출 수 있다는 점
     + 반면에 단점은 개별 스레드의 수행이 느려진다는 점으로, 지연 없이 바로 수행될 수 있는 스레드라 할지라도 다른 스레드의 명령어 수행 때문에 지체되기 때문임

   - 큰 단위 멀티스레딩 (Coarse-Grained Multithreadig) : 마지막 단계 캐시 실패와 같은 심각한 사건이 일어날 때에만 스레드를 전환하는 하드웨어 멀티스레딩의 한 방식
     + 즉, 작은 단위 멀티스레딩의 대안으로 고안되었음
     + 스레드 전환 비용이 매우 작아야 할 필요가 없으며, 긴 지연이 발생하는 경우에만 다른 스레드의 명령어를 실행하기 때문에 개별 스레드의 수행이 느려지는 문제도 완화
     + 그러나 큰 단위 멀티스레딩은 작연 지연들로 인한 처리량의 손실을 극복하는데 한계가 있다는 단점이 존재
     + 이 문제는 큰 단위 멀티스레딩의 파이프라인 초기화 비용 때문에 발생하며, 큰 단위 멀티스레딩은 한 스레드에 속한 명령어들만 내보내기 떄문에, 지연이 발생하면 파이프라인을 새로 채워야 함
     + 이와 같은 초기화 비용 때문에 파이프라인을 채우는 시간을 무시할 수 있을 만큼 지연시간이 긴 경우에 더 유용

   - 동시 멀티스레딩(Stimultaneous Multithreading ,SMT) : 다중 내보내기와 동적 스케줄링을 지원하는 마이크로구조의 자원을 활용하여 멀티스레딩의 비용을 줄이는 멀티스레딩 한 방식
     + 즉, 하드웨어 멀티스레딩의 변형으로, 다중 내보내기(Multiple-Issue)와 동적 스케줄링을 지원하는 파이프라인 프로세서의 자원을 이용해 명령어 수준의 병렬성뿐 아니라 스레드 수준 병렬성도 함께 이용
     + 다중 내보내기 프로세서들은 일반적으로 한 스레드가 효과적으로 사용할 수 있는 것보다 더 많은 기능 유닛 병렬성을 가지고 있다는 점에 찾안하여 SMT가 등장하게 됨
     + 더욱이, 레지스터 재명명과 동적 스케줄링을 사용하면 서로 다른 스레드에 가져온 명령어 여러 개를 그들 간의 종속성에 신경 쓰지 않고 내보낼 수 있음 : 종속성은 동적 스케줄링 기능을 해결할 수 있음

5. SMT는 기존의 동적 메커니즘을 사용하므로 매 사이클마다 자원을 바꾸지 않음
   -  대신 늘 여러 스레드 명령어들을 함께 실행하고, 명령어 슬롯이나 재명명된 레지스터를 적절한 스레드에 할당하는 일은 하드웨어에게 맡김

6. 프로세서 구성에 따라 슈퍼스칼라 자원을 활용하는지 어떻게 다른지 개념적으로 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/d374f59e-a18a-4569-b516-ade993b9278d">
</div>

   - 그림의 상단부는 멀티스레딩을 지원하지 않는 슈퍼스칼라 프로세서에서 4개의 스레드가 따로따로 수행되는 것을 보여줌
   - 하단부는 다음 세 가지 멀티스레딩 방식이 4개의 스레드를 어떻게 더 효율적으로 실행할 수 있는지 보여줌
     + 큰 단위 멀티스레딩을 지원하는 슈퍼스칼라
     + 작은 단위 멀티스레딩을 지원하는 슈퍼스칼라
     + 동시 멀티스레딩을 지원하는 슈퍼스칼라

7. 하드웨어 멀티스레딩을 지원하지 않는 슈퍼스칼라는 명령어 수준 병렬성이 부족하므로 내보내기 슬롯의 이용률이 낮아짐
   - 게다가 명령어 캐시 실패같은 큰 지연이 발생하면 전체 프로세서가 아무 일도 하지 않고 놀게 됨
   - 큰 단위 멀티스레딩 슈퍼스칼라에서 긴 지연이 발생하면 다른 스레드로 전환하여 이를 일부 감출 수 있음 : 이렇게 하면 아무 일도 하지 않는 클럭 사이클 수를 줄일 수 있지만, 파이프라인 초기화 오버헤드 떄문에 아무 일도 하지 않는 사이클이 생기며, 명령어 수준 병렬성이 부족하므로 모든 내보내기 슬롯을 사용하는 것이 불가능하게 됨
   - 작은 단위 멀티스레딩의 경우에는 스레드의 인터리빙을 통하여 아무 일도 하지 않는 사이클을 대부분 없앨 수 있음
     + 그러나 한 클럭 사이클에서 한 스레드의 명령어만 내보내기 때문에 명령어 수준의 병렬성이 부족하여 여전히 일부 클럭 사이클에서는 노는 슬롯이 생기게 됨

8. SMT의 경우에도 스레드 수준 병렬성과 명령어 수준 병렬성이 모두 활용되어, 한 클럭 사이클에서 여러 스레드가 내보내기 슬롯을 같이 사용함
   - 이상적인 경우라면 여러 스레드가 필요로 하는 자원과 실제 가용 자원 간의 불균형 내보내기 슬롯의 활용도를 제한하게 됨
   - 그러나 실제로는 다른 요인들이 슬롯 사용을 제약할 수 있음
   - 프로세서들의 실제 동작을 아주 단순화했지만, 멀티스레딩이 갖는 잠재적 성능상의 이점, 특히 SMT의 장점을 잘 보여주고 있음
  
