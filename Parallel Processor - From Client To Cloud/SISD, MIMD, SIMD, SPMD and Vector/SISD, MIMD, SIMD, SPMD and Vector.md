-----
### SISD, MIMD, SIMD, SPMD와 벡터
-----
1. 명령어 스트림의 개수와 데이터 스트림 개수에 기반을 둔 분류법
<div align="center">
<img src="https://github.com/user-attachments/assets/7438adef-824f-4400-a59f-041d858bab90">
</div>

   - 전통적인 단일프로세서는 1개의 명령어 스트림과 1개의 데이터 스트림을 가지는데, 이를 SISD(단일 명령어 단일 데이터(Single Instruction Single Data) 스트림)
   - 전통적인 멀티프로세서는 여러 개의 명령어 스트림과 여러 개의 데이터 스트림을 가지는데, 이를 MIMD(복수 명령어 복수 데이터(Multiple Instrunction Multiple Data) 스트림)

2. MIMD 컴퓨터의 각 프로세서가 서로 다른 프로그램을 수행하면서도 모든 프로그램이 협력하여 큰, 통합된 목적을 달성하도록 프로그래밍하는 것이 가능
   - 하지만 보통은 모든 프로세서가 같은 프로그램을 수행하되, 조건문을 사용하여 각 프로세서가 코드의 서로 다른 부분을 수행하도록 하는 방법을 사용 : 이런 방식을 SPMD(단일 프로그램 복수 데이터(Single Program Multiple Data) 스트림, 모든 프로세서가 같은 프로그램을 수행하는 MIMD의 전통적 프로그래밍 모델)

3. 여러 개의 명령어 스트림을 가지면서 단일 데이터 스트림을 갖는 MISD로 분류될 수 있는 컴퓨터와 가장 유사한 것은 단일 스트림에 대하여 파이프라인 방식으로 일련의 계산을 수행하는 스트림 프로세서(Stream Processor)
   - 예를 들어, 네트워크로 받은 입력을 구문 분석하고, 암호를 풀고, 압축을 푼 다음, 매칭되는 것을 찾는 등의 일련의 작업을 파이프라인 방식으로 수행하는 것
   - MISD의 반대인 SIMD는 벡터 데이터에 대한 연산을 실행 (예를 들어, SIMD 명령어 하나는 64개 데이터 스트림을 64개의 ALU로 보내서 한 클럭 사이클에 64개의 합을 계산할 수 있음)
   - SIMD의 장점은 병렬 실행 유닛들이 동기화되어 있어서 한 프로그램 카운터(PC)로 인출한 명령어 하나를 일제히 수행한다는 것
     + 프로그래머의 관점에서 보면 SISD와 거의 비슷하며, 모든 유닛들이 동일한 명령어를 수행하는 것과 같은데, 실행 유닛마다 별도의 주소 레지스터를 가지고 있어 다른 데이터 주소를 사용할 수 있다는 점이 다름
     + 즉, 순차적인 프로그램을 직렬 하드웨어인 SISD에서 실행되도록 컴파일 할 수 있고, 병렬 하드웨어인 SIMD에서 실행되도록 컴파일 가능
     + 원래 SIMD를 개발하게 된 동기는 여러 실행 유닛들을 제어하는 제어 유닛을 하나로 통합해서 비용을 절약하는 것
     + 그 외에도 프로그램 메모리 크기가 작아도 된다는 장점이 있음
   - 메세지 전달 MIMD는 프로세서마다 별도의 프로그램을 가지고 있어야 하고, 공유 메모리 MIMD는 여러 개의 명령어 캐시를 가지고 있어야 하지만, SIMD는 동시에 수행할 프로그램 하나만 있으면 됨
   - SIMD는 for 순환문에서 배열을 처리할 때 가장 효율적
     + 그러므로 SIMD 병렬성을 잘 활용하려면 동일한 구조를 갖는 데이터가 매우 많이 있어야 하는데, 이를 데이터 수준 병렬성(Data-Level Parallelism, 독립적인 데이터에 같은 연산을 수행함으로써 얻어지는 병렬성)이라고 부름
     + SIMD는 case나 switch 문장을 실행할 때 약점을 보이는데, 이 때는 각 실행 유닛이 자신이 가진 데이터가 무엇인가에 따라 다른 동작을 수행해야 하기 때문임
     + 부적합한 데이터를 가진 실행 유닛들은 동작을 억제시키고, 적합한 데이터를 가진 유닛들만 동작하도록 해야 함 : case나 switch 경우의 수가 n이라면, 성능은 1 / n로 떨어짐
