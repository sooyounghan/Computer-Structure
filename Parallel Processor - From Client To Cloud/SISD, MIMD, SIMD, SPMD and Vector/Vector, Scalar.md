-----
### 벡터와 스칼라 비교
-----
1. 벡터 명령어와 일반적인 명령어 집합 구조(스칼라 구조)의 비교
   - 벡터 명령어는 많은 양의 작업을 지정하므로, 벡터 명령어 하나가 순환문 전체 수행과 같음 : 그러므로 명령어 인출과 해독의 대역폭이 획기적으로 줄어듬
   - 벡터 명령어를 사용하면 벡터를 구성하는 각 원소들의 계산이 벡터 내른 다른 원소들의 계산과 독립적이 되므로, 한 벡터 명령어 내 데이터 해저드를 점검하는 하드웨어가 필요 없음
   - 데이터 수준 병렬성을 가지고 있는 응용에 대해서는 벡터 구조와 벡터 컴파일러를 이용하는 것이 MIMD 멀티프로세서에서 프로그래밍하는 것보다 훨씬 쉽다고 알려져 있음
   - 모든 벡터 원소 하나 하나에 대해 데이터 해저드를 점검하는 대신, 벡터 피연산자 하나 당 한 번씩만 점검하면 되므로, 전력 소모도 그만큼 줄어듬
   - 메모리에 접근하는 벡터 명령어의 경우 메모리 접근 패턴을 미리 알 수 있음
     + 벡터의 원소들이 모두 인접해있다면, 인터리빙 정도가 큰 인터리브 메모리에서 벡터를 인출하는 것이 매우 효율적
     + 메인 메모리에서 매 워드를 인출할 때마다 메모리 지연을 겪는 것이 아닌 전체 벡터에 대해서 단 한 번만 지연을 겪음
   - 순환문 전체가 행동이 이미 정해진 벡터 명령어 하나로 치환되므로 순환문의 분기로 인한 제어 해저드가 발생하지 않음
   - 명령어 대역폭과 해저드 점검 빈도수가 줄고, 메모리 대역폭이 효율적으로 사용되기 때문에, 벡터 구조가 스칼라 구조보다 전력과 에너지 면에서 유리

2. 동일한 개수의 데이터에 대해 스칼라 연산을 수행하는 것보다 벡터 연산을 이용하면 더 빠르게 수행 가능
3. 따라서, 컴퓨터 설계자들은 벡터 연산을 자주 사용할 수 있는 응용이 있다면, 벡터 유닛을 포함시키는 방향으로 가게 됨
