-----
### x86의 SSE와 AVX
-----
1. x86의 원래 MMX(MultiMedia eXtension)와 SSE(Streaming SIMD Extension) 명령어는 ARM NEON과 같은 연산들을 포함하고 있었음
   - 2001년 Intel은 SSE2의 일부로 2배 정밀도 부동 소수점 레지스터와 연산을 포함해 144개의 명령어를 추가
   - 부동 소수점 피연산자를 저장하는 8개의 64비트 레지스터를 두었음

2. AMD는 AMD64의 한 부분으로 레지스터 개수를 16개로 늘리고, 이를 XMM이라고 하고, Intel은 이를 사용하면서 EM64T라고 이름을 바꿈
3. SSE와 SSE2 명령어 요약
<div align="center">
<img src="https://github.com/user-attachments/assets/53ac3a0d-6aee-4f3e-8a50-da52dc7f0d30">
</div>

4. 단일 정밀도나 2배 정밀도 수를 레지스터에 저장하는 외에 Intel은 여러 개의 부동 소수점 수(단일 정밀도 수 4개 또는 2배 정밀도 수 2개)를 128비트 SSE2 레지스터 하나에 채워 넣을 수 있게 함
   - 그러므로 SSE2를 위한 부동 소수점 레지스터 16개의 실제 크기는 128비트
   - 피연산자를 정렬된(Aligned) 128비트 데이터 형태로 메모리에 넣을 수 있으면, 128비트 데이터 전송 명령어 하나로 여러 개의 피연산자를 적재 또는 저장 가능
   - 이렇게 묶여진(Packed) 부동 소수점 형식은 단일 정밀도 수 4개(PS) 또는 2배 정밀도 수 2개(PD)를 동시에 연산하는 명령어로 처리

5. 2011년 Intel은 고급 벡터 확장(AVX)을 도입하면서 레지스터 폭을 다시 2배로 키우고 이를 YMM이라 부름
   - 그래서 단일 연산으로 8개의 32비트 부동 소수점 연산 또는 4개의 64비트 부동 소수점 연산을 명시할 수 있게 됨
   - 기존 SSE과 SSE2 명령어는 YMM 레지스터의 하위 128비트 상에서 연산을 수행
   - 128비트 연산에서 256비트 연산으로 확장되면서 SSE2 어셈블리 언어 연산자 앞에 접두어 v(vector)를 붙이고 XMM 레지스터 이름 대신 YMM 레지스터 이름 사용
   - 예를 들어 64비트 부동 소수점 덧셈 2개를 수행하는 SSE2 명령어
```
addpd %xmm0, %xmm4
```
   - AVX
```
vaddpd %ymm0, %ymm4
```
   - 64비트 부동 소수점 덧셈 4개를 한 꺼번에 실행
   - 2015년도에 Intel은 일부 마이크로프로세서에 AVX512를 도입하면서 레지스터를 다시 2배 확장하여 512비트로 키우고, 이를 ZMM이라고 부름

6. AVX는 x86에 주소 3개를 사용하는 명령어도 추가
```
vaddpd %ymm0, %ymm1, %ymm4   # %ymm4 = %ymm0 + %ymm1
```
   - 이전 버전은 다음과 같이 2개의 주소 사용
```
addpd %xmm0, %xmm4   # %xmm4 = %xmm4 + %xmm0
```
   - MIPS와 달리 x86는 목적지가 오른쪽에 존재
   - 3-주소 명령어는 계산에 필요한 레지스터와 명령어 수를 줄일 수 있음
