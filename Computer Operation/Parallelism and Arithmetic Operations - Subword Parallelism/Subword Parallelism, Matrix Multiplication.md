-----
### 서브워드 병렬성과 행렬 곱셈
-----
1. 서브워드 병렬성이 성능에 미치는 영향을 알아보기 위해 AVX를 사용해 코드를 실행
   - x86 AVX 명령어를 이용해 일관성 있게 양질의 프로그램을 생성하도록 컴파일러를 만들 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/9c0a8112-a172-47dd-a9ad-487177f39041">
</div>

   - 7번 행의 _m512d 데이터 형을 사용하는데, 이는 컴파일러에게 이 변수는 8개의 2배 정밀도 부동 시스템(8 X 64비트 = 512비트)을 갖는다고 알려주는 것
     + C intrinsic _mm512_load_pd()는 행렬 C에서 8개의 2배 정밀도 부동 소수점 수를 병렬로(_pd) c0에 적재하는 AVX 명령어 사용
     + 주소 계산 C + i + j * n은 원소 C[i + j * n]을 나타냄
   - 마지막 단계인 13번 줄은 2배 정밀도 부동 소수점 8개를 c0에서 행렬 C로 보내기 위해 C intrinsic _mm256_store_pd() 사용
     + 매번 반복할 때마다 원소를 8개씩 처리하므로, 4번 줄의 외부 for 순환문은 i를 1 증가시키지 않고, 8씩 증가시킴
     + 순환문 내부의 10번 행에서는 다시 _mm512_load_pd()를 이용해 A의 원소 8개를 적재
     + 이 원소들을 B의 한 원소와 곱하기 위해 먼저 C intrinsic _mm512_broadcast_sd()를 사용해 스칼라 2배 정밀도 수(이 경우 8의 한 원소)의 복사본 8개를 ZMM 레지스터에 하나 넣음

   - 11번 행에서는 _mm512_fmadd_pd를 사용해 2배 정밀도 곱하기 8개를 병렬로 실행한 후, c0에 있는 합 8개에 곱셈 결과 8개를 각각 더함

2. 컴파일러가 생성한 내부 순환문의 x86 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/807b7486-48c8-4a74-b640-df4c33369967">
</div>

   - 앞에서 언급한 C intrinsic에 해당하는 AVX512 명령어 4개(이 명령어들은 모두 v로 시작하며, 그 중 3개는 병렬 2개 정말도를 표시하는 pd로 끝나고, 하나는 병렬 단일 정밀도를 표시하는 sd로 끝남)를 볼 수 있음
   - 부동 소수점 명령어는 XMM 레지스터를 사용하는 스칼라 2배 정밀도(sd)가 ZMM 레지스터를 사용하는 병렬 2배 정밀도(pd)로 바뀜
   - 4번 행을 보면, A의 모든 원소가 B의 한 원소와 곱해짐 : 한 가지 해결책은 64비트 크기의 B 원소 8개를 복사해서 512비트의 ZMM 레지스터에 넣는 것이며, vbroadcastsd 명령어가 하는 일이 바로 이것
   - 또한, 이 버전은 6번 행에서 곱셈과 덧셈을 명령어 하라도 처리
   - AVX 버전은 기존보다 7.5배 빠름 : 서브워드 병렬성을 이용해 한 번에 8배 많은 연산을 수행하면서 기대할 수 있는 8배 성능 향상에 거의 근접
