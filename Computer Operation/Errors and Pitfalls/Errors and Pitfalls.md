-----
### 오류 및 함정
-----
1. 연산의 오류와 함정은 일반적으로 컴퓨터 연산의 제한된 정밀도와 실제 연산의 무제한적인 정밀도 차이에서 유래
2. 한 비트 왼쪽 자리이동 명령어가 2를 곱해준 것과 같은 결과를 보이듯이, 오른쪽 자리이동 멸령어는 2로 나누어준 것과 같은 결과를 나타내는가?
   - 이진수 x에서 xi는 x의 i번째 비트를 나타냄
<div align="center">
<img src="https://github.com/user-attachments/assets/48f7202b-4580-4650-9a38-9b93bb86003c">
</div>

   - x의 모든 비트를 오른쪽으로 n비트 자리 이동한 것은 $2^{n}$으로 나눈 것과 같은 것처럼 보임
   - 부호있는 정수의 경우, 예를 들어, -5를 4로 나눈다고 가정하면 몫은 -1이고, -5의 2의 보수법 표현은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/6a59a4e9-a59e-46ed-99be-66f14506d12b">
</div>

   - 이 오류대로라면, 2비트 오른쪽으로 자리이동한 것은 4($2^{2}$)으로 나눈 것과 같아야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/3073225f-3be8-446d-a278-ddb25dadb124">
</div>

   - 부호 비트가 0이 되므로, 이 결과는 확실히 잘못되었음을 알 수 있음
   - 오른쪽 자리이동에 의해 실제 만들어지는 수는 -1이 아닌 1,073,741,822
   - 해결책은 왼쪽을 0으로 채우는 대신 부호 비트를 채우는 산술적(Arithmetic) 오른쪽 자리이동 : -5을 2비트 산술적 오른쪽 자리이동
<div align="center">
<img src="https://github.com/user-attachments/assets/afb5cdd0-4d3f-426c-83e9-77f164c78eb0">
</div>

   - 결과는 -1 대신에 -2 (근사하지만 맞는 값이 아님)

3. 부동 소수점 덧셈은 결합 법칙이 성립하지 않는가?
   - 2의 보수 정수 덧셈을 연속적으로 할 때, 그 과정에서 오버플로우가 발생하더라도 결합 법칙은 성립
   - 그러나 부동 소수점 수는 실수의 근사치이고, 컴퓨터 연산도 제한된 정밀도를 갖기 때문에 부동 소수점 수에서는 결합 법칙이 성립하지 않음
   - 부동 소수점으로 표시할 수 있는 수의 범위는 매우 큼
   - 문제는 부호가 다른 2개의 매우 큰 수를 더한 후 여기에 어떤 작은 수를 더할 때 발생 : 예를 들어, c + (a + b) = (c + a) + b
     + c = -1.5 X $10^{38}$, a = 1.5 X $10^{38}, b = 1.0이고, 모두 단일 정밀도를 갖는 실수라고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/0ad8e2d4-0ca9-44b5-8d42-6ff8c0ef0b90">
</div>

   - 부동 소수점 수는 정밀도에 있어서 한계가 있고, 실제 결과의 근사값을 결과로 취함
   - 따라서 1.5 X $10^{38}$은 1.0보다 매우 커서 1.5 X $10^{38}$ + 1.0은 여전히 1.5 X $10^{38}$이 됨
   - 이것이 부동 소수점 덧셈 순서에 따라 a, b, c의 합이 0.0 또는 1.0이 나오는 이유
   - 따라서, c + (a + b) ≠ (c + a) + b : 부동 소수점 덧셈은 결합 법칙이 성립하지 않음

4. 정수 데이터 형에서 사용되는 병렬 수행 방식은 부동 소수점 데이터형에서도 똑같이 적용되는가?
   - 프로그램은 일반적으로 병렬로 실행되는 것을 작성하기 전에 순차적 실행 버전이 먼저 작성
   - 따라서, 두 버전이 같은 결과를 얻는지가 중요하며, 만약 같지 않으면 병렬 버전에 문제가 있다고 생각할 수 있음
   - 이 방식은 컴퓨터 연산이 순차적 실행에서 병렬 실행으로 바뀌어도 결과에 영향을 미치지 않음을 가정
     + 즉, 100만 개의 수를 더한다면 1개의 프로세서를 더한 것과 1000개의 프로세서를 사용한 것과 같은 결과를 얻게 될 것
     + 정수 덧셈은 결합 법칙이 성립하므로, 2의 보수 정수에 대해 이 가정은 항상 옳음
     + 그러나 부동 소수점 덧셈은 결합 법칙이 성립하지 않으므로 이 가정은 옳지 않음
   - 어떤 프로그램들이 같이 실행되느냐에 따라 병렬 컴퓨터의 운영체제 스케줄러가 프로세서 수를 다르게 할당하면 문제가 발생
     + 실행할 때마다 프로세서 수가 달라지면 부동 소수점 합 계산 순서가 달라져서, 같은 입력에 같은 프로그램이 수행되더라도 약간씩 다른 결과가 나올 수 있음
   - 이런 문제가 있으므로 부동 소수점 수를 다루는 병렬 코드를 작성할 때에는 병렬 프로그램의 결과가 순차 프로그램과 똑같지 않을 때, 이 값이 과연 믿을만한 것인지 검증이 필요
     + 이러한 문제를 다루는 분야가 수치 해석, LAPACK이나 SCALAPAK 같이 순차형과 병렬형이 모두 검증된 수치 라이브러리가 널리 쓰이는 이유 중 하나가 바로 이것

5. MIPS 명령어 addiu(add immediate unsigned)는 16비트의 수치값(immediate field)을 부호확장하여 사용하는가?
   - 이름은 unsigned이지만, 오버플로우에 대해 신경 쓰지 않을 때 부호있는 정수에 상수를 더하는 데 사용
   - MIPS는 수치값을 사용하는 뺄셈 명령어를 지원하지 않으며, addiu에 음수 상수도 사용할 수 있어야 하고, 음수 상수는 부호확장되어야 함
   - 따라서, MIPS 설계자들은 수치값 필드를 부호확장하는 것으로 결정
