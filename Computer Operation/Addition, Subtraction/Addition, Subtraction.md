-----
### 덧셈과 뺄셈
-----
1. 컴퓨터는 사람들이 생각하는 그대로 덧셈을 수행
   - 오른쪽에서 왼쪽으로 한 비트 씩 더하고, 이 때 생기는 올림수(Carry)는 바로 왼쪽 자리로 보냄
   - 즉, 바로 왼쪽 자리에 올림수를 보내줌
   - 뺄셈은 덧셈을 이용하며, 뺄 값의 부호를 바꾸어 더하기만 하면 됨

2. 예) 이진 덧셈과 뺄셈 : 7에 6을 이진법으로 더하고, 7에서 6을 이진법으로 빼기
   - 7 + 6 : 오른쪽 4비트만이 계산에 이용
<div align="center">
<img src="https://github.com/user-attachments/assets/281a8427-e637-4f6b-8ba7-9edc2c364c4a">
</div>

   - 합과 올림수
<div align="center">
<img src="https://github.com/user-attachments/assets/26994168-ac95-4868-83d3-f67bbb1a8e7b">
</div>

   - 7 - 6 : 바로 뺄셈 
<div align="center">
<img src="https://github.com/user-attachments/assets/df83341d-ef9b-4c38-865c-9f5299e18f25">
</div>

   - 7 - 6 : 2의 보수법 이용해 -6을 더하는 방법
<div align="center">
<img src="https://github.com/user-attachments/assets/4c5f96a9-a053-4a8b-8cc9-0704e1388166">
</div>

3. 연산 결과를 사용 가능한 하드웨어(이 경우 32비트 워드)로 표현할 수 없을 때 오버플로가 발생함
4. 덧셈에서의 오버플로우
   - 부호가 다른 피연산자를 더할 경우 오버플로우는 발생하지 않음
     + 계산 결과의 절대값이 두 피연산자 중 어느 하나보다 커질 수 없기 때문임
     + 예를 들어, -10 + 4 = -6인데, 피연산자는 이미 32비트로 표현된 값이고, 합이 어느 피연산자보다도 크지 않으므로 합 또한 32비트로 표현 가능
   - 따라서, 양수와 음수를 더할 때에는 오버플로우가 발생할 수 없음

5. 뺄셈의 오버플로우가 발생하지 않는 경우
   - 단, 뺄셈이므로 반대가 되며, 즉, 피연산자의 부호가 같을 경우에는 오버플로우가 발생할 수 없음
   - 두 번쨰 피여난자의 부호를 바꾸어 더하는 방식으로 뺄셈을 처리 : 예) c - a = c + (-a)를 생각
   - 그러므로 같은 부호의 수를 빼는 것은 부호가 다른 수를 더하는 것과 같음

6. 덧셈이나 뺄셈에서 실제로 오버플로우가 발생했을 때의 탐지 방법
   - 32비트의 수 2개를 더하거나 뺀 결과를 완벽하게 표현하기 위해 33비트가 필요할 경우가 존재
   - 워드 크기가 32비트이므로 33번째 비트는 표시할 수 없는데, 이렇게 되면 부호 비트가 결과의 부호가 아니라 크기를 나타내는 비트 중 최상의 비트값으로 결정
   - 딱 한 비트가 부족하므로, 틀릴 수 있는 것은 부호 비트
     + 따라서, 두 양수를 더한 값이 음수가 되면 오버플로우가 발생 (부호 비트로 올림수가 올라갔음을 의미)
     + 이와 반대로, 두 음수를 더했는데 합이 양수가 되는 경우에도 오버플로우가 발생

   - 오버플로우는 양수에서 음수를 뺀 결과가 음수가 되거나, 음수에서 양수를 뺀 결과 양수가 되는 경우에도 발생 가능
     + 이것은 부호 비트에서 빌림수(Borrow)가 발생했음을 의미

   - 오버플로우가 발생한 경우의 연산의 종류, 피연산자 및 그 결과
<div align="center">
<img src="https://github.com/user-attachments/assets/0b6c8420-d16c-4f00-93c7-b413067f4dd0">
</div>

7. 부호 없는 정수는 오버플로우가 무시되는 메모리 주소를 사용
   - 그러므로, 컴퓨터 설계자는 어떤 경우에는 오버플로우를 무시하고, 다른 경우에는 이를 인식하는 방법을 제공해야 함
   - MIPS에서는 두 가지 선택을 지원하기 위해 두 가지 산술 명령어 제공
     + Add(add), add immediate(addi)와 substract(sub) 명령어들은 오버플로우가 발생하면 예외(Exception) 발생
     + add unsigned(addu), add immediate unsigned(addiu), subtract unsigned(subu) 명령어들은 오버플로우가 발생해도 예외를 일으키지 않음

8. C 언어는 오버플로우를 무시하므로 MIPS C 컴파일러는 변수의 형에 관계 없이 언제나 부호없는 버전인 addu, addiu, subu 명령어 생성
   - 그러나 MIPS Fortan 컴파일러는 피연산자의 데이터형에 따라서 적절한 산술 명령어를 생성
   - 산술논리장치(ALU, Arithmetic Logic, Unit, ALU) : 덧셈과 뺄셈을 수행하는 하드웨어로, AND와 OR 같은 논리 연산 수행
  
9. addiu가 혼동을 일으키는 이유는 그 이름과 수치 필드 때문임 : u는 부호 없음을 나타내므로 덧셈에서 오버플로우가 발생할 수 없다는 것을 의미
    - 그러나 16비트 수치 필드는 addi, slti, sltiu와 같이 32비트로 부호확장
    - 따라서, 연산은 unsgined이더라도, 수치 필드에는 부호가 있음

10. 컴퓨터 설계자는 연산 오버플로우를 어떻게 처리할지 결정해야 함
    - C나 자바 같은 언어들은 정수 오버플로우를 무시하지만, Ada나 Fotran 같은 언어 프로그램에게는 알려지길 원함
    - 그러므로 프로그래머나 프로그래밍 환경은 오버플로우 발생 시 어떻게 할 것인지 결정해야 함
    - MIPS는 오버플로우를 탐지하면 예외(Exception)를 발생시킴
      + 예외 : 인터럽트라고도 하며, 프로그램 수행을 방해하는 게획되지 않은 사건을 의미 (예) 오버플로우가 탐지에 사용)
      + 예외를 인터럽트(프로세서 외부에서 발생하는 예외 (어떤 구조에서는 모든 예외를 인터럽트라고도 함))라고 부르는 컴퓨터도 많이 존재
      + 예외나 인터럽트는 본질적으로 계획되지 않은 프로시저 호출
      + 오버플로우가 발생한 명령어의 주소는 레지스터에 저장되고, 컴퓨터는 적절히 처리하기 위해 해당 루틴으로 처리
      + 인터럽트가 걸린 주소를 저장해서 해당 처리를 한 다음 프로그램을 실행할 수 있게 함
      + MIPS에서는 프로세서 외부로부터 발생하는 예외를 인터럽트(Interupt)라고 부름

   - MIPS에는 EPC(Exception Program Counter)라고 불리는 레지스터가 있어서 인터럽트가 걸린 명령어의 주소를 기억하는 데 사용
   - mfc0(Move From System Control) 명령어는 EPC를 범용 레지스터에 복사하여 MIPS 소프트웨어가 예외 처리 코드를 수행한 후 점프 레지스터 명령어를 통해 인터럽트가 걸린 명령어로 되돌아갈 수 있게 해줌

11. 요약
    - 수의 표현 방식과 무관하게 산술 연산 실행 결과 고정된 크기의 컴퓨터 워드로는 표현할 수 없는 큰 결과가 발생할 수 있음
    - 부호없는 수를 사용하는 경우 오버플로를 탐지하는 것은 쉽지만, 그러나 주소 연산 과정에서 발생하는 오버플로우는 검출하기를 원하지 않기 때문에 일반적으로 무시

12. 범용 마이크로프로세서에서 잘 볼 수 없는 기능 중 포화(Saturating) 연산이 존재
    - 오버플로우가 발생했을 때, 부호없는 산술 연산이 모듈로(Modulo) 연산을 하는 것과 달리, 포화는 가장 큰 양수나 음수를 결과값으로 함
    - 포화 연산은 미디어 연산에서 주로 사용
    - 표준 명령어 집합의 멀티미디어 확장은 포화산술 연산을 제공하는 경우가 많음

13. MIPS는 오버플로우가 발생시킬 수 있지만, 다른 많은 컴퓨터와 달리 오버플로우를 검사하기 위한 조건부 분기 명령은 제공하지 않음
    - 대신 MIPS에서 오버플로우를 검사혀려면 여러 명령어들을 사용해야 함
    - 부호있는 덧셈용 오버플로 검사 프로그램
<div align="center">
<img src="https://github.com/user-attachments/assets/e7ee682e-e4ee-4a09-8913-f908b4f37b1b">
</div>

   - 부호없는 덧셈($t0 = $t1 + $t2)의 오버플로우 검사
<div align="center">
<img src="https://github.com/user-attachments/assets/72acec1f-291e-4bd4-9126-c80ff45f60d8">
</div>

14. mfc0 명령어를 이용해 EPC를 레지스터에 복사하고 점프 레지스터 명령을 이용해 인터럽트가 발생된 코드로 되돌아갈 수 있음
    - 점프 레지스터 명령어를 사용하려면 EPC를 레지스터로 보내야 하는데, 이 때 점프 레지스터 명령어가 어떻게 인터럽트된 코드로 되돌아갈 수 있으며, 모든 레지스터들의 값을 어떻게 원상 복구하는가?
      + 모든 레지스터 값을 먼저 원상 복구하는 방법이 있는데, 이렇게 하면 점프 레지스터 명령어가 사용하도록 EPC에서 레지스터 복사한 복귀 주소를 훼손하게 됨
      + 복귀 주소를 가진 레지스터를 제외하고, 다른 레지스터들만 원상 복구하여 점프가 가능하게 하는 방법이 존재하지만, 이 방법은 예외가 생기면 프로그램 실행 도중 아무 댸나 레지스터 값 하나가 바뀔 수 있음

    - MIPS 프로그래머들은 $k0, $k1 레지스터를 운영체제 전용으로 지정
      + 이 레지스터들은 예외가 발생하더라도 원상복구 되지 않음
      + $at 레지스터는 어셈블러가 임시 레지스터로 사용하도록 MIPS 컴파일러가 사용하지 않는 것처럼, $k0, $k1 레지스터도 운영체제가 사용하도록 MIPS 컴파일러는 사용하지 않음
      + 예외 루틴은 이 레지스터들 중 하나에 복귀 주소를 넣고, 점프 레지스터 명령어를 이용해 되돌아감

15. 상위 비트들로 올라가는 올림수를 빨리 결정하면 덧셈의 속도를 향상시킬 수 있음
    - 이를 위해 올림수를 예측해서 최악의 경우 덧셈기 비트 수만큼이 아니라 덧셈기 비트 수의 $log_{2}$ 함수로 올림수를 계산할 수 있는 여러 가지 방법 제안
    - 이러한 예측 신호는 더 적은 수의 게이트를 통과하므로, 빠르기는 하지만 올림수를 예측하기 위해서 더 많은 게이트를 필요로 함
    - 가장 널리 사용되는 방식은 올림수 예견(Carry Lookahead)
