-----
### 곱셈
-----
1. 십진수의 곱셈 과정 : 0과 1로만 구성된 십진수의 곱셈 (1000 곱하기 1001)
<div align="center">
<img src="https://github.com/user-attachments/assets/7767e0a1-f1ea-4c0a-8704-f2cb58f51de7">
</div>

   - 첫 번째 피연산자 : 피승수(Multiplicand)
   - 두 번째 피연산자 : 승수(Multiplier)
   - 최종 결과 : 곱(Product)
   - 승수의 자릿수를 오른쪽에서 왼쪽으로 가면서 한 번에 하나씩 택해서 이를 피승수와 곱한 뒤, 그 곱셈의 결과를 직전의 곱보다 한 자리 왼쪽에 놓음

2. 최종 곱셈 결과의 자릿수가 피승수나 승수에 비교해서 상당히 큼
   - 사실 부호 비트를 무시한다면 n 비트의 피승수에 대한 m 비트 승수의 곱셈 결과는 n + m 비트의 길이
   - 결국 모든 가능한 곱을 표현하기 위해서는 n + m 비트가 필요
   - 따라서, 덧셈과 마찬가지로 곱셈에도 오버플로우 문제가 발생 : 두 32비트 수의 곱셈 결과가 32비트가 되기를 바라는 경우
     + 위 예에서의 십진수 자릿수를 0과 1만을 사용 : 단 두 가지 선택만 존재하므로 곱셈의 각 단계가 간단해짐
     + 승수의 자릿수가 1이면 피승수(1 X 피승수)를 해당 위치에 복사
     + 승수의 자릿수가 0이면 0(0 X 피승수)을 해당 위치에 복사

   - 이진수 곱셈은 실제로 0과 1만 사용하므로, 위의 두 가지 경우만 존재
   
