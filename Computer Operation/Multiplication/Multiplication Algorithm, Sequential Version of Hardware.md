-----
### 곱셈 알고리즘과 하드웨어의 순차적 버전
-----
1. 곱셈 하드웨어의 첫 번째 버전
<div align="center">
<img src="https://github.com/user-attachments/assets/32d355a1-a9d6-405a-bd27-d16a2a152967">
</div>

   - 승수는 32비트 승수 레지스터에 있고, 64비트 곱 레지스터는 0으로 초기화되어있다고 가정
   - 매 단계마다 피승수를 왼쪽으로 한 자리씩 이동시키고, 필요하면 중간 결과에 더해주는 식으로 계산되어야 함
   - 이렇게 32단계를 거치면, 32비트 피승수가 왼쪽으로 32번 이동하게 되므로, 64비트 피승수 레지스터가 필요
     + 이 레지스트의 오른쪽 32비트 피승수로, 왼쪽 절반은 0으로 초기화
     + 이 레지스터는 64비트 곱 레지스터에 축적되는 합과 피승수의 위치를 맞추기 위해 매 단계마다 1비트 왼쪽으로 자리 이동

2. 하드웨어를 이용하는 첫 번째 곱셈 알고리즘
   - 각 비트 연산에 필요한 기본 3단계
<div align="center">
<img src="https://github.com/user-attachments/assets/6d15bb28-17c9-422c-880e-0f187531d60d">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/6d8ae0a9-fbc8-4c3a-8417-5196a14d86ca">
</div>

   - 승수의 최하위 비트(Multiplier0)는 피승수를 곱 레지스터에 더할지 말지 결정
   - 단계 2에서 왼쪽으로 자리이동하는 것은 피연산자를 왼쪽으로 이동시키는 역할
   - 단계 3에서 오른쪽 자리 이동을 하는 이유는 다음 번 반복에서 검사할 승수의 다음 비트를 준비하기 위함
   - 각 단계에서 한 클럭 사이클씩 필요하다면, 이 알고리즘은 32비트 숫자 2개를 곱하는데 거의 100 클럭 사이클이 걸림

3. 곱셈과 같은 산술 연산의 상대적 중요도는 프로그램에 따라 다름
   - 그러나 덧셈과 뺄셈의 사용 빈도는 곱셈의 5배 ~ 100배 사이 어느 값이 될 것
   - 따라서, 많은 응용 프로그램에서 곱셈은 여러 클럭 사이클이 걸려도 성능에 별다른 영향을 끼치지 않음

4. 예) 곱셈 알고리즘 : 2 X 3을 계산하되, 공간 절약을 위해 4비트 수를 이용해 $0010_{2}$ X $0011_{2}$로 곱셈
   - 최종 결과는 0000 $0110_{2}$, 즉 6
  
5. 이 알고리즘과 하드웨어는 매 반복이 1 클럭 사이클만 걸리도록 쉽게 변경 가능
   - 연산을 병렬로 수행함으로써 속도 향상이 가능
   - 승수 비트가 1일 때, 피승수를 곱에 더하는 동안 승수와 피승수는 자리 이동
   - 이 때, 하드웨어가 검사하는 승수의 맨 오른쪽 비트가 자리 이동하기 전 값이고, 덧셈이 사용하는 값이 전 반복에서 자리이동된 피승수이면 문제가 없음
   - 덧셈기와 레지스터에서 사용되지 않는 부분이 있으므로, 덧셈기와 레지스터 폭을 절반으로 줄여 더욱 최적화 가능
   - 개선된 하드웨어
<div align="center">
<img src="https://github.com/user-attachments/assets/990633fd-33ca-46f1-bab2-6c8332f488db">
</div>

6. 산술 연산을 자리이동으로 대치시키는 것은 상수를 곱할 때도 적용 가능
   - 어떤 컴파일러들은 작은 상수와의 곱셈을 일련의 자리이동과 덧셈으로 대치
   - 이진수에서 한 비트 왼쪽 자리이동은 2배 큰 수를 나타내므로, 왼쪽으로 자리 이동하는 것은 2의 거듭제곱을 곱해주는 것과 같음
   - 거의 모든 모든 컴파일러가 2의 거듭제곱으로 곱하는 것을 왼쪽 자리이동으로 대치하는 강도 감소 최적화(Strength Reduction Optimization)를 수행
