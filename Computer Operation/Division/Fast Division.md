-----
### 더 빠른 나눗셈
-----
1. 하드웨어를 추가해서 나숫셈 성능을 향상시킬 수 있음
   - 곱셈의 속도를 빠르게 하기 위해 많은 수의 덧셈기를 사용했지만, 같은 방법으로는 나눗셈에는 적용 불가
   - 알고리즘이 다음 단계를 수행하기 전 뺄셈 결과의 부호를 알아야 하기 때문임
   - 반면 곱셈의 경우에 32개의 부분곱을 바로 계산 가능

2. 한꺼번에 몫을 두 비트 이상 만들 수 있는 기술이 존재 : SRT 나숫셈은 매 단계에서 동시에 여러 개의 몫 비트를 예측
   - 피제수와 나머지 상위 비트들을 이용해 표를 찾아 몫을 추측
   - 틀린 추측은 그 후의 단계에서 바로 잡음
   - 오늘날 널리 사용되는 방식은 한 번에 4비트를 추측하는 법
   - 핵심은 뺄 값을 추측하는 것인데, 이진 나눗셈의 경우 각 단계별 추측에 필요한 표를 참조하기 위해 나머지의 6비트의 제수의 4비트를 인덱스로 이용

3. MIPS에서 나눗셈
   - 똑같은 순차 하드웨어가 곱셈과 나눗셈 모두 이용 가능
   - 왼쪽이나 오른쪽으로 자리이동될 수 있는 64비트 레지스터와 덧셈과 뺄셈을 할 수 있는 32비트 ALU만 있으면 됨
   - MIPS는 32비트 Hi와 Lo 레지스터를 곱셈과 나눗셈용 64비트 레지스터로 사용
   - 나눗셈 명령이 완료된 뒤 Hi는 나머지를, Lo는 몫을 가짐
   - 부호있는 정수와 부호없는 정수 모두를 다루기 위해 MIPS에는 두 가지 명령어가 존재 : div(divide)와 divu(divide unsigned)
   - MIPS 어셈블러는 범용 레지스터 3개를 사용하는 나누기 의사명령어를 제공 : 이 의사명령어는 mflo나 mfhi 명령어를 사용해 원하는 결과를 범용 레지스터에 넣음

4. 요약
   - MIPS 같은 하드웨어가 곱셈과 나눗셈을 지원하므로 32비트 레지스터 한 쌍을 두어서 곱셈과 나눗셈 양쪽에 모두 사용
   - 여러 몫 비트를 동시에 예측하고, 예측이 틀리면 나중에 바로잡는 방법으로 나눗셈을 빠르게 할 수 있음
   - MIPS 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/6aa17951-77ee-4e83-9fbc-4582dc93bf0f">
</div>

5. MIPS 나눗셈 명령은 오버플로우를 무시하므로, 몫이 너무 커서 오버플로우가 발생하는 소프트웨어로 검사해야 함
   - 나눗셈은 오버플로우를 발생시킬 뿐만 아니라 0으로 나누기 같은 부적절한 연산도 초래

6. 나머지가 음수인 경우, 제수를 바로 더해서 원상 복귀하는 대신, 음수를 그대로 두고 다음 단계에서 자리이동된 나머지에 피저수를 더함
   + (r + d) X 2 - d = r X 2 + d X 2 - d = r X 2 + d이므로 가능
   + 이를 비복원(Non-restoring) 나눗셈 알고리즘이라 하며, 이 알고리즘은 각 단계마다 1사이클 씩 소요
   + 기존 알고리즘은 복원(Restoring) 나눗셈 알고리즘이라 부름
   + 뺄셈의 결과가 음수이면, 이를 저장하지 않는 조건부 실행(Non-performing) 나눗셈 알고리즘이라 부름 : 평균적으로 1/3만큼 적은 산술 연산 실시
