-----
### 나눗셈 알고리즘과 하드웨어
----
1. 나눗셈 하드웨어의 첫 번째 버전
<div align="center">
<img src="https://github.com/user-attachments/assets/aa4572d7-b6fa-47a4-b276-cc99d831bdeb">
</div>

   - 몫 레지스터 32비트를 0으로 초기화하고 시작
   - 이 알고리즘은 매번 반복할 때마다 제수를 오른쪽으로 한 비트 씩 자리이동해야 하므로 제수를 64비트 제수 레지스터의 왼쪽 절반에 넣고 시작
   - 그리고 피제수와 자리를 맞추기 위해 반복할 때마다, 오른쪽으로 한 비트씩 자리이동
   - 나머지 레지스터는 피제수로 초기화

2. 첫 번째 나눗셈 알고리즘의 3단계
<div align="center">
<img src="https://github.com/user-attachments/assets/9f36bcec-e34f-404d-9180-a1ee2f64b09a">
</div>

   - 단계 1에서 제수를 빼야 함 : set on less than 명령어에서 했던 비교와 같음
   - 만약 결과가 양수이면, 제수는 피제수와 같거나 더 작음 : 따라서 몫에 1을 넣음 (단계 2a)
   - 만약, 결과가 음수이면 제수를 나머지 레지스터에 다시 더함으로써 원래 값을 회복하고 몫에는 0을 넣음 (단계 2b)
   - 제수는 오른쪽으로 자리이동 되고, 다시 이 과정을 반복
   - 계산이 완료되면 나머지와 몫은 각각 해당 레지스터에 남게 됨

3. 예) 나눗셈 알고리즘 : 7 / 2를 계산하되, 공간 절약을 위해 4비트 알고리즘을 이용해 0000 $0111_{2}$ 나누기 $0010_{2}$로 할 것
   - 몫은 3이 되고, 나머지는 1이 됨
   - 나머지가 양수인지, 음수인지 알아보는 단계 2는 단순히 나머지 레지스터 부호 비트가 0인지 1인지 테스트하는 것
   - 이 알고리즘이 정확한 몫과 나머지를 얻기 위해서는 n + 1번의 단계를 거쳐야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/06dbf941-bc55-4b81-b697-afd75ecc89c2">
</div>

4. 이 알고리즘과 하드웨어는 훨씬 더 빠르고 싸게 개선될 수 있음
   - 뺼셈과 동시에 피연산자와 몫을 자리이동시키면 성능 향상이 가능
   - 레지스터와 덧셈기에 사용되지 않는 부분이 있음을 활용하여 덧셈기와 레지스터의 크기를 절반으로 줄일 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/6ecb278a-9d6b-4867-a44c-7c0a45ad162c">
</div>
