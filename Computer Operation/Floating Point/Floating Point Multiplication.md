-----
### 부동 소수점 곱셈
-----
1. 과학적 표기법의 십진수 곱셈 : 1.110 X $10^{10} X 9.200 X $10^{-5}$ (유효자리에는 네 자리, 지수에는 두 자리까지 저장할 수 있다고 가정)
   - 단계 1 : 덧셈과는 달리 피연산자들의 지수를 더하기만 하면 곱의 지수를 구할 수 있음
     + 새로운 지수 : 10 + -5 = 5
     + 똑같은 결과를 얻을 수 있는지 확인하기 위해, 바이어스된 지수로 계산 : 10 + 127 = 137, -5 + 127 = 122이므로, 따라서 새로운 지수는 137 + 122 = 259
     + 결과는 8비트 지수 부분에 들어가기에 너무 큼 : 문제는 바이어스로, 지수뿐만 아니라 바이어스도 더했기 때문임
     + 새로운 지수 = (10 + 127) + (-5 + 127) = (5 + 2 X 127) = 259
     + 따라서, 바이어스 된 수를 더할 때, 정확히 바이어스된 결과를 얻기 위해서는 결과에서 바이어스 값을 빼야함
     + 새로운 지수 = 137 + 122 - 127 = 259 - 127 = 132 = (5 + 127)
     + 최종 결과인 5인 계산했던 지수

   - 단계 2 : 유효자리의 곱셈
<div align="center">
<img src="https://github.com/user-attachments/assets/279dbcf3-733a-4027-9046-22e2d9c88553">
</div>

   - 각 피연산자의 소수점 오른쪽에는 세 자리의 수가 있음 : 따라서, 결과의 오른쪽으로부터 여섯 번째 자리에 소수점을 찍음
<div align="center">
<img src="https://github.com/user-attachments/assets/aaa6657c-a87d-4dc6-8668-9ff27c38af97">
</div>

   - 소수점 오른쪽에 세 자리만 있을 수 있다고 가정했으므로, 곱은 10.212 X $10^{5}$

   - 단계 3 : 이 곱은 정규화되어 있지 않으므로, 정규화
<div align="center">
<img src="https://github.com/user-attachments/assets/af3d1ff9-32e2-44e0-8edc-b26063054f8f">
</div>

   - 따라서 정규화된 형태로 맞추기 위해 곱셈 후의 결과를 오른쪽으로 한 자리 자리이동하고, 지수에 1을 더함
   - 이 시점에서 오버플로우와 언더플로우를 검사할 수 있음
   - 언더플로우는 두 피연산자가 모두 작을 때 발생할 수 있음 : 즉, 두 수가 매우 큰 음의 지수를 갖는 경우 발생

   - 단계 4 : 유효자리가 부호 부분을 제외하고 네 자리뿐이라고 가정했으므로, 계산된 결과를 자리맞춤하여야 함
     + 계산 결과를 유효 자리 네 자리로 자리 맞춤
<div align="center">
<img src="https://github.com/user-attachments/assets/df20685f-edb6-4b4e-bf06-0c8f68af0d78">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/1f516cb6-f81a-4737-acbe-ccf1acaacd8c">
</div>

   - 단계 5 : 결과의 부호는 피연산자의 부호에 따라 결정
     + 두 부호가 같으면 결과의 부호는 양수, 그렇지 않으면 결과는 음수
     + 최종 결과
<div align="center">
<img src="https://github.com/user-attachments/assets/fa8f4e7b-17bb-4278-8ebe-59d90d7e60a9">
</div>

   - 덧셈 알고리즘에서는 결과의 부호가 유효자리의 덧셈에 의해 결정
   - 그러나 곱셈에서 결과의 부호는 피연산자들의 부호에 의해 결정

2. 부동 소수점 곱셈
<div align="center">
<img src="https://github.com/user-attachments/assets/e3ba7be3-ec25-469f-a6ec-fa7efc730d92">
</div>

   - 먼저 바이어스된 지수를 서로 더한 후, 바이어스 하나를 빼서 곱의 새 지수를 구함
   - 다음 단계는 유효자리들끼리의 곱셈
   - 이어서 필요에 따라 정규화 과정 수행
   - 계산된 지수의 크기를 검사해서 오버플로우나 언더플로우가 발생했는지 확인한 후 결과를 자리맞춤
   - 만약, 자리 맞춤 과정이 추가 정규화를 필요로 하면 다시 한 번 지수의 크기를 검사
   - 마지막으로 피연산자들의 부호가 다르면(곱이 음수인 경우) 부호 비트를 1로 결정하며, 피연산자의 부호가 같으면(곱이 양수인 경우) 0으로 결정
