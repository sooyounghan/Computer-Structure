-----
### 부동 소수점 표현
-----
1. 부동 소수점을 표현하는 방식은 소수 부분(Fraction)의 크기와 지수(Exponent)의 타협이 중요
   - 소수 부분 : 소수 부분 필드에 있는 값으로 일반적으로 0과 1사이의 값, 맨티사(Mantissa)
   - 지수 : 부동 소수점 산술의 숫자 표현에서 지수 필드에 있는 값
   - 고정된 워드 크기를 사용하므로 하나를 증가시키면 다른 하나를 감소시켜야 함
   - 이 문제는 정밀도와 표현 범위 사이의 선택
     + 소수 부분 크기를 증가시키면, 소수 부분으로 표현할 수 있는 정밀도가 높아짐
     + 지수의 크기를 증가시키면, 표현할 수 있는 수의 범위가 늘어남

2. 부동 소수점 수의 크기는 보통 워드 크기의 배수
   - MIPS의 부동 소수점 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/6c644095-f7b2-42e9-b7e9-0988a3514c09">
</div>

   - 여기서 s는 부동 소수점 수의 부호(1이면 음수)
   - 지수는 8비트 지수 필드의 값(지수 부호 포함)
   - 소수 부분은 23비트 수
   - 이와 같은 표현 방식을 부호와 크기(Sign and Magnitude) 표현 방식 : 부호가 수의 나머지 부분과 떨어져 독립된 비트로 표현되기 떄문임

3. 일반적으로 부동 소수점 수는 다음과 같은 형태를 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/cc65e1cd-e21c-42a3-82ca-0202e1b657fc">
</div>

  - F는 소수 부분 값과 관련
  - E는 지수 부분의 값과 연관

4. 이렇게 선택된 지수와 소수 부분 크기는 MIPS 컴퓨터 산술이 매우 큰 표현범위를 갖게 함
   - 2.0 X $10^{-38}$만큼 작은 소수로부터, 2.0 X $10^{38}$만큼 큰 수가 컴퓨터에서 표현될 수 있음
   - 그러나 이는 무한대가 아니므로, 이보다 더 큰 계산 결과가 나올 수 있음
   - 그러므로 오버플로우 예외는 정수 연산에서 뿐만 아니라 부동 소수점 연산에서도 발생할 수 있음
     + 오버플로우(Overflow) : 양수값을 갖는 지수가 지수 부분에 표현될 수 없을 만큼 큰 상황, 즉, 지수가 너무 커서 지수 필드에 들어갈 수 없는 경우
   - 또한, 계산 결과가 너무 작아서 표현할 수 없는 경우에는 언더플로우(Underflow)
     + 언더플로우(Underflow) : 음수값을 갖는 지수가 지수 부분에 표현될 수 없을 만큼 큰 상황, 즉, 음수 지수의 절대값이 너무 커서 지수 부분에 표현될 수 없는 경우

5. 언더플로우와 오버플로우의 발생 가능성을 줄이는 방법 : 지수 부분이 더 큰 다른 표현 방식으로 사용 가능
   - C언어에서는 이를 double이라고 부름
   - double 형식을 갖는 수의 연산을 2배 정밀도(Double Precision) 부동 소수점 연산이라고 부름
   - 위 표현 형식은 단일 정밀도(Single Precision) 부동 소수점이라고 함
   - 2배 정밀도 부동 소수점 수를 표현하려면 MIPS 워드 2개가 필요 : s는 여전히 수의 부호, 지수는 11비트의 지수 필드 값, 소수 부분의 크기는 52비트
<div align="center">
<img src="https://github.com/user-attachments/assets/2c4b7f3d-5b66-4877-a500-da8e933eb678">
</div>

   - MIPS 2배 정밀도 표현법은 2.0 X $10^{-308}$부터 2.0 X $10^{308}$까지의 수 표현 가능
   - 이와 같은 2배 정밀도 연산은 지수의 범위를 크게 해주기도 하지만, 주된 장점은 훨씬 더 큰 유효자리를 제공하여 정밀도를 높임
   - 이들은 IEEE 754 부동 소수점 표준으로, 1980년 이후 만들어진 컴퓨터는 거의 모두 이 표준을 사용 : 부동 소수점 프로그램의 이식을 매우 쉽게 하였고, 컴퓨터 연산의 질을 크게 향상

6. 유효자리 부분에 더 많은 수를 담기 위해서 IEEE 754 표준은 정규화된 이진수의 가장 앞쪽 1비트를 생략하고 표현하지 않음
   - 따라서, 실제적으로 유효자리는 단일 정밀도 표현에서는 24비트의 길이(숨겨진 1과 23비트 소수 부분), 2배 정밀도에서는 53비트(1 + 52비트)의 길이를 가짐
   - 표현에 정확을 가하기 위해, 유효 자리(Significand)라는 용어는 숨겨진 1을 포함하는 24 또는 53비트를 나타내는데 사용
   - 23 또는 52비트를 나타낼 때는 소수 부분이라는 용어 사용
   - 숫자 0.0은 선행하는 1이 없으므로, 이를 구별하기 위해 예약된 지수값 0을 사용하며, 이 경우 하드웨어는 소수 부분 앞에 1을 붙이지 않음
   - 따라서, 00...00은 0을 나타내며, 0을 제외한 나머지 수는 숨겨진 1을 덧 붙이면 다음과 같은 값
<div align="center">
<img src="https://github.com/user-attachments/assets/7599963f-5fc8-478a-8874-5e1d151e06fc">
</div>

   - 여기서 소수 부분의 비트들은 0과 1 사이의 수를 나타내고, E는 지수 부분의 값을 표시
   - 유효 자리의 비트를 왼쪽에서 오른쪽으로 s1, s2, s3, ... 와 같이 번호를 매기면 다음과 같은 값
<div align="center">
<img src="https://github.com/user-attachments/assets/c055570d-fb0d-4924-99a4-5d81e701a07f">
</div>

7. IEEE 754 부동 소수점 수의 인코딩 방법
<div align="center">
<img src="https://github.com/user-attachments/assets/86f45d34-cd1f-40cc-bbb0-bb0fb2e0b9cf">
</div>

   - IEEE 754의 또 다른 특징은 비정상적 사건을 표현하는 특수 심벌이 존재
   - 예를 들어, 0으로 나누기에 대해 인터럽트를 거는 대신 소프트웨어가 +∞ 이나 -∞를 표시하는 비트열을 결과값에 정할 수 있음
   - 표현 가능한 가장 큰 지수값을 특수 심벌용으로 예약해 놓았으며, 이 결과를 프린트하면 프로그램은 무한대 기호를 프린트할 것 (무한대의 목적 : 실수의 위상적 닫힘(Topological Closure)을 형성하기 위함)
   - IEEE 754는 0 나누기 0이나, 무한대 빼기 무한대와 같은 유효하지 않은 연산의 결과를 위한 심벌도 가지고 있음 : 이 심벌은 숫자가 아님(Not a Number)를 표현하는 NaN (NaN을 사용하면 테스트나 결정을 나중에 편할 때로 미룰 수 있음)

8. IEEE 754 설계자들은 정수 비교에 의해 쉽겍 정렬(Sorting) 될 수 있는 부동 소수점 표현을 원했음
   - 이런 이유로, less than / grater than 또는 equal to 0 테스트를 빠르게 할 수 있도록 부호 비트가 최상위 비트에 놓이게 됨 (이 표현 방식은 기본적으로 2의 보수법 표현 방식이 아닌 부호와 크기의 표현 방식이므로 단순한 정수 정렬보다 조금 더 복잡)
   - 지수를 유효자리 앞에 두면, 부호가 같은 수를 비교할 때, 지수가 큰 수가 지수가 작은 수보다 더 큰 정수처럼 보이는데, 이것 또한 부동 소수점 수를 정수 비교 명령어로 정렬하는 일을 쉽게 해줌
   - 하지만, 음수 지수는 숫자 정렬을 어렵게 만듬
     + 만약 음수 지수를 나타내기 위해 2의 보수법이나 지수의 최상위 비트를 1로 만드는 어떤 표현법을 사용한다면, 지수가 음수이면 매우 큰 수처럼 보일 것
     + 예) $1.0_{2}$ X $2^{-1}$ : 유효자리 맨 앞의 1은 소수 부분에 나타나있지 않고 숨겨져 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/5734a0f0-24cc-47a3-8352-5e4df5d78ef1">
</div>

   - 예) $1.0_{2}$ X $2^{+1}$은 이 숫자보다 작은 이진수처럼 보일 것
<div align="center">
<img src="https://github.com/user-attachments/assets/3c8e76f0-b669-4c17-8c4c-e21b3033ffb8">
</div>

   - 이상적인 표기법은 가장 음수인 지수를 $00..00_{2}$로, 가장 양수인 지수를 $11..11_{2}$로 표현하는 것 : 이러한 방식을 바이어스된 표현법(Biased Notation)
      + 여기서 바이어스는 실제 값을 구하기 위해 부호없이 표현된 수에서 빼야 하는 상수
      + IEE 754의 단일 정밀도 표현 방식에서는 바이어스 값 127을 사용
      + 따라서, -1은  -1 + 127 = 126 = 0111 $1110_{2}$라는 비트 패턴으로 표현
      + +1은, 1 + 127 = 128 = 1000 $0000_{2}$으로 표현
      + 2배 정밀도를 위한 지수의 바이어스는 1023이며, 이는 부동 소수점으로 표현된 값이 실제로 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/fc9e15f6-d095-44fb-b2db-eb14a860d2c3">
</div>

   - 단일 정밀도에서 표현할 수 있는 가장 작은 수
<div align="center">
<img src="https://github.com/user-attachments/assets/b2e298a4-e90a-4f42-b1e8-554e7a5f1e2e">
</div>

   - 가장 큰 수
<div align="center">
<img src="https://github.com/user-attachments/assets/752c448a-ba39-4b76-aa55-e517192798d1">
</div>
