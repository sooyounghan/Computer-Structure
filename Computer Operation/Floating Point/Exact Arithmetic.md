-----
### 정확한 산술
-----
1. 가장 작은 수와 가장 큰 수 사이의 모든 수를 정학하게 나타낼 수 있는 정수와 달리, 부동 소수점 숫자는 실제로 나타낼 수 없는 수의 근사값인 것이 보통
   - 그 이유는 0과 1사이에만도 무수히 많으 실수들이 존재하는데, 2배 정밀도 부동 소수점 표현 방버을 사용하더라도 나타낼 수 있는 값은 $2^{53}$개에 불과하기 때문임
   - 따라서, 최선의 방법은 실제의 수에 가장 근접한 부동 소수점 표현을 구하는 것
   - 이를 위해 IEEE 754는 프로그래머가 원하는 근사 방법을 선택할 수 있도록 여러가지 맞춤 방법 제공

2. 정확한 자리맞춤을 위해서는 계산할 때 하드웨어에 추가 비트가 포함되어야 함
   - 만약, 모든 중간 결과가 원래 데이터 비트 수 만큼 보존되고 나머지는 다 잘려 나간다면, 자리맞춤 할 기회는 아예 오지 않을 것
   - 그러므로 IEEE 754는 계산하는 동안 오른편에 항상 2개의 추가 비트 유지
     + 보호 비트(Guard Bit) : 부동 소수점 계산 도중 오른쪽에 유지되는 두 추가 비트 중 첫 번째 비트로, 자리맞춤의 정확도를 개선하기 위해 사용
     + 자리맞춤 비트(Round Bit) : 부동 소수점 연산 중간 결과가 부동 소수점 형식에 일치하도록 하는 방법으로, 부동 소수점 형식으로 나타낼 수 있는 가장 가까운 수를 찾아내는 것이 목적

3. 보호 자릿수를 사용한 자리맞춤
   - 유효자리가 십진수 세 자리라고 가정하고, 2.34 X $10^{2}$에 2.56 X $10^{0}$을 더하고, 유효자리 숫자 세 자리를 사용하여 가장 가까운 십진수로 자리맞춤할 것
   - 먼저 지수를 맞추기 위해 작은 수를 오른쪽으로 자리 이동 : 2.56 X $10^{0}$는 0.0256 X $10^{2}$
     + 보호 자리 및 자리 맞춤 자리가 존재하므로 지수를 정렬할 때 2개의 최하위 자리를 표현할 수 있음
     + 보호 자리는 5가 되고, 자리맞춤 자리는 6이 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/f52014db-9f7f-4729-8eba-e3fe63b65727">
</div>

   - 따라서 결과는 2.3656 X $10^{2}$
     + 자리맞춤 할 두 자리를 가지고 있으므로 0부터 49는 버리고, 51부터 99는 올림
     + 50은 타이브레이커(Tiebreaker)이므로 50%는 버리고, 50%는 올림
     + 세 자리 유효 숫자로 자리맞춤을 하면 결과는 2.37 X $10^{2}$

   - 보호 자리와 자리 맞춤 자리가 없으면, 두 자리를 버리고 덧셈을 해야함
<div align="center">
<img src="https://github.com/user-attachments/assets/a4eb29f8-4b93-4a27-9c8a-f8f85194d0cd">
</div>

   - 따라서 합은 2.36 X $10^{2}$
   - 앞서 계산한 결과에 비해 가장 오른쪽 자리 수가 1이 작게 됨

4. 자리맞춤 시 최악의 경우에는 실제 값이 부동 소수점 표현의 중간이 되는 경우
   - 부동 소수점에서 정확도는 유효자리의 최하위 비트 중 오류가 발생한 것이 몇 비트인가에 따라 결정
   - 이 척도를 ULP(Units in the Last Place) : 실제 수와 표현 가능한 수의 최하의 유효자리 비트들 중에 서로 다른 비트의 개수
     + 어떤 수의 최하의 유효자리 비트 중 2개에 오류가 있을 때 ulp가 2라고 함
     + 오버플로우, 언더플로우 또는 유효하지 않은 연산의 예외가 없는 한, IEEE 754는 컴퓨터가 1/2 ulp 이내의 수를 사용함을 보장

5. 덧셈은 실제로 추가 자릿수가 하나만 있어도 되지만, 곱셈할 때는 2개가 다 필요
   - 이진 곱셈 결과는 맨 앞에 0이 하나 있을 수 있는데, 이 때, 정규화 과정에서 곱을 한 비트 왼쪽으로 자리이동 해야함
   - 이 자리 이동 시에 보호 비트가 곱의 최하위 비트로 들어가고, 자리맞춤 비트는 곱을 정확히 자리맞춤 할 수 있도록 도와줌
   - IEEE 754에는 네 가지 자리맞춤 모드가 존재
     + 항상 자리올림(+∞ 방향), 항상 자리내림(-∞ 방향), 잘라내기(Truncate), 그리고 가장 가까운 짝수로의 자리맞춤(Round to Nearest Even)
     + 마지막 모드는 결과값이 정확히 두 값의 가운데에 위치할 때 어떻게 할 것인가를 결정
     + 더 공평한 방법은 절반은 자리올림하고, 나머지 절반은 자리내림 하는 것
     + IEEE 754 표준은 계산된 결과값이 두 값의 가운데에 위치할 때, 최하위 비트가 홀수이면 더하기 1을 하고, 짝수이면 잘라내라고 규정
     + 정가운데 일 때 이 방법은 항상 최하위 비트를 0으로 만들어주며, 이 방식이 가장 가까운 짝수로의 자리맞춤 (자바에서는 이 방식만 지원되며, 이 방식이 가장 널리 사용)

   - 자리맞춤 비트들을 추가로 사용하는 목적은 무한한 정밀도로 중간 계산 결과를 구한 후 자리맞춤 한 것과 최종 결과를 갖게 하기 위함
   - 이 목적을 달성하고 가장 가까운 짝수로의 자리맞춤을 하기 위해서는 보호 비트와 자리맞춤 비트 외 세 번째 비트가 필요
   - 이 비트는 자리맞춤 비트 오른쪽에 0이 아닌 비트들이 하나라도 존재하면 1이 되는데, 이 비트는 점착 비트(Sticky Bit)라고 불리며, 자리맞춤 시 0.50..00과 0.50..01을 구별할 수 있게 해줌
     + 점착 비트 : 보호 비트와 자리이동 비트와 함께 자리맞춤에 사용되는 비트로서, 자리맞춤 비트의 오른쪽에 0이 아닌 비트가 존재할 때 1이 됨
     + 예를 들면, 점착 비트는 덧셈할 때 지수를 같게 만들기 위해 더 작은 수를 오른쪽으로 자리 이동하면서 1이 될 수 있음
     + 5.01 X $10^{-1}$에 2.34 X $10^{2}$을 더한다고 가정할 때, 보호 비트와 자리맞춤 비트를 사용하는 경우에도 실제로는 0.0050에 2.34를 더하게 되고, 결과값은 2.3450이 됨
     + 오른쪽에 0이 아닌 비트가 있었기 때문에 점착 비트는 1이 됨
     + 점착 비트 없이는 결과값이 2.345000..00이 되어 가장 가까운 짝수로 자리맞춤을 하면 2.34
     + 점착 비트를 사용하면 2.345000..00보다 크단느 것을 알 수 있으므로 2.35

6. PowerPC, AMD SSE5, Intel AVX 구조에는 3개의 레지스터 a = a + (b X c) 연산을 하는 곱셈 후 덧셈(Multiply and Add) 명령어가 존재
   - 이 연산이 자주 사용되는 경우, 이 명령어를 사용하여 부동 소수점 성능을 높일 수 있음
   - 또 중요한 점은, 별도 명령어로 곱하고 더하면 자리맞춤을 2번 해야 하지만, 이 명령어는 덧셈 뒤 한 번만 자리 맞춤을 수행한다는 것
   - 자리맞춤을 한 번만 하면 정밀도는 높아짐
   - 이와 같이 자리맞춤을 한 번만 하는 연산을 곱셈-덧셈 융합(Fused Multiply Add)라고 부름
