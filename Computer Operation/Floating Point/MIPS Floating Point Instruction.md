-----
### MIPS의 부동 소수점 명령어
-----
1. MIPS는 다음과 같은 명령어를 사용하여 IEEE 754 단일 정밀도 및 2배 정밀도 표현 형식 지원
   - 부동 소수점 단일 정밀도 덧셈(add.s)과 2배 정밀도 덧셈(add.d)
   - 부동 소수점 단일 정밀도 뺄셈(sub.s)과 2배 정밀도 뺄셈(sub.d)
   - 부동 소수점 단일 정밀도 곱셈(mul.s)과 2배 정밀도 곱셈(mul.d)
   - 부동 소수점 단일 정밀도 나눗셈(div.s)과 2배 정밀도 나눗셈(div.d)
   - 부동 소수점 단일 정밀도 비교(c.x.s)와 2배 정밀도 비교(c.x.d)
     + x는 equal(eq), not equal(neq), less than(lt), less than or equal(le), greater than(gt) 또는 grater than or equal(ge)이 될 수 있음

2. 부동 소수점 비교는 비교 조건에 따라 cond 비트를 참(true) 또는 거짓(false)으로 만듬
   - 분기 명령은 cond 값에 따라서 분기할 것인지, 아닌지를 결정
  
3. MIPS 설계자들은 $f0, $f1, $f2, ... 라고 불리는 부동 소수점 레지스터를 별도로 두기로 함
   - 이들은 단일 정밀도와 2배 정밀도에 모두 사용
   - 이에 따라, 설계자들은 부동 소수점 레지스터를 위한 적재 및 저장 명령어 lwc1과 swc1을 포함시킴
   - 부동 소수점 수의 적재와 저장 명령어의 주소 계산에 사용되는 베이스 레지스터로는 정수 레지스터가 사용
   - 2개의 단일 정밀도 수를 메모리에서 읽어와서 더한 다음 합을 다시 저장하는 MIPS 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/7f56afe0-8f5f-4025-80c9-237afdb79e9f">
</div>

   - 2배 정밀도 레지스터 하나가 사실은 단일 정밀도 레지스터 한 쌍을 합쳐서 사용하는 것이고, 이 때 짝수 번 레지스터 번호를 레지스터 이름으로 사용
   - 따라서, 단일 정밀도 레지스터 $f2와 $f3 한 쌍은 2배 정밀도 레지스터 $f2가 됨

4. 부동 소수점 MIPS 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/781871be-f6d0-4aee-8af4-887729f2d5fe">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/af951dc9-0301-4876-836c-239237fef9f7">
</div>

5. 컴퓨터 설계자가 부동 소수점 연산 지원과 관련하여 부딪히는 문제 중 하나는 정수 명령어가 사용하는 레지스터를 같이 사용할 것인지 아니면 부동 소수점 전용 특별 레지스터를 추가할 것인지 하는 것
   - 프로그램이 정수 연산을 할 때와 부동 소수점 연산을 할 때 보통 다른 데이터를 사용하므로, 레지스터를 분리하면 프로그램 수행에 필요한 명령어 수가 약간 증가
   - 정작 크게 영향을 받는 부분은 부동 소수점 레지스터와 메모리 사이 데이터 이동에 사용할 별도 데이터 전송 명령어들을 만들어야 한다는 것
   - 별도의 부동 소수점 레지스터 사용의 장점
     + 첫째, 명령어 형식의 비트 수를 늘리지 않고도 2배나 많은 레지스터를 사용할 수 있음
     + 둘째, 정수 레지스터와 부동 소수점 레지스터가 따로 있으니 레지스터 대역폭이 2배로 늘어남
     + 셋째, 부동 소수점에 맞게 레지스터를 특화시킬 수 있음 (예) 어떤 컴퓨터는 레지스터에 있는 다양한 크기의 피연산자들을 한 가지 내부 형식으로 변환)

6. 예) 부동 소수점 C 프로그램을 MIPS 어셈블리 코드로 컴파일 : 화씨 온도를 섭씨 온도로 변환
<div align="center">
<img src="https://github.com/user-attachments/assets/b4d37f07-a4ff-4fb1-b47c-25d2e8e433ba">
</div>

   - 부동 소수점 인수 fahr은 $f12에 넣어서 전달하고, 결과를 $f0에 저장한다고 가정 (정수 레지스터 $0와 달리 부동 소수점 레지스터 $f0는 임의의 값을 가질 수 있음)
   - 컴파일러가 전역 포인터 $gp에 쉽게 접근할 수 있는 거리에 부동 소수점 상수 3개를 넣는다고 가정 : 처음 두 명령어는 상수 5.0과 9.0을 부동 소수점 레지스터에 적재
<div align="center">
<img src="https://github.com/user-attachments/assets/c8a9200c-c876-44be-8373-305fc0a94845">
</div>

   - 5.0 / 9.0값을 얻기 위해 이 둘을 나눔
<div align="center">
<img src="https://github.com/user-attachments/assets/aec6ec0f-4567-4e88-aaee-0a262d415bd4">
</div>

   - 컴파일할 때 5.0을 9.0으로 나누어서 상수 5.0 / 9.0 하나만 메모리에 저장하는 컴파일러들이 많은데, 이렇게 하면 실행할 때 나눗셈을 할 필요가 없음
   - 상수 32.0을 적재하고 이것을 fahr($f12)에서 뺌
<div align="center">
<img src="https://github.com/user-attachments/assets/1bad9c89-f0f2-4de4-ba47-6899b13672d6">
</div>

   - 마지막으로 2개의 중간 결과를 곱해 $f0에 반환값으로 저장하고 복귀
<div align="center">
<img src="https://github.com/user-attachments/assets/87aa8beb-e000-4118-8af1-c566ec2b620a">
</div>

7. 예) 2차원 배열을 사용하는 부동 소수점 C 프로시저를 MIPS 어셈블리 코드로 컴파일
   - 대부분 부동 소수점 계산은 2배 정밀도 연산 사용
   - 행렬 곱셈 C = C + A * B를 게산
   - A, B, C 모두 32차 정방행렬(32 X 32)이라고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/6ea914c4-6b37-47f3-a317-98e6067fcc12">
</div>

   - 배열의 시작 주소는 매개변수이므로, $a0, $a1, $a2에 존재
   - 정수 변수는 $s1, s2에 있다고 가정
   - c[i][j]는 가장 안쪽 순환문에서 사용
     + 이 순환문의 인덱스는 k이므로 c[j][j]에 영향을 미치지 않음
     + 따라서, 순환문을 반복할 때마다 c[i][j]를 적재하고 저장할 필요가 없음
     + 대신 컴파일러는 순환문 외부에서 c[i][j]를 레지스터에 적재하고, 같은 레지스터 a[i][k] X b[k][j]의 합을 축적
     + 그러다가 가장 안쪽 순환문이 끝나면 그 합을 c[i][j]에 저장

   - 코드를 간단하게 하기 위해 어셈블리 언어 의사명령어 li(상수를 레지스터에 적재시키는 명령어), l.d와 s.d(어셈블러에 의해 한 쌍의 데이터 전송 명령어 lwc1와 swc1로 변환)를 사용
   - 프로시저 본체는 순환 종료값인 32를 임시 레지스터에 저장하고 for 순환 변수 3개를 초기화하면서 시작
<div align="center">
<img src="https://github.com/user-attachments/assets/117939a6-a977-46dd-ad34-c48771d545ac">
</div>

   - c[i][j]의 주소를 계산하려면 32 X 32 2차원 배열이 메모리에 어떻게 저장되는지 알아야 함
     + 이 배열은 32개의 원소를 갖는 1차원 배열 32개와 똑같이 생각할 수 있음
     + 따라서, 첫 번째 단계는 원하는 원소를 찾기 위해 i개의 1차원 배열, 즉, 열들을 건너뛰는 것
     + 이를 위해 행렬의 첫 번째 인덱스를 행의 크기인 32로 곱함, 32는 2의 거듭제곱이므로 곱셈 대신 자리이동 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/ff303426-3287-4108-8347-e603384db9c2">
</div>

   - 원하는 j번째 원소를 선택하기 위해 두 번째 인덱스를 더함
<div align="center">
<img src="https://github.com/user-attachments/assets/9b5a38d4-8c20-4e83-bd8b-1cb971c69940">
</div>

   - 이 합을 바이트 인덱스로 바꾸기 위해 행렬 원소의 바이트 크기를 곱함
     + 2배 정밀도 원소 하나는 8바이트씩 차지하므로 8을 곱해야 하는데, 8은 2의 거듭제곱이므로, 곱하기 대신 왼쪽으로 세 자리 자리이동

   - 다음은 이 합을 c의 시작 주소에 더해 c[i][j]의 주소를 구하고, 2배 정밀도 c[i][j]를 $f4에 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/beb1cc1d-4691-4b2f-ae2c-8d8edd791e96">
</div>

   - 주소를 계산하고 2배 정밀도 수 b[k][j]를 레지스터에 넣는 5개 명령어
<div align="center">
<img src="https://github.com/user-attachments/assets/8d345761-6f89-4946-8677-f41380a17882">
</div>

   - 마찬가지로 다음 5개의 명령어는 앞의 5개의 명령어와 같음 : 주소를 계산하고 2배 정밀도 수인 a[i][k]를 적재
<div align="center">
<img src="https://github.com/user-attachments/assets/675e9839-0c34-4ec5-ad06-be5b9e1bc081">
</div>

   - 모든 데이터를 적재했으므로, 부동 소수점 연산 가능
   - 레지스터 $f18와 $f16에 이는 a와 b의 원소를 곱하고 합을 $f4에 축적
<div align="center">
<img src="https://github.com/user-attachments/assets/03fce103-3f14-4939-8760-8593c3699d15">
</div>

   - 마지막 블록은 인덱스 k를 증가시키고, 인덱스 32가 아니면 순환문의 처음으로 다시 돌아감
   - 만약 32이면, 즉, 가장 안쪽 순환문의 끝이면 $f4에 축적된 합을 c[i][j]에 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/b4985e47-cd8d-4a31-a0e7-3036400b223a">
</div>

   - 마찬가지로, 마지막 4개의 명령어들은 중간과 가장 바깥쪽 순환의 인덱스 변수를 증가
   - 인덱가 32가 아니면 순환문으로 되돌아가고, 32이면 빠져나옴
<div align="center">
<img src="https://github.com/user-attachments/assets/c4498934-b9cc-4ad6-9e8b-bbf3b33e3877">
</div>

8. 행-우선 순서(Row-Major Order) 배열 형식
   - C를 비롯한 많은 프로그래밍 언어에서 사용
   - Fortran은 배열이 한 열씩 저장되는 열-우선 순서(Column-Major Order) 사용

9. 32개 MIPS 부동 소수점 레지스터 ($f0, $f1, ..., $f30)의 16개만이 2배 정밀도 연산에 사용 가능
    - 2배 정밀도 연산은 단일 정밀도 레지스터들을 쌍으로 묶어 사용
    - 홀수 번호 레지스터들은 64비트 부동 소수점 수의 오른쪽 절반을 적재하고 저장하는 데 사용
    - MIPS-32는 명령어 집합에 l.d와 s.d를 추가
    - 또 모든 부동 소수점 명령어의 '단일 정밀도 쌍(Paired Single)' 버전 추가
    - 이 버전 명령어의 하나는 64비트 레지스터에 있는 32비트 피연산자에 대해 부동 소수점 연산 2개를 병렬로 수행
    - 예) add.ps $f0, $f2, $f4는 add.s $f0, $f2, $f4 add.s $f1, $f3, $f5 두 명령어와 같음

10. 정수 레지스터와 부동 소수점 레지스터를 따로 두는 이유
    - 1980년대 마이크로프로세서는 한 칩에 부동 소수점 유닛과 정수 유닛을 함께 넣을 수 있을 만큼 트랜지스터가 많지 않았음
    - 따라서, 부동 소수점 레지스터를 포함하느 부동 소수점 유닛은 독립적인 2차 칩 형태의 선택 사양
    - 이런 선택 사양의 가속 칩을 코프로세서(Co-Processor)라고 부름
    - MIPS 부동 소수점 적재 명령어의 이름이 lwc1인 것은 부동 소수점 유닛인 코프로세서 1에 한 워드를 적재하라는 뜻
    - 1990년대 초 이후 마이크로프로세서 부동 소수점 유닛이 같은 칩에 집적되게 됨

11. 나눗셈 속도 개선은 곱셈 속도 개선보다 어려움
    - SRT 외에 나눗셈 시간을 단축하는 또 다른 방법 : 곱셈기의 속도가 빨라진 것을 이용
    - Newton의 반복법(Newton's Iteration) : 함수가 0이 되는 값을 찾는 것인데, 이를 이용해 (1 / 제수)을 계산한 후 이 값을 피제수와 곱하는 것
      + 반복법은 여분의 비트를 많이 계산하지 않고는 적절한 자리맞춤을 할 수 없다는 단점이 존재

12. 자바는 자바 부동 소수점 데이터형과 연산의 정의에 IEEE 754 용어로 그대로 받아들임
    - 그러나 다차원배열을 사용하는 자바에서는 바로 지원되지 않음
      + 자바는 배열의 배열을 허용함
      + 그러나 각 배열은 C의 다차원 배열과 달리, 길이가 각각 다를 수 있음
    - 따라서, 한 행의 접근이 끝나면 새로운 길이를 계산하는 코드도 포함되어야 함
    - 또 객체 참조가 널(Null)이 아닌 것도 확인해야 함
