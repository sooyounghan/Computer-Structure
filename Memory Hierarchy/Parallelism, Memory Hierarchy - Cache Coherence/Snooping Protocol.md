-----
### 스누핑 프로토콜
-----
1. 일관성을 유지하는 한 가지 방법은 프로세서가 데이터 항목에 배타적 접근을 확보한 후에 데이터를 쓰는 것
   - 이러한 형태의 프로토콜은 쓰기 작업 시 다른 캐시에 있는 복사본들을 무효화하기 떄문에 쓰기 무효화 프로토콜(Write Invalidate Protocol)이라고 부름
   - 배타적 접근은 다른 캐시의 복사본들을 모두 무효화하기 떄문에 쓰기 작업이 일어날 때까지 읽기 또는 쓰기가 가능한 다른 복사본이 없다는 것을 보장해줌

2. 나중 쓰기 캐시에서 스누핑 버스(Snooping Bus)를 위한 무효화 프로토콜이 어떻게 동작하는지 보여주는 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/1efe214c-2c39-4b8a-97dc-3fb8d19c6081">
</div>

   - 이 프로토콜이 어떻게 일관성을 보장해주는지 보기 위해서, 한 프로세서의 쓰기 작업 후 다른 프로세서들이 갖고 있는 복사본들은 모두 무효화되어야 함
   - 그러므로 읽기 작업이 발생하면 캐시 실패가 되어 캐시가 데이터의 새로운 복사본을 메모리에서 가져와야함
   - 쓰기 작업에서는 다른 프로세서가 동시에 쓸 수 없도록 해서 쓰기 프로세서의 배타적 접근을 보장해야 함
   - 만약 두 프로세서가 동시에 같은 데이터에 쓰려고 시도한다면, 그 둘 중 하나가 경쟁에서 이기게 되고, 다른 프로세서의 복사본은 무효화됨
   - 다른 프로세서가 쓰기 작업을 완료하기 위해서는 갱신된 값을 갖고 있는 데이터의 새로운 복사본을 가져와야 함
   - 그러므로 이 프로토콜은 쓰기 순서화도 시행하고 있음

3. 블록 크기는 캐시 일관성 유지에 큰 영향을 미침
   - 예를 들어, 블록 크기가 8워드인 캐시에 대한 스누핑에서 두 프로세서가 한 워드를 교대로 쓰고 읽는다고 가정
   - 대부분의 프로토콜에서 두 프로세서가 블록 전체를 주고받게 되므로 일관성 유지에 필요한 대역폭이 증가하게 됨
   - 큰 블록은 또한 거짓 공유(False Sharing, 관련 없는 두 공유변수가 같은 캐시 블록에 들어 있을 때, 프로세서들이 각각 다른 변수를 접근하더라도 블록 전체가 프로세서 사이에서 왔다갔다 하는 경우)라고 하는 문제도 야기할 수 있음
   - 연관이 없는 공유 변수 2개가 같은 캐시 블록에 있을 때, 프로세서들이 각기 다른 변수를 접근하고 있다 할지라도 플록 전체가 프로세서 사이에서 교환됨

4. 앞에서 살펴본 세 가지 특성들이 일관성을 보장하기에 충분하다고 할지라도, 쓰인 값이 언제 보이게 될 것인가 하는 문제 또한 중요
<div align="center">
<img src="https://github.com/user-attachments/assets/f8505677-7de3-4eea-ae48-ccae9b628b3c">
</div>

   - 이유를 알아보기 위해 위 그림에서 X의 읽기 작업이 다른 프로세서가 X에 쓴 값을 즉시 읽어야 한다고 요구할 수 없다는 점에 주목
   - 예를 들어, 만일 한 프로세서의 X에 대한 쓰기 작업이 다른 프로세서에 의한 X의 읽기 작업 직전에 일어났다면, 읽기 작업이 새로 쓴 값을 가져오는 것을 보장하기가 아마도 불가능할 것
     + 그 시점에는 새 데이터가 프로세서를 출발하지도 못했을 수 있음
     + 쓴 데이터가 정확히 언제 읽힐지는 메모리 정합성 모델(Memory Consistency Model)에 의해 정의
   - 모든 프로세서의 쓰기의 결과를 보기 전까지 쓰기 작업이 완료되지 않고 다음 쓰기 작업의 발생도 허락하지 않으며, 프로세서가 다른 메모리 접근에 대한 쓰기 작업들의 순서를 변경하지 않는다고 가정
     + 이 두 가지 조건은 만약 프로세서가 주소 X에 쓰기 작업을 하고 다음에 Y에 쓰기 작업을 한다면, Y의 새로운 값을 보는 모든 프로세서는 반드시 X의 새로운 값을 본다는 것을 의미
     + 이러한 제한들은 프로세서가 읽기 작업의 순서는 재조정할 수 있게 하지만, 쓰기 작업은 프로그램 순서대로 마칠 것을 강제

5. 입력이 캐시 뒤 메모리를 바꿀 수 있고, 나중 쓰기 캐시의 경우 출력이 최신 값을 필요로 할 수 있으므로 멀티프로세서의 캐시들 뿐 아니라 단일프로세서의 캐시와 입출력에 대해서도 캐시 일관성 문제가 존재
   - 멀티프로세서와 입출력에 대한 캐시 일관성 문제가 출발점은 같지만, 적절한 해결책에 영향을 미치는 특성은 서로 다름
   - 복수의 데이터 복사본이 매우 드물게 발생하는 입출력과 달리 멀티프로세서에서 실행되는 프로그램은 일반적으로 다수의 캐시에 같은 데이터 복사본들을 가지고 있음

6. 공유된 블록의 상태가 분산되어 있는 스누핑 캐시 일관성 유지 프로토콜 외에, 디렉터리 기반 캐시 일관성 유지 프로토콜(Directory-based Cache Coherence Protocol)라는 중앙 집중식 프로토콜이 존재
   - 이 프로토콜은 디렉토리라고 불리는 한 장소에 실제 메모리 블록의 공유 상태를 저장
   - 디렉토리 기반 일관성 유지는 스누핑보다 구현 오버헤드가 더 큼
   - 그러나 이 방식은 캐시들 간 트래픽을 줄일 수 있어 프로세서 수가 더 많을 때 적합
