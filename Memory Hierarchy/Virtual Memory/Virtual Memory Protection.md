-----
### 가상 메모리 보호 구현
-----
1. 오늘날 가상 메모리의 가장 중요한 기능은 프로세스들과 운영체제 사이에 메모리 보호 기능을 제공하면서 여러 프로세스가 하나의 메인 메모리를 공유하도록 허용하는 것
2. 보호 메커니즘은 다수 프로세스가 같은 메모리를 공유하더라도 어떤 악의를 품은 프로세스가 다른 사용자 프로세스나 운영체제의 주소 공간에 고의적으로든, 실수로든 절대 쓰기를 수행할 수 없어야 함
3. TLB 쓰기 접근 비트가 페이지를 쓰기로부터 보호할 수 있음
4. 가상 메모리 시스템에서 운영체제가 보호를 구현할 수 있게 하기 위해서는, 하드웨어가 최소한 다음 세 가지 기본 능력을 제공해야 함
   - 실행 중인 프로세스가 사용자 프로세스인지 아니면 운영체제 프로세스인지 나타내는 최소한 두 가지 모드 지원 : 운영체제 프로세스는 관리자(커널 모드라고도 하며, 실행 중인 프로세스가 운영체제 프로세스라는 것을 표시하는 모드) 프로세스, 커널 프로세스, 집행(Executive) 프로세스 등 다양한 이름으로 불림
   - 프로세스 상태 일부를 사용자 프로세스가 읽기만 하고 쓸 수 없도록 함 : 여기에는 프로세서가 사용자 모드인지, 관리자 모드인지 알려주는 사용자 / 관리자 모드 비트, 페이지 테이블 포인터, TLB가 포함 : 여기에 쓰기 위해 운영체제가 관리자 모드에서만 사용 가능한 특수 명령어를 사용해야 함
   - 프로세서가 사용자 모드에서 관리자 모드로, 또 반대로 전환할 수 있는 메커니즘을 제공해야 함
     + 사용자 모드에서 관리자 모드로의 전환은 보통 시스템 호출(System Call, 사용자 모드에서 관리자 프로그램 공간의 특정 위치로 제어를 넘겨주는 특수 명령어로, 프로세스에서 예외 메커니즘 호출) 예외로 수행되는데, 관리자 코드 공간의 정해진 위치로 제어를 넘겨주는 특수 명령어(MIPS 명령어 집합의 syscall 명령어)로 구현
     + 다른 예외와 똑같이, 시스템 호출을 할 당시의 PC 값 EPC에 저장되고 프로세서는 관리자 모드로 넘어가게 됨
     + 예외 처리를 끝내고 사용자 모드로 되돌아가는 것은 ERET(Return From Exception) 명령어를 사용하는데, 이 명령어는 프로세스를 사용자 모드로 바꾸고 EPC에 저장된 주소로 점프하게 됨

   - 이런 방법을 사용하고 운영체제 주소 공간에 페이지 테이블을 저장함으로써 운영체제가 페이지 테이블을 변경할 수 있게 함
   - 동시에 사용자 프로세스가 페이지 테이블 내용을 변경하는 것을 막을 수 있으며, 또한 운영체제가 이 프로세스에 제공한 저장 공간만 접근할 수 있게 함

5. 어떤 프로세스가 다른 프로세스의 데이터를 읽어오는 것도 막아야 함
   - 일단 메모리 공유가 시작되면, 프로세스의 데이터를 다른 프로세스가 읽거나 쓰지 못하게 보호하는 기능이 제공되어야 함
   - 각 프로세스는 각각의 가상 주소 공간을 가지고 있으므로, 각 프로세스의 가상 주소 공간들이 서로 다른 실제 페이지로 사상되게 페이지 테이블을 구성하면, 어떤 프로세스도 다른 프로세스의 데이터에 접근할 수 없게 됨
   - 물론 이렇게 하기 위해서는 사용자 프로세스가 페이지 테이블 사상을 바꾸지 못하게 해야 함
   - 사용자 프로세스 스스로 자신의 페이지 테이블을 수정하지 못하게 하면 운영체제가 안전을 보장할 수 있지만, 그러나 운영체제는 페이지 테이블을 수정할 수 있어야 함 : 페이지 테이블을 운영체제의 보호된 주소 공간에 배치하면 두 가지 사항을 모두 만족시킬 수 있음
   - 프로세스들이 정보 공유를 원할 때는 운영체제가 이를 지원해줘야 함
     + 다른 프로세스의 정보를 접근하려면 이 프로세스의 페이지 테이블을 변경해야 하기 때문임
     + 쓰기 접근 비트는 공유를 읽기로 제한하는 데 사용될 수 있는데, 페이지 테이블의 다른 부분처럼 이 비트도 운영체제에 의해서만 변경될 수 있음
     + 예를 들어 프로세스 P1이 프로세스 P2 소유의 페이지를 읽을 수 있게 하기 위해서는, 공유하려는 실제 페이지를 가리키는 가상 페이지를 P1의 주소 공간에 할당하고, 이를 페이지 테이블에 넣어 달라고 P2가 운영체제에게 요청해야함
     + P2가 보호받기를 원한다면 운영체제는 쓰기 보호 비트로 P1이 데이터를 쓸 수 없게 할 수 있음
   - 페이지 테이블은 TLB 실패일 때만 접근하므로, 페이지에 대한 접근 권한을 결정하는 모든 비트들은 페이지 테이블과 TLB 양쪽에 다 넣어야 함

6. 운영체제가 실행 프로세스를 P1에서 P2로 바꾸고자 할 때, 보호를 위해서 P2가 P1의 페이지 테이블을 접근할 수 없도록 보장해야 함
   - 이러한 전환을 문맥 전환(Context Switch) 또는 프로세스 전환(Process Switch) : 프로세스를 다른 프로세스가 사용할 수 있도록 프로세서 내부 상태를 바꾸는 것으로, 현재 실행 중인 프로세스로 돌아가는 데 필요한 상태의 저장도 포함
   - TLB가 없을 때는 페이지 테이블 레지스터가 P2의 테이블을 가리키도록 바꾸기만 하면 됨(P1 페이지 테이블 대신)
   - 만약 TLB가 있다면, P1의 데이터를 보호하고, TLB에 P2의 엔트리를 적재하기 위해 P1에 속한 TLB 엔트리르 모두 제거해야 함
   - 프로세스 전환이 자주 일어난다면 이 방식은 아주 비능률적
     + 예를 들어, P2가 겨우 두어 개의 TLB를 적재하고 나서 바로 P1으로 복귀한다면, P1은 자신의 TLB 엔트리가 모두 없어져 버렸기 때문에 TLB 실패 처리 과정을 통해 이들을 다시 읽어 와야 함
     + 이 문제는 P1과 P2가 사용하는 가상 주소가 같을 수 있으므로, 이 주소들 간 혼동을 피하기 위해 TLB를 지워야 하기 때문에 발생

   - 일반적인 대안은 프로세스 식별자(Process Identifier) 또는 태스크 식별자(Task Identifier)를 붙여 가상 주소 공간을 확장하는 것
     + Intrinsity FastMATH 프로세서는 이 용도로 8비트 주소 공간 ID(ASID) 필드를 사용
     + 이 작은 필드는 현재 실행 중인 프로세스를 나타내며, 이 값은 프로세스를 전환할 때 운영체제에 의해 적재되는 레지스터에 저장
     + 프로세스 식별자는 TLB 태그 부분에 덧붙여져서, 페이지 번호와 프로세스 식별자 둘 다 일치할 때만 ㅅLB 적중이 발생
     + 이 방법을 사용하면 ASID를 재활용하는 것 같은 아주 희귀한 경우를 제외하고 TLB를 지울 필요가 없음

   - 프로세스 전환이 발생할 때 캐시에는 실행 중인 프로세스의 데이터가 있으므로 같은 문제가 캐시에서도 발생할 수 있음
     + 이러한 문제는 실제 주소를 사용하는 캐시와 가상 주소를 사용하는 캐시에서 서로 다른 방식으로 발생되며, 프로세스가 자신의 데이터만 접근할 수 있도록 보장하기 위해 프로세스 식별자를 비롯한 다양한 해결책이 사용되고 있음
