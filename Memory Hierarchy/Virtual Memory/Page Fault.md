-----
### 페이지 부재
-----
1. 가상 페이지의 유효 비트가 0이면 페이지 부재가 발생하며, 운영체제가 제어를 넘겨받게 됨
   - 제어를 넘기는 것은 예외 메커니즘에 의해 행해짐
   - 운영체제가 제어를 갖게 되면 계층의 다음 수준(보통 플래시 메모리나 자기 디스크)에서 그 페이지를 찾아서, 이 페이지를 메인 메모리의 어디에 넣을 것인지 결정해야 함

2. 가상 주소만으로는 그 페이지가 디스크 내 어디에 있는지 바로 알 수 없음
   - 즉, 가상 메모리 시스템에는 가상 주소 공간 내 각 페이지의 디스크 상 위치를 알고 있어야 함

3. 메모리 내 페이지가 언제 쫓겨날지 미리 알 수 없으므로, 운영체제는 대개 프로세스를 생성할 때, 프로세스의 모든 페이지를 위한 공간을 플래시 메모리나 디스크 상에 마련함
   - 이 디스크 상의 공간을 스왑 스페이스(Swap Space, 프로세스의 가상 메모리 공간 전체를 위해 예약된 디스크 공간)라고 부름
   - 이 때, 각 가상 페이지가 디스크의 어느 곳에 저장되는지를 기록하기 위한 자료 구조를 만듬
     + 이 자료구조는 페이지 테이블의 일부분일 수 있고, 페이지 테이블과 같은 방법으로 인덱스되는 다른 자료 구조일 수 있음
   - 단일 테이블이 실제 페이지 번호나 디스크 주소를 담고 있을 때의 구조를 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/1b38d7f2-12b9-40df-93c5-0e1ce2489dd9">
</div>

   - 운영체제는 또한 어떤 프로세스와 어떤 가상 주소가 각 실제 페이지를 추적하는 자료 구조를 만듬
   - 페이지 부재가 발생했을 때, 메인 메모리 내 모든 페이지가 사용 중이면, 운영체제는 교체할 페이지를 선택해야 함
   - 페이지 부재 횟수를 최소화해야 하기 때문에 대부분 운영체제는 가까운 시간 내 사용되지 않을 페이지를 선정하려고 함
   - 이를 위해 운영체제는 과거를 이용하고 미래를 예측하는 LRU(Least Recently Used) 교체 방법을 사용
     + 오랫동안 사용하지 않은 페이지가 최근에 사용된 페이지보다 앞으로 사용될 가능성이 적다는 가정하에 사용한 지 가장 오래된 페이지를 찾음
     + 교체된 페이지는 디스크 상 스왑 스페이스에 써짐
     + 운영체제 또한 하나의 프로세스이며 메모리를 제어하는 테이블 또한 메모리에 저장

4. 완벽하게 LRU 방식을 구현하는 것은 메모리를 참조할 때마다 자료구조를 갱신해야 하므로 매우 비용이 많이 발생
   - 대신에 많은 운영체제는 최근에 어떤 페이지가 참조되고 참조되지 않았는지를 추적하는 유사 LRU 방식을 사용
   - 운영체제가 LRU 페이지를 찾는 것을 돕기 위해 어떤 컴퓨터들은 참조 비트(Reference Bit) 또는 사용 비트(Use Bit)를 두고, 페이지가 접근될 때마다 그 값을 1로 함
     + 참조 비트(사용 비트) : 페이지가 접근될 때마다 값이 1이 되는 필드로서, LRU나 다른 교체 방식의 구현에 사용
   - 운영체제는 주기적으로 참조 비트를 0으로 만들고, 후에 참조된 페이지만 다시 1로 만들어서, 특정 시간 동안 어떤 페이지들이 접근되었는지를 알 수 있게 함
   - 이 사용 정보를 이용해 운영체제는 가장 오래 전에 참조된 것들(참조 비트가 0으로 있는 것들) 중 하나를 선택할 수 있음
   - 만약 참조 비트가 하드웨어적으로 제공되지 않는다면, 운영체제는 어떤 페이지가 접근되었었는지를 알기 위한 다른 방법을 찾아야 함

5. 32비트의 가상 주소, 4 Kib 페이지, 페이지 테이블 엔트리당 4바이트로 된 페이지 테이블의 전체 크기를 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/146aed02-2ba2-43d8-ab42-abfdbd06e136">
</div>

   - 즉, 실행 중인 프로그램마다 4 MiB의 메모리가 항상 필요
   - 이 크기는 프로세스가 하나일 때 그리 나쁘지 않지만, 각자 자신의 페이지 테이블을 가지는 수백 개의 프로세스가 실행 될 때와 위의 수식에 따라 $2^{52}$ 워드가 필요한 64비트 주소는 어떻게 처리되어야 하는가?
     + 페이지 테이블 떄문에 필요한 저장 용량을 줄이기 위해 다양한 기법이 사용
   - 페이지 테이블에 할당된 메인 메모리를 최소화하면서 필요한 최대 저장 용량을 줄이기 위한 방법
     + 가장 간단한 방법은 한 프로세스에 대한 페이지 테이블 크기를 제한하는 한계(Limit) 레지스터를 사용하는 것 : 가상 페이지 번호가 한계 레지스터 값보다 더 커지면, 페이지 테이블에 새로운 엔트리를 추가해야 함
       * 이 기술은 프로세스가 더 많은 공간을 사용하면 페이지 테이블도 따라서 커지는 것을 허용
       * 이렇게 하면, 프로세스가 가상 주소 공간의 페이지를 많이 사용할 때만 페이지 테이블이 커지게 됨
       * 이 기술을 사용하려면 주소 공간이 한 방향으로만 확장되어야 함

     + 대부분 언어들은 스택(Stack)과 힙(Heap) 2개의 확장 가능한 영역을 필요로 하므로, 한 방향으로만 커지는 것만으로 충분하지 않음
       * 이 점 떄문에 페이지 테이블을 둘로 나누어서 한 테이블은 가장 높은 주소에서 아래로 커지고, 다른 테이블은 가장 낮은 주소에서 위로 늘어나는 것이 편리
       * 이렇게 하려면 2개의 분리된 페이지 테이블과 2개의 분리된 한계 레지스터가 존재해야 함
       * 2개의 페이지 테이블을 사용하게 됨으로써 주소 공간은 2개의 세그먼트로 나누어지게 되며, 보통 주소의 최상위 비트가 어느 세그먼트를 사용할지에 따라 2개의 세그먼트로 나누어지게 됨
       * 보통 주소의 최상위 비트가 어느 세그먼트를 사용할지에 따라 어느 페이지 테이블을 사용할지 결정하게 됨
       * 주소의 최상위 비트가 세그먼트를 지정하기 떄문에, 세그먼트 최대 크기는 주소 공간의 절반
       * 각 세그먼트의 한계 레지스터는 세그먼트의 현재 크기를 나타내는데, 페이지 단위로 커짐
       * 이런 유형의 세그먼테이션은 MIPS를 비롯한 많은 컴퓨터 구조 에서 사용하지만, 응용 프로그램에서는 잘 사용되지 않고, 운영체제에서 사용
       * 이 기법의 최대 단점은 가상 주소가 연속적으로 사용되지 않고 주소 공간이 드문드문 떨어져서 조금씩 사용될 때는 별 효과가 없음

     + 페이지 테이블 크기를 줄이는 또 다른 방법은 가상 주소에 해시 함수(Hashing Function)을 적용하여, 페이지 테이블이 가상 페이지 수만큼이 아닌 메인 메모리 내 실제 페이지 개수만큼만 크면 되게 하는 것
       * 이런 구조를 역 페이지 테이블(Inverted Page Table)이라 하며, 물론 역 페이지 테이블을 사용하면 페이지 테이블을 직접 인덱스를 할 수 없기 때문에, 엔트리를 찾는 과정이 약간 더 복잡해짐

     + 페이지 테이블 저장에 필요한 전체 용량을 줄이기 위해 다단계 페이지 테이블을 쓸 수 있음
       * 첫 번쨰 단계는 가상 주소 공간의 큰 고정 크기 블록들을 사상하는데, 이런 페이지는 모두 64 ~ 256개 정도임
       * 이 큰 블록들을 세그먼트, 이 첫 단계 사상 테이블을 세그먼트 테이블이라고 부르기도 함 (이 세그먼트는 사용자에게 보이지 않음)
       * 세그먼트 테이블의 각 엔트리는 이 세그먼트의 페이지 중 할당된 것이 있는지 나타내고, 할당된 페이지가 있다면 이 세그먼트와 페이지 테이블을 가리킴
       * 주소 변환은 주소의 최상위 비트들을 이용하여 세그먼트 페이지 테이블을 조사함으로써 시작되며, 세그먼트 주소가 유효하면 세그먼트 테이블 엔트리가 가리키는 페이지 테이블을 주소의 다음 상위 비트들로 인덱스
       * 이 방식은 전체 페이지 테이블을 할당하지 않고도 주소 공간이 드문드문 떨어진 방식(다수의 불연속 세그먼트가 활성화되는)으로 사용될 수 있게 함
       * 이러한 방법은 매우 큰 주소 공간을 사용할 때나 불연속적인 할당을 요구하는 소프트웨어 시스템에 특히 유용
       * 이 2단계 사상의 가장 큰 단점은 주소 변환 과정이 복잡해짐

     + 페이지 테이블에 사용되는 실제 메인 메모리를 줄이기 위해 대부분 최신 컴퓨터들은 페이지 테이블을 페이지화
       * 가상 메모리와 같은 아이디어를 이용하기 위해 페이지 테이블을 가상 주소 공간에 두는 것
       * 이 경우 페이지 부재가 끊임없이 발생하는 것 같은 작지만 치명적인 문제가 있는데, 이런 문제는 피해야 함
       * 극복하는 방법은 아주 세부적인 사항이고, 또 프로세서에 따라 매우 달라짐
       * 즉, 모든 페이지 테이블을 운영체제의 주소 공간에 배치하고, 적어도 운영체제와 페이지 테이블 중 일부는 항상 메인 메모리에 있게 하여 디스크를 찾아가지 않게 함으로써 이 문제를 피할 수 있음
