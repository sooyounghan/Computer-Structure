-----
### 가상 메모리
-----
1. 메인 메모리가 보통 자기 디스크로 구현되는 2차 저장장치(Secondary Storage)를 위한 '캐시'로 동작할 수 있음
   - 이 기술을 가상 메모리(Virtual Memory)라고 부름 (가상 메모리 : 메인 메모리를 2차 저장장치 캐시로 사용하는 기술)
   - 역사적으로 가상 메모리를 사용하게 된 주요 동기
     + 여러 프로그램들을 효과적이고 안전하게 메모리를 공유할 수 있게 하기 위함 (클라우드 컴퓨팅을 위한 여러 가상 머신의 메모리 요구)
     + 작고 제한된 메인 메모리에서 프로그래밍 하는 제약을 제거하기 위함

2. 다수의 가상 머신이 같은 메모리를 사용할 수 있게 하려면, 모든 프로그램이 반드시 자신에게 할당된 메인 메모리 부분만 읽고 쓸 수 있게 하여 각 가상 머신이 다른 가상 머신으로부터 보호할 수 있어야 함
   - 캐시가 한 프로그램의 활발히 사용되는 부분만 담고 있는 것과 마찬가지로, 메인 메모리도 많은 가상 머신이 활발히 사용하는 부분만 담고 있으면 됨
   - 따라서, 지역성 원칙은 캐시 뿐만 아니라 가상 메모리를 가능하게 하는 근거가 됨
   - 가상 메모리는 메인 메모리는 물론 프로세서도 효율적으로 공유하게 해줌

3. 프로그램을 컴파일 할 때 가상 머신이 다른 어떤 가상 머신들과 메모리를 공유할 지 알 수 없음
   - 실제로 메모리를 공유하는 가상 머신은 가상 머신들이 수행되는 동안 동적으로 변하게 됨
   - 이러한 동적 상호작용 때문에 각 프로그램들이 자신만의 주소 공간(Address Space), 즉 이 프로그램만 접근 가능한 별개의 메모리 영역으로 컴파일 되기를 원함
   - 가상 메모리는 프로그램의 주소 공간을 실제 주소(Physical Address, 메인 메모리 내 주소)로 변환해줌
   - 이러한 변환 과정이 한 프로그램의 주소 공간을 다른 가상 머신으로부터 보호(Protection)
     + 보호 : 프로세서 / 메모리 / 입출력 장치를 공유하는 여러 프로세스들이 의도적이든, 비의도적이든 남의 데이터를 읽거나 쓰지 못하게 해서 서로 간섭하지 않도록 하는 메커니즘의 집합 (이 메커니즘은 운영체제를 사용자 프로세스로부터 격리시키는 역할도 함)

4. 가상 메모리가 생겨나게 된 두 번째 동기는 사용자 프로그램이 메인 메모리보다 더 커질 수 있게 해주려는 것
   - 이전에는 프로그램이 메인 메모리보다 더 클 경우 프로그램을 메모리에 맞추는 일은 프로그래머의 책임
   - 프로그래머가 프로그램을 작은 조각으로 나누고, 상호 배타적 조각들을 찾아내야 했음
   - 이 오버레이(Overlay)들은 실행 도중 사용자 프로그램의 제어하에 적재되거나 제거되었음
   - 프로그램이 적재되지 않은 오버레이를 접근하는 일이 없고, 적재된 오버레이는 전통적으로 모듈로 구성되었으며, 각 모듈은 코드와 데이터를 갖고 있음
   - 다른 모듈에 속한 프로시저 사이의 호출이 발생하면 한 모듈 위에 다른 모듈을 덮어쓸 수 있음

5. 따라서, 이를 위해 발명된 가상 메모리는 메인 메모리(때로는 가상 메모리와 구별하기 위해 실제 메모리(Physical Memory)라고도 부름)와 2차 기억장치로 구성되는 두 단계의 메모리 계층을 자동으로 관리

6. 가상 메모리와 캐시에 적용되는 개념 자체는 같을지라도 역사적 뿌리는 다르다보니 서로 다른 용어를 사용
   - 가상 메모리 블록은 페이지(Page)라 불리고, 가상 메모리 실패는 페이지 부재(Page Fault, 접근하려는 페이지가 메인 메모리 안에 존재하지 않을 때 발생하는 사건)라고 불림
     + 가상 메모리를 갖는 프로세서가 가상 주소(Virtual Address, 가상 메모리에서의 위치를 나타내는 주소로서, 메모리에 접근할 때 주소 사상 메커니즘에 의해 실제 주소로 변환)를 내보내면, 하드웨어와 소프트웨어가 협력하여 가상 주소를 실제 주소(Physical Address)로 변환한 후, 메인 메모리 접근에 사용
     + 페이지로 구성된 가상 주소 메모리가 메인 메모리로 사상되는 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/d146de43-2ea5-4bf9-af86-2ef980422ae7">
</div>

   - 이 과정을 주소 변환(Address Translation) 또는 주소 사상(Address Mapping)이라고 함 (가상 주소를 메모리 접근에 사용되는 주소로 사상시키는 과정)
   - 오늘날 가상 메모리에 의해 제어되는 두 메모리 계층은 개인 휴대용 기기에서는 보통 DRAM과 플래시 메모리이고, 서버에서는 DRAM과 자기 디스크

7. 가상 메모리는 재배치(Relocation) 기능을 제공하여 수행될 프로그램의 적재를 단순화함
   - 재배치는 프로그램에 의해 사용되는 가상 주소를 다른 실제 주소로 사상시킨 후 메모리 접근에 사용
   - 이 재배치는 메인 메모리 내 어떤 위치에도 프로그램을 적재할 수 있게 함
   - 오늘날 쓰이는 모든 가상 메모리 시스템은 프로그램을 고정 크기 블록(페이지)의 집합으로 재배치 시킴
   - 따라서, 프로그램에 할당하기 위해 메모리의 연속적 블록을 찾아낼 필요가 없게 되었으며, 대신 운영체제는 메인 메모리 내 빈 페이지가 충분히 많이 있는지만 확ㅇ니하면 됨

8. 가상 메모리 시스템 주소는 가상 페이지 번호(Virtual Page Number, VPN)와 페이지 변위(Page Offset)으로 나누어짐
   - 가상 페이지 번호가 실제 페이지 번호(Physicla Page Number, PPN)으로 변환되는 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/00843585-6edb-44eb-8fdf-f20af62f279a">
</div>

   - 실제 페이지 번호는 실제 주소의 상위 부분을 구성하고, 변환 후에도 바뀌지 않는 페이지 변위는 하위 부분을 구성
   - 페이지 변위 필드의 비트 수는 페이지의 크기를 결정
   - 가상 주소로 참조 가능한 페이지 수는 실제 주소로 참조 가능한 페이지 수와 같지 않아도 됨 : 실제 페이지보다 더 많은 수의 가상 페이지가 무한히 큰 가상 메모리 환상의 기초가 됨

9. 가상 메모리에서 페이지 부재 처리에 소요되는 높은 비용을 줄이기 위해 많은 설계 대안들이 제시
    - 페이지 부재는 처리하는 데 수백만 사이클이 소요
    - 보통 크기의 페이지의 경우 첫 번째 워드를 꺼내는 데 걸리는 시간이 거의 대부분인 실패 손실 때문에, 가상 메모리 설계에 대해 다음 몇가지 결정이 생김
      + 긴 접근시간을 보상할 만큼 페이지가 충분히 커야 함
        * 오늘날 4 KiB에서 16 KiB 크기가 일반적이며, 새로운 데스크톱과 서버 시스템이 32 KiB와 64 KiB 페이지를 지원하도록 개발되고 있음
        * 그러나 임베디드 시스템들은 반대방향으로 발전하고 있어 페이지 크기가 1 KiB 정도
      + 페이지 부재 발생률을 줄이는 구성이 바람직 : 이를 위해 사용되는 주된 기술은 페이지를 완전 연관 방식으로 메모리에 배치하는 것
      + 페이지 부재는 소프트웨어로 처리할 수 있음 : 이 부담이 디스크를 접근하는 시간과 비교할 때 작기 떄문이며, 게다가 소프트웨어는 페이지 배치에 좋은 알고리즘을 사용할 수 있음
        * 왜냐하면, 실패율이 조금만 줄어도 충분히 그러한 알고리즘의 비용을 보상할 수 있기 때문임
      + 가상 메모리에서 즉시 쓰기 방식을 사용하면 시간이 너무 오래걸리므로 적절핮 못함 : 대신 가상 메모리 시스템은 나중 쓰기 방식을 사용

10. 원래 가상 메모리는 시분할 시스템의 일부로 다수의 프로그램이 컴퓨터를 공유할 수 있게 하기 위해 개발

11. 서버와 PC의 경우 2비트 주소를 사용하는 프로세서들이 문제가 되기도 함
    - 일반적으로 가상 주소의 크기가 실제 주소 크기보다 훨씬 크다고 생각하지만 그 반대의 경우도 존재
    - 프로세서의 주소 크기가 메모리 기술 수준에 비해 상대적으로 작을 때 이런 현상이 발생
    - 프로그램 하나나 가상 머신 하나를 실행할 때는 별 이득이 없지만, 다수의 프로그램이나 가상 머신들이 동시에 실행될 때는 스와핑 되지 않음으로써 또는 병렬 프로세서상에서 수행됨으로써 이득을 볼 수 있음

12. 여기서는 주로 고정된 크기의 블록을 사용하는 페이징에 초점
    - 이 방법 외에도 가변 크기와 블록을 사용하는 세그먼테이션(Segmentation, 세그먼트 번호와 세그먼트 변위 두 부분으로 구성된 주소를 사용하는 가변 크기 주소 사상 기법으로, 세그먼트 번호는 실제 주소로 사상)기법이 존재
    - 세그먼테이션에서 주소는 세그먼트 번호와 세그먼트 변위 두 부분으로 이루어짐
      + 세그먼트 번호가 실제 주소로 사상되고, 여기에 변위를 더하여 실질적인 실제 주소를 구함
      + 세그먼트는 그 크기가 다양하므로 변위가 세그먼트 내 있는지 확인하기 위해 경계 검사도 피요
      + 세그먼테이션의 주 용도는 보다 강력한 보호 방법과 공유 방법을 주소 공간에 제공하는 것
    - 하지만, 주소 공간이 논리적으로 분리적 조각들로 분할되어, 세그먼트 번호와 변위 두 부분으로 된 주소를 사용해야 한다는 단점 존재
      + 반면에 페이징은 페이지 번호와 변위 사위의 경계가 프로그래머나 컴파일러에게 보이지 않음
    - 세그먼트는 컴퓨터 워드 크기를 변화시키지 않고 주소 공간을 확장하는 방법으로도 사용되어 왔음
      + 그러나 이러한 시도는 두 부분으로 된 주소 때문에 생기는 성능 손실과 불편함 때문에 성공적이지 못했으며, 프로그래머와 컴파일러가 이 부분을 꼭 알아야 하는 단점 존재
    - 많은 시스템들은 주소 공간을 고정 크기의 큰 블록으로 나누는데, 이렇게 하면 운영체제와 사용자 프로그램 사이 보호 기능이 단순화되고, 페이징 구현의 효율성이 증대
      + 이런 블록을 '세그먼트'라고 부르는 경우도 있지만, 이 방식은 가변 크기를 갖는 세그멘테이션 방식보다 훨씬 간단하고 사용자 프로그램에게 보이지 않음
