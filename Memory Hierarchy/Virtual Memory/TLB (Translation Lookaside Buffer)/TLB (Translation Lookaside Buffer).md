-----
### 주소 변환을 빠르게 하기 : TLB
-----
1. 페이지 테이블이 메인 메모리에 있기 떄문에 프로그램에 의한 모든 메모리 접근이 최소한 2배의 시간이 걸림
   - 실제 주소를 얻기 위한 메모리 접근 한 번과 데이터를 얻기 위한 또 한 번의 접근이 필요하기 때문임
   - 접근 성능을 높이기 위한 핵심은 페이지 테이블에 대한 참조의 지역성을 이용하는 것
     + 어떤 가상 페이지 번호의 변환이 사용되면, 이 페이지상 워드 참조는 공간적 지역성과 시간적 지역성을 가지므로 떄문에 가까운 장래에 그 주소 변환이 다시 필요할 가능성이 높음

2. 따라서 요즘 컴퓨터들은 최근에 사용된 변환을 가지고 있는 특별한 캐시가 존재하는데, 이 캐시는 특별한 주소 변환 전용 캐시로, 변환 캐시(Translation Cache)라고 부르는 것이 정확하지만, 통상적으로 변환 참조용 버퍼(Translation-Lookaside Buffer, TLB)라고 부름
   - 변환 참조용 버퍼(TLB) : 페이지 테이블에 접근하는 것을 피하기 위해 최근에 사용된 주소 사상을 보관하고 있는 캐시
   - TLB 각 태그 항목이 가상 페이지 번호의 일정 부분을 갖고 있어 TLB 데이터 항목이 실제 페이지 번호를 갖고 있음을 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/53003008-9f25-4ae8-9912-45b5cc0753b3">
</div>

   - 이제는 참조할 때마다 페이지 테이블 대신 TLB를 접근하므로, TLB는 갱신 비트나 참조 비트 같은 다른 상태 비트들을 포함해야 함

3. 메모리를 참조할 때마다 TLB에서 가상 페이지 번호를 찾아보고, 적중되면 실제 페이지 번호는 주소를 만드는 데 쓰이고 해당 엔트리 참조 비트는 1이 되고, 프로세서가 쓰기를 수행하면 갱신 비트도 1이 됨
   - TLB 실패가 발생하면, 이 실패가 페이지 부재인지 단순한 TLB 실패인지 알아야 함
   - 이 페이지가 메모리에 있으면, 그 변환이 TLB에 없을 뿐이지 페이지 부재는 아님 : 이 경우에는 프로세서가 그 변환을 페이지 테이블에서 읽어 TLB에 적재하고 참조를 다시 시도함으로써 TLB 실패를 처리할 수 있음
   - 그 페이지가 메모리에 존재하지 않으면, TLB 실패는 진짜 페이지 부재를 의미 : 이 경우에는 프로세서가 예외를 사용하여 운영체제를 호출
   - TLB는 메인 메모리 내의 페이지보다 훨씬 더 적은 수의 엔트리를 가지므로, TLB 실패는 실제 페이지 부재보다 더 빈번하게 발생

4. TLB 실패는 하드웨어로 처리할 수도 있고 소프트웨어로도 처리할 수 있음
   - 실제로 이 두 방법 모두 수행해야 할 기본적 동작이 같으므로, 두 가지 방법 성능 차이는 거의 없음
   - TLB 실패가 발생해서 실패한 변환을 페이지 테이블에서 읽어내면, 교체할 TLB 엔트리를 선정해야 함
   - TLB 엔트리에는 참조 비트와 갱신 비트가 포함되어 있으므로, 엔트리를 교체할 때 이 비트들도 페이지 테이블에 저장해야 함 : 이 비트들만이 TLB 엔트리 중 변화될 수 있는 부분
   - TLB 실패율이 낮기 때문에 나중 쓰기 방법(엔트리에 쓸 때가 아닌 실패가 발생했을 때 이 엔트리를 페이지 테이블에 저장하는 것)을 사용하는 것이 효율적
   - 실패가 발생해서 새로운 테이블 엔트리를 가져와야 하는 경우가 아니면 TLB에 쓰는 일이 없게 하기 위해 참조 비트와 갱신 비트를 그대로 구현하지 않고 비슷하게 흉내 내는 다른 방법을 사용하는 시스템도 존재

5. TLB의 일반적인 값
   - TLB 크기 : 16 ~ 512 엔트리
   - 블록 크기 : 1 ~ 2 페이지 테이블 엔트리 (보통 각각 4 ~ 8 바이트)
   - 적중 시간 : 0.5 ~ 1 클럭 사이클
   - 실패 손실 : 10 ~ 100 클럭 사이클
   - 실패율 : 0.01 ~ 1%

6. TLB에 사용된 연관 정도는 매우 다양
   - 완전 연관 사상이 실패율이 낮기 때문에 어떤 시스템들은 작은 완전 연관 TLB를 사용
   - TLB는 작기 때문에 완전 연관 사상 구현 비용이 그렇게 높지 않음
   - 큰 TLB를 사용하는 시스템들도 있는데, 이 경우 연관 정도는 대체로 작음
   - LRU 하드웨어의 구현 비용이 너무 높으므로, 완전 연관 사상에서 교체할 엔트리를 결정하는 일이 쉽지 않음
   - 게다가 TLB 실패는 페이지 부재보다 더 빈번히 발생하므로 값싸게 처리해야 함 : 따라서 페이지 부재 떄처럼 비싼 소프트웨어 알고리즘을 사용할 수 없으며, 그 결과 교체할 엔트리를 무작위로 선정하는 시스템들이 많이 있음
