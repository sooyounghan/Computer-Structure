-----
### TLB 실패와 페이지 부재 처리
-----
1. TLB 적중 사에는 TLB에서 가상 주소가 실제 주소로 곧바로 변환되지만, TLB 실패와 페이지 부재의 처리는 훨씬 복잡
   - TLB 엔트리 중에서 가상 주소와 일치하는 것이 없을 때 TLB 실패가 발생
   - TLB 실패의 경우
     + 페이지가 메모리에 있음 : 이 때는 실패를 일으킨 TLB 엔트리만 새로 만들면 됨
     + 페이지가 메모리에 없음 : 이 때는 페이지 부재를 처리하기 위해 운영체제로 제어를 넘겨야 함

2. MIPS는 전통적으로 TLB 실패를 소프트웨어로 처리
   - 메모리에서 페이지 테이블 엔트리를 가져온 다음 TLB 실패를 발생시킨 명령어를 다시 실행 : 다시 실행하면 TLB 성공이 될 것
   - 페이지 테이블 엔트리가 페이지가 메모리에 없다고 하면 페이지 부재 예외가 발생

3. TLB 실패나 페이지 부재 처리는 실행 중인 프로세스를 인터럽트하여, 운영체제로 제어를 넘기고, 중단된 프로세스를 나중에 계속 실행하는 예외 메커니즘을 이용
   - 페이지 부재는 종종 메모리를 접근하는 클럭 사이클 도중에 인식
   - 페이지 부재를 처리하고 난 후 명령어를 다시 시작하기 위해서는 페이지 부재를 일으킨 명령어의 주소를 갖고 있는 프로그램 카운터를 저장해야 함 (이 값은 EPC에 저장)

4. TLB 실패나 페이지 부재 예외는 메모리 접근 클럭 사이클이 끝나기 전에 탐지되어야 함
   - 그래야 다음 클럭 사이클에 정상적인 명령어 실행 대신 예외 처리를 시작할 수 있음
   - 페이지 부재가 이 클럭 사이클에서 인식되지 못하면, 적재 명령어가 레지스터 내용을 바꾸어 버릴 수 있음
   - 그러면 그 명령어를 다시 시작할 때 큰 문제가 발생할 수 있으며, 그렇지 않으면 $1의 내용이 바뀌기 때문에 그 명령어를 올바르게 재수행할 수 없음
   - 저장 명령어의 경우도 마찬가지이며, 페이지 부재가 발생하면 메모리에 기록하는 것을 막아야 하며, 이 일은 보통 쓰기 제어신호를 메모리에 인가하지 않음으로써 이루어짐

5. 운영체제의 예외 처리기 실행이 시작될 때부터 운영체제가 프로세서의 모든 상태를 저장하는 시간 사이에는 운영체제가 매우 취약한 상태
   - 예를 들어 첫 번째 예외를 처리하고 있는 도중에 다른 예외가 또 발생하면 제어 유닛이 EPC를 덮어 써서 페이지 부재를 일으킨 명령어로 돌아갈 수 없게 됨
     + 예외를 활성화(인터럽트 활성화라고도 하며, 프로세스가 예외에 응답할지 말지를 제어하는 신호나 동작으로, 프로세서가 다시 시작하는 데 필요한 상태를 안전하게 저장하기 전에 다른 예외가 또 발생하는 것을 막기 위해 필요)하거나 비활성화하는 기능을 제공함으로써 방지 가능
     + 일단 예외가 발생하면 프로세서는 모든 다른 예외를 비활성화하는 비트를 1로 만들며, 이 작업은 프로세서가 관리자 모드 비트를 1로 하는 것과 동시에 할 수 있음
     + 그 다음에는 다른 예외가 발생하더라도 복구할 수 있도록 운영체제가 EPC와 Cause 레지스터를 저장 : EPC와 Cause 레지스터는 예외 / TLB 실패 / 페이지 부재 처리를 도와주는 2개의 특수 제어 레지스터
<div align="center">
<img src="https://github.com/user-attachments/assets/33e21287-4fc1-4521-8047-00d16f42cd41">
</div>

   - 운영체제는 다시 예외를 활성화 할 수 있으며, 이러한 과정은 예외가 발생하더라도 프로세서가 어떤 상태도 잃어버리지 않고 인터럽트 당한 명령어를 다시 수행할 수 있도록 해줌

6. 운영체제가 페이지 부재를 일으킨 가상 주소를 알게 되면 다음 3단계를 수행
   - 가상 주소를 사용해 페이지 테이블 엔트리를 찾고 디스크 내에서 참조된 페이지 위치를 찾음
   - 교체할 실제 페이지를 선정 : 만약 선정된 페이지 갱신 비트가 1이면, 새로운 가상 페이지를 이 실제 페이지로 가져오기 전에 먼저 디스크에 기록해야 함
   - 참조된 페이지를 선정된 실제 페이지로 가져오기 위해 디스크 읽기를 시작
     + 물론, 이 마지막 단계는 수백만 프로세서 사이클이 소요 (교체될 페이지 갱신 비트가 1이면 단계 2에도 같은 시간 소요)
     + 따라서 운영체제는 디스크 접근이 끝날 때까지 프로세서에서 수행될 다른 프로세스를 선택하는 것이 일반적
     + 운영체제가 프로세스의 상태를 저장했으므로 프로세서의 제어를 다른 프로세스로 넘길 수 있음

7. 데이터 접근 시 발생하는 페이지 부재 예외 처리는 다음 세 가지 특성 떄문에 구현하기 힘듬
   - 명령어 페이지 부재와는 달리 명령어 실행 도중 발생할 수 있음
   - 예외를 처리하기 전에 그 명령어를 완결할 수 없음
   - 예외 처리 이후에는 아무 일도 없었던 것 처럼 그 명령어 실행을 재개해야 함

8. 명령어를 다시 시작할 수 있게(Restartable Instruction, 예외가 처리된 뒤 실행을 다시 시작할 수 있는 명령어, 예외는 명령어 실행 결과에 어떤 영향도 끼치지 않음) 만들어서 예외를 처리한 후 중단되었던 명령어 실행을 계속할 수 있는 것이 MIPS 같은 구조에서는 비교적 쉬움
   - 어떤 명령어든 데이터를 하나만 쓸 수 있고 이 쓰기는 명령어 사이클의 맨 마지막 단계에서 일어나므로, 명령어 수행이 완료되는 것을 막고(쓰기를 못하게 해서) 명령어를 처음부터 다시 실행하면 됨

9. MIPS는 TLB 실패가 발생하면 MIPS 하드웨어는 Bad-VAddr이라고 불리는 특수 레지스터에 참조된 페이지 번호를 저장하고 예외를 발생시킴
10. 예외가 운영체제를 동작시키면 운영체제가 소프트웨어로 실패를 처리
    - 이 때, TLB 실패 핸들러의 위치인 주소 8000 $0000_{16}$로 제어가 넘어감
    - 실패한 페이지의 실제 주소를 알기 위해 TLB 실패 처리 루틴은 가상 주소의 페이지 번호와 활성화된 프로세스 페이지 테이블의 시작 주소를 나타내는 페이지 테이블 레지스터를 사용하여 페이지 테이블을 인덱스함
    - 이 인덱스 작업을 빠르게 하기 위해 MIPS 하드웨어는 필요한 모든 정보를 Context 레지스터에 넣음
      + 상위 12비트는 페이지 테이블의 시작 주소이고, 다음 18비트는 실패된 페이지의 가상 주소
      + 페이지 테이블 엔트리의 크기는 한 워드이므로 마지막 2비트는 0
      + 따라서, 처음 두 명령어는 Context 레지스터 값을 커널 임시 레지스터 $k1에 복사하고, 그 주소의 페이지 테이블 엔트리르 $k1에 적재
      + $k0와 $k1은 운영체제가 아무 때나 사용할 수 있게 예약되어 있음 : 이렇게 하는 주된 이유는 TLB 핸들러가 빠르게 동작하기 위함

11. TLB 실패 핸들러의 MIPS 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/01a64919-5b78-4203-82a6-e2c5878ff947">
</div>

   - MIPS에는 TLB 갱신을 위한 특수 시스템 명령어들이 존재
   - 명령어 tlbwr은 제어 레지스터 EntyLo를 제어 레지스터 Random에 의해 선택되는 TLB 엔트리에 복사
     + Random은 무작위 교체를 수행하므로 기본적으로 규칙이 없는 카운터라고 보면 됨
     + TLB 실패는 12 클럭 사이클 정도 소요

12. TLB 실패 핸들러는 페이지 테이블 엔트리가 유효한지 검사하지 않음에 유의
    - TLB 엔트리 실패 때문에 생기는 예외는 페이지 부재보다 훨씬 더 자주 발생하므로, 운영체제는 페이지 테이블 엔트리를 검사하지 않고 TLB에 넣은 후 명령어를 다시 실행
    - 만약 엔트리가 유효하지 않으면, 또 다른 예외가 발생해서 운영체제가 페이지 부재를 인식하게 됨
    - 이 방법이 자주 발생하지 않는 페이지 부재에 대해서 약간의 성능 저하를 초래하지만 자주 발생하는 TLB 실패를 빠르게 처리

13. 페이지 부재를 발생시킨 프로세스가 인터럽트되면 TLB 실패 핸들러와는 다른 주소인 8000 $0180_{16}$로 제어를 옮김
    - TLB 실패는 실패 손실을 줄이기 위해 별도 시작 주소를 갖고 있지만, 페이지 부재는 일반적인 예외 처리 주소 8000 $0180_{16}$에서 처리
    - 운영체제는 예외 Cause 레지스터를 이용해 예외 원인을 규명
    - 페이지 부재 예외이므로 운영체제가 할 일이 많음
    - 따라서, TLB 실패와는 다르게 활성화된 프로세스의 모든 상태를 저장하며, 이 상태는 모든 범용 레지스터와 부동 소수점 레지스터, 페이지 테이블 주소 레지스터, EPC, 예외 Cause 레지스터를 포함
    - 대부분 예외 핸들러는 부동 소수점 레지스터를 사용하지 않았으므로, 일반 엔트리 포인트는 이를 저장하지 않고, 이 레지스터를 사용하는 일부 핸들러들만 부동 소수점 레지스터를 저장

14. 예외 핸들러의 MIPS 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/30237b07-4e8e-4cb3-be04-6ea06b8e79e1">
</div>

   - 언제 예외를 활성화하고, 언제 비활성화할지 신경 쓰면서 어셈블리 코드로 상태를 저장하고 복원하지만, 특정 예외를 처리하기 위해서는 C코드를 호출

15. 페이지 부재를 일으킨 가상 주소를 찾는 방법은 페이지 부재가 명령어 부재인지, 데이터 부재인지에 따라 달라짐
    - 부재를 일으킨 명령어 주소는 EPC에 있으며, 따라서 명령어 페이지 부재라면 EPC가 부재 페이지의 가상 주소를 가지고 있음
    - 데이터 부재의 경우 명령어(이 주소는 EPC에 있음)에서 베이스 레지스터와 변위 필드를 가져와서 부재 된 가상 주소를 계산할 수 있음

16. 이 단순화된 스택 포인터(sp)가 유효하다고 가정하고 있음
    - 이런 하위 수준의 예외 프로그램에서 페이지 부재 문제를 피하기 위해 MIPS에서는 사상되지 않은 메모리(Unmapped Memory, 페이지 부재가 발생하지 않는 주소 공간 일부분)라고 불리는 페이지 부재가 발생하지 않는 주소 공간이 따로 있어서 예외 시작점과 예외 스택을 여기에 배치
    - MIPS 하드웨어가 가상 주소 8000 $0000_{16}$부터 BFFF $FFFF_{16}$까지 단순한 가상 주소의 상위 비트들을 무시하여 실제 주소로 변환함으로써 실제 메모리의 하위 부분에 넣음

17. 많은 메모리 위치를 접근할 수 있고 많은 데이터를 쓸 수 있는 복잡한 명령어들을 가지고 있는 프로세서의 경우 명령어를 재시작할 수 있게 만드는 것이 어려움
    - 한 명령어 실행 중 다수의 페이지 실패가 발생할 수 있음
    - 예를 들어 x86 프로세서는 수천 개의 데이터 워드를 접근하는 블록 이동(Block Move) 명령어를 가지고 있음
    - 이런 프로세서에서는 MIPS 명령어처럼 명령어를 처음부터 다시 시작하는 것이 불가능한 경우가 존재 : 대신 명령어 실행을 일단 중단하고 나중에 중단된 부분부터 이어서 실행
    - 명령어 실행 중간에서 명령어를 다시 시작하기 위해서는 어떤 특수한 상태를 저장한 뒤 예외를 처리하고 다시 그 특수한 상태를 복원하는 것이 필요
    - 이런 일이 제대로 되게 하려면 운영체제의 예외 처리 코드와 하드웨어 간 신중하고 긴밀한 협조가 필요

18. 메모리 접근 때마다 또 하나의 간접 계층을 두는 것보다, 가상 머신에서는 손님 가상 주소 공간에서 하드웨어의 실제 주소 공간으로 직접 사상하는 그림자 페이지 테이블(Shadow Page Table)을 VMM이 유지
    - VMM이 손님 페이지 테이블에 대한 모든 수정을 탐지함으로써, 하드웨어가 변환에 사용하는 그림자 페이지 테이블 엔트리가 손님 OS 환경의 페이지 테이블 엔트리에 해당하는 것임을 보장할 수 있음
    - 단, 손님 테이블의 리얼 페이지를 대체하는 정확한 실제 페이지의 경우는 제외
    - 따라서 VMM은 손님 OS가 자신의 페이지 테이블을 바꾸려고 하거나 페이지 테이블 포인터에 접근하려고 하는 어떤 시도도 모두 트랩해야 함
    - 이 일은 보통 손님 페이지 테이블에 쓰기를 막고, 손님 OS가 페이지 테이블 포인터에 접근하는 것을 트랩함으로써 이루어짐
    - 페이지 테이블 포인터를 접근하는 작업이 특권 동작이면 후자는 자연스럽게 이루어짐

19. 가상 머신 손님 OS가 각자 자기 페이지 테이블들을 관리하므로 가상 머신 명령어 집합 가상화 외에 가상 메모리의 가상화가 또 다른 문제가 됨
    - 이를 위하여 VMM이 리얼 메모리(Real Memory)와 실제 메모리(Physical Memory)의 개념(종종 같은 것으로 취급)을 분리시키고, 리얼 메모리를 가상 메모리와 실제 메모리 사이에 있는 별도의 중간 계층으롬 나들었음 (이 세 계층을 가상 메모리, 실제 메모리, 머신 메모리라고 부름)
    - 손님 OS는 자신의 페이지 테이블을 이용해 가상 메모리를 리얼 메모리에 사상하고, VMM 페이지 테이블은 손님 OS의 리얼 메모리를 실제 메모리에 사상
  
