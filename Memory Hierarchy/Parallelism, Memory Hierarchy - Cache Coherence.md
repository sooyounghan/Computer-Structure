-----
### 병렬성과 메모리 계층 구조 : 캐시 일관성
-----
1. 멀티코어 프로세서는 여러 개의 프로세서가 하나의 칩 안에 들어있는 것을 말함
   - 이 프로세서들은 공통의 주소 공간을 공유하며, 공유 데이터는 캐시를 사용할 때 새로운 문제를 야기함
   - 2개의 서로 다른 프로세서가 각각 자신의 캐시를 통하여 메모리를 보게 되므로, 추가적인 예방 조치가 없으면 각자 다른 값을 보게 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/6c0f7654-b4df-4794-8ec3-d3bdf2bbafb2">
</div>

   - 2개의 다른 프로세서가 어떻게 같은 위치에 2개의 다른 값을 갖게 되는지 보여주고 있으며, 일반적으로 이를 캐시 일관성 문제(Cache Coherence Problem)이라고 함

2. 비공식적으로, 어떤 데이터를 읽든지 항상 가장 최근에 쓴 값을 읽을 수 있다면, 메모리 시스템이 일관된다고 말할 수 있음
   - 이러한 정의는 비록 직관적으로 좋아보이기는 하지만, 모호하며 극도로 단순화된 것
   - 이 단순한 정의는 메모리 시스템 동작의 서로 다른 두 가지 측면을 포함하는데, 둘 다 올바른 공유 메모리 프로그램 작성에 중요
     + 일관성(Conherence)이라고 불리는 첫 번쨰 측면은 읽기가 가져오는 값을 정의
     + 정합성(Consistency)이라고 불리는 두 번째 측면은 쓴 값을 읽기가 가져오는 시기를 결정

3. 일관성 - 아래와 같은 조건이 만족되면 메모리 시스템은 일관적
   - 프로세서 P가 x에 쓴 후 P가 다시 X를 읽을 때, P의 쓰기와 읽기 사이에 어떠한 다른 프로세서도 X에 쓰기를 하지 않았다면, 항상 P가 쓴 값을 가져옴
     + 그러므로 위 그림에서 CPU A가 단계 3 이후에 X를 읽는다면, 값 1을 가져오게 될 것

   - 다른 프로세서가 X에 쓴 다음 어떤 프로세서가 X를 읽을 때, X에 대한 쓰기와 읽기가 시간적으로 충분히 떨어져 있으며, 이 두 동작 사이에 X에 대한 다른 쓰기가 없다면, 이 프로세서는 다른 프로세서가 X에 쓴 값을 읽음
     + 따라서, 위 그림에서 단계 3에서 CPU A가 X에 1을 저장한 후에, CPU B의 캐시의 값을 0에서 1로 바꾸는 메커니즘이 필요

   - 동일한 위치에 대한 쓰기는 순서화됨(Serialized)
     + 다시 말하면, 동일한 위치에 2개의 프로세서가 쓰기를 수행하는 경우, 모든 프로세서가 이 쓰기들을 같은 순서로 보게 됨
     + 예를 들어 CPU B가 단계 3 이후에 X에 2를 저장한다면, 어떤 프로세서가 X 값을 처음 2로 읽은 다음 나중에 1로 읽을 수 없음

   - 앞의 첫 번째 특성은 단순히 프로그램 순서를 유지하는 것이며, 당연히 단일프로세서에서는 이 특성이 항상 성립할 것
   - 두 번째 특성은 메모리에 대해 일관적 관점을 갖는다는 것이 무엇을 의미하는지에 대한 개념을 정의
     + 만약 프로세서가 계속해서 예전 값을 읽을 수 있다면, 메모리가 비일관적(Incoherent)이라고 명확하게 말할 수 있음
   - 쓰기 순서화(Write Serialization)의 필요성은 더 미묘하지만 똑같이 중요함
     + 쓰기를 순서화하지 않은 상태에서 P1이 X에 쓴 후, P2가 X에 썼다고 가정
     + 쓰기 순서화는 일정 시간이 지난 뒤에는 모든 프로세서가 P2에 쓴 값을 보는 것을 보장
     + 쓰기를 순서화하지 않는다면, P1이 쓴 값이 마냥 유지되어서 P2가 쓴 값을 먼저 보고, 그 후에 P1이 쓴 값을 보는 프로세서가 생길 수 있음
     + 이러한 문제점을 피하는 가장 간단한 방법은 동일한 위치에 대한 모든 쓰기가 항상 동일한 순서로 보이게 하는 것이며, 이러한 특성을 쓰기 순서화라고 함
    
