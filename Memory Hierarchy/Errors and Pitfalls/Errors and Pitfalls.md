-----
### 오류 및 함정
-----
1. 캐시를 시뮬레이션 할 때, 바이트 주소 지정이나 캐시 블록 크기를 고려해야 함
   - 캐시를 시뮬레이션 할 때 주어진 주소가 어느 캐시 블록에서 사상되는지 결정함에 있어, 바이트 주소지정과 다중 워드 블록의 영향을 정확히 고려해야 함
   - 예를 들어 블록 크기가 4바이트이고, 전체 크기가 32바이트인 직접 사상 캐시에서 바이트 주소 36은 캐시의 1번 블록으로 사상
     + 바이트 주소 36은 블록 주소 9가 되고(9 modulo 8)은 1이 됨
     + 또, 주소 36이 워드 주소이면 블록 (36 modulo 8) = 4로 사상
     + 따라서, 문제가 주소의 기준을 명확히 밝히도록 해야 함

   - 마찬가지로 블록 크기도 고려해야 함 : 블록 크기가 32바이트이고, 전체 크기가 256바이트인 캐시에서, 바이트 주소 300은 어느 블록으로 사상되는지 확인
     + 주소 300을 필드로 나누면 답을 찾을 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/9748a96f-ee19-4a4e-b2c5-72c7781ac8a7">
</div>

   - 따라서 바이트 주소 300의 블록 주소
<div align="center">
<img src="https://github.com/user-attachments/assets/fcb2c80c-9d49-470f-9f3e-284ab9a59279">
</div>

   - 캐시 내 전체 블록 수
<div align="center">
<img src="https://github.com/user-attachments/assets/2b5852f2-1792-48a1-8f8e-63268573e541">
</div>

   - 블록 번호 9는 캐시 블록 번호 (9 mod 8) = 1로 사상

2. 프로그램을 작성할 때 또는 컴파일러가 코드를 생성할 때 메모리 시스템의 동작을 무시하지 않아야 함
   - 성능 평가는 프로그래머가 메모리 시스템의 동작을 알고리즘 설계의 한 요인으로 포함시키면 성능을 쉽게 2배로 만들 수 있음

3. 캐시를 공유하는 코어나 스레드의 수보다 집합 연관 정도가 작은 공유 캐시를 갖지 않도록해야 함
   - $2^{n}$개의 프로세서나 스레드에서 실행되는 병렬 프로그램이 공유된 L2 캐시의 같은 집합으로 사상되는 주소에 자료구조들을 할당하기가 쉬움
   - 만약 캐시가 적어도 $2^{n}$-way 집합 연관 방식으로 되어 있다면, 이와 같이 우연히 발생할 수 있는 충돌은 하드웨어에 의해 프로그램이 모르게 할 수 있음
   - 그렇지 않을 경우, 가령 16-코어 설계에서 32-코어 설계로 넘어가려는데 두 구조 모두 16-way 집합 연관 방식의 L2 캐시를 사용한다면, 프로그래머가 도저히 이해할 수 없는 성능 하락을 경험하게 될 수 있음 (L2 캐시 대립 실패 때문에 발생)

4. 비순서 프로세서에서 메모리 계층 구조의 성능을 평가할 때 평균 메모리 접근 시간을 사용하지 말아야 함
   - 캐시 실패 동안 프로세서가 지연되면 메모리 지연시간과 프로세서 실행시간을 따로 계산할 수 있고, 평균 메모리 접근 시간을 사용하여 메모리 계층구조의 성능을 독립적으로 평가할 수 있음
   - 그러나 프로세서가 명령어를 계속 실행하고 캐시 실패 동안 더 많은 캐시 실패들을 계속 만들어내면, 메모리 계층 구조를 정확히 평가하는 유일한 방법은 메모리 께층 구조와 함께 비순서 프로세서를 시뮬레이션 하는 수 밖에 없음

5. 세그먼트 되지 않은 주소 공간 위에 세그먼트를 더해서 주소 공간을 확장하지 않아야 함
   - 1970년대에는 많은 프로그램들이 너무 커져서 16비트 주소로는 모든 데이터와 코드를 접근할 수 없게 되었음 : 이에 따라 세그먼트 되지 않은 32비트 주소 공간(단층 주소 공간(Flat Address Space)라고도 부름)을 사용하거나, 또는 기존의 16비트 주소 공간에 16비트 세그먼트를 추가하는 방식을 사용하여 컴퓨터들이 32비트 주소를 제공할 수 있도록 바뀜
   - 불행히도 큰 배열의 인덱스, 제한 없는 포인터, 참조 파라미터 등과 같이 한 세그먼트보다 더 큰 주소를 프로그래밍 언어가 사용하려고 할 때 문제가 발생
   - 게다가 세그먼트를 추가하면 모든 주소를 2워드(세그먼트 번호 한 워드와 세그먼트 변위 한 워드)로 바꾸어야 하므로 레지스터에서 주소를 사용할 때 문제 발생

6. 실제 디스크의 실패율은 명세서와 일치하지 않음 (오히려 큼)
7. 운영체제는 디스크 접근을 스케줄링하기에 최적의 정소가 아님
   - 상위 수준 디스크 인터페이스는 호스트 운영체제에 논리적 블록 주소를 제공
   - 주어진 상위 수준 추상화에서 OS가 성능 향상을 위해 할 수 있는 최선은 논리적 블록 주소를 오름차순으로 정렬하는 것
   - 그러나 디스크가 논리적 주소와 물리적 섹터 / 트랙 / 표면 간의 사상 관계를 알고 있으므로 스케줄링을 다시 함으로써 회전 지연과 탐색 지연을 줄일 수 있음
   - 예) 4개의 읽기
<div align="center">
<img src="https://github.com/user-attachments/assets/200d3986-b0c3-4e73-be75-46883638d3c1">
</div>

   - 4개의 읽기를 논리적 블록 순서대로 재정렬
<div align="center">
<img src="https://github.com/user-attachments/assets/c5512484-c94b-4d57-8ff3-df70f34b36e1">
</div>

   - 디스크에서 데이터의 상대적 위치에 따라 재정렬 : 더 좋지 않은 결과를 만들 수 있음
     + 디스크가 스케줄링하면 3/4회전 만에 마칠 수 있으나, OS가 스케줄링하면 3회전 필요
<div align="center">
<img src="https://github.com/user-attachments/assets/9a2fbe1f-2628-4132-8ce4-c453a3721d02">
</div>

8. 가상화가 가능하도록 설계한 것이 아닌 명령어 집합 구조에서 VMM을 구현하지 말아야 함
   - 가상화 문제를 일으키는 18개의 명령어
      + 제어 레지스터를 사용자 모드에서 읽는 명령어로, 손님 운영체제가 가상 머신에서 동작 중임을 드러냄
      + 세그먼트 구조의 요구대로 보호 검사하는 명령어로, 운영체제가 최상위 특권 수준에서 실행된다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/d77c0f49-4504-4765-a3cd-9279356766ea">
</div>

   - x86에서 VMM을 손쉽게 구현하기 위해 AMD와 Intel은 새로운 모드를 통한 구조 확장 제안
   - 하드웨어를 변경하는 것의 대안으로 문제 있는 컴퓨터 구조 부분을 사용하지 않도록 운영체제를 약간 수정하는 방법도 존재 : 이러한 기술을 반가상화(Paravirtualization)이라고 함

9. 하드웨어 공격은 보안을 위태롭게 하지 않음
    - 운영체제의 수 많은 소프트웨어 버그가 컴퓨터 시스템 공격자들으 주된 침투 수단이지만, DDR3 DRAM 칩의 약점을 이용해 가상 메모리 보안을 망가뜨릴 수 있음을 보임
    - DRAM 내부 2차원 구조와 DDR3 DRAM의 매우 작은 메모리 셀 때문에, DDR3 DRAM의 한 행에 반복적으로 쓰기를 하면 이웃 행에 교란 에러(Distribance Error)를 일으켜서 셀들의 값이 바뀔 수 있음
    - 행 집중 공격(Row Hammer)기술을 사용해 페이지 테이블 항목 보호 비트를 뒤집어 운영체제가 보호하려는 메모리 영역에 프로그램이 접근할 수 있도록 만들어, 그 후에 나온 마이크로프로세서와 DRAM은 행 집중 공격을 막을 수 있게 이를 탐지하는 메커니즘도 도입
  
