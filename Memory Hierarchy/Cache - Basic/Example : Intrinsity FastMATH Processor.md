-----
### 실제 캐시의 예 : Intrinsity FastMATH 프로세서
-----
1. MIPS 구조에 기반하지만 캐시를 단순하게 구현한 임베디드 마이크로프로세서
<div align="center">
<img src="https://github.com/user-attachments/assets/e0631e46-daf5-40c4-98ed-d9cc03d86a00">
</div>

2. 이 프로세서는 12단계 파이프라인을 가지고 있음
   - 프로세서가 최고 속도로 동작할 때는 매 클럭마다 명령어 1개와 데이터 워드 1개를 요청할 수 있음
   - 파이프라인의 메모리 요구를 지연 없이 충족시키기 위해 명령어 캐시와 데이터 캐시를 따로 두었으며, 각 캐시의 크기는 16 KiB(즉, 4096 워드)이고, 블록 크기는 16워드

3. 캐시에 대한 읽기 요청은 단순 : 데이터 캐시와 명령어 캐시가 분리되어 있으므로 각 캐시의 읽기 / 쓰기를 위한 제어 신호가 별도로 필요
   - 주소를 해당 캐시에서 보냄 : 주소는 PC(명령어의 경우)나 ALU(데이터 경우)에 나옴
   - 캐시 적중일 경우 요청한 워드가 캐시의 데이터 선에 나옴 : 읽어 낸 블록에는 16개의 워드가 존재하므로 요청한 워드를 선택하여야 함
     + 블록 변위 필드가 멀티플렉서 제어에 사용
     + 이 신호는 블록 내의 워드 16개 중에서 요청한 워드를 선택
   - 캐시 실패일 경우, 메인 메모리로 주소를 보냄 : 메모리가 데이터를 보내 주면, 캐시에 쓰고 난 뒤, 이를 읽어서 프로세서의 요청을 처리

4. Intrinsity FastMATH는 즉시 쓰기와 나중 쓰기 두 가지 방식을 다 지원
   - 어떤 방식을 사용할지는 운영체제가 선택하며, 한 항목만 담을 수 있는 쓰기 버퍼를 갖고 있음

5. 캐시의 실패율 - 명령어 캐시와 데이터 캐시의 실패율
<div align="center">
<img src="https://github.com/user-attachments/assets/6d6e4efd-4fb2-482e-a94e-997eecf28dac">
</div>

   - 조합 실패율은 명령어와 데이터 접근 각각 빈도수를 고려하여 계산한 유효 실패율
   - 실패율이 캐시 설계의 중요한 특성이지만, 궁극적 척도는 메모리 시스템이 프로그램 실행 시간에 미치는 영향

6. 분할 캐시(Split Cache) : 메모리 계층 구조의 한 계층이 병렬로 동작하는 2개의 독립적인 캐시로 구성되는 방식으로, 한 캐시는 명령어를 처리하고 다른 캐시는 데이터를 처리
   - 분할 캐시와 같은 크기를 갖는 통합 캐시(Combined Cache)는 일반적으로 더 좋은 적중률을 가짐
   - 통합 캐시는 데이터가 사용하는 엔트리와 명령어가 사용하는 엔트리의 수를 엄밀하게 나누지 않으므로, 더 높은 적중률을 얻을 수 있음
   - 그럼에도 불구하고 오늘날의 거의 모든 프로세서들이 파이프라인이 기대하는 만큼 캐시 대역폭을 늘리기 위해 명령어 캐시와 데이터 캐시를 따로 두고 있음
   - Intrinsity FastMATH 프로세서와 같은 크기의 분할 캐시 실패율과 두 캐시의 합과 같은 크기를 갖는 통합 캐시의 실패율
     + 전체 캐시 크기 : 32 KiB
     + 분할 캐시 유효 실패율 : 3.24%
     + 통합 캐시 실패율 : 3.18%

   - 분할 캐시의 실패율이 더 나쁘지만, 그 차이는 크지 않음
   - 명령어와 데이터 접근을 동시에 지원함으로써 캐시 대역폭을 2배로 늘려서 얻는 장점이 실패율이 약간 증가되는 단점보다 큼
   
