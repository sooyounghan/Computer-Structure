-----
### 쓰기의 처리
-----
1. 저장 명령을 가정
   - 데이터를 데이터 캐시에만 쓰고, 메인 메모리에 쓰지 않으면, 메인 메모리는 캐시와 다른 값을 가지게 됨
   - 이 경우 캐시와 메모리가 불일치(Inconsistent)한다고 말함
   - 메인 메모리와 캐시를 일치시키는 가장 쉬운 방법은 항상 데이터를 메모리와 캐시에 같이 쓰는 것 : 이 방법을 즉시 쓰기(Write-Through)라고 함
     + 즉시 쓰기 : 쓰기가 항상 캐시와 다음 하위 계층을 동시에 갱신하는 방식으로, 항상 두 계층의 데이터가 일치함을 보장해줌

2. 쓰기의 다른 중요 측면은 쓰기 실패 시 어떤 일이 발생하는가임
   - 먼저 메모리에서 해당 워드가 포함된 블록을 가져와서 캐시에 넣은 뒤, 워드에 새로운 값을 씀
   - 또한, 전체 주소를 사용해 이 워드를 메인 메모리에도 씀
   - 이 방식이 쓰기를 매우 간단히 처리하기는 하지만 좋은 성능을 제공하기는 어려움
   - 즉시 쓰기 방식에서는 모든 쓰기가 메인 메모리에 데이터를 써야만 함
     + 이 쓰기는 시간이 오래 걸려서 최소한 100개의 프로세서 클럭 사이클이 필요한 경우가 많고, 따라서 프로세서의 성능을 심하게 저하시킴
     + 예를 들면, 명령어의 10%가 저장 명령어라고 가정하고, 캐시 실패가 없으면 CPI가 1.0이고, 모든 쓰기에 100개의 추가 사이클이 필요하다면, CPI는 1.0 + 100 X 10% = 11이 되어 10배 이상 성능 저하가 발생

3. 이 문제를 해결하기 위한 한 가지 방법은 쓰기 버퍼(Wrtie Buffer)를 이용하는 것
   - 쓰기 버퍼 : 메모리에 쓰이기 위해 기다리는 동안 데이터를 저장하는 큐
   - 쓰기 버퍼는 데이터와 메모리가 써질 때까지 기다리는 동안 데이터를 저장
   - 데이터를 캐시와 쓰기 버퍼에 쓰고 난 후에 프로세서는 바로 수행을 계속할 수 있음
   - 메인 메모리에 쓰기를 완료하면 쓰기 버퍼의 엔트리는 지워짐
   - 프로세서가 쓰기를 하려고 할 때, 쓰기 버퍼가 모두 차 있으면 쓰기 버퍼에 빈 공간이 생길 때까지 멈춰있어야 함
   - 물론, 메모리가 쓰기를 완료할 수 있는 속도가 프로세서의 쓰기 동작 발생 속도보다 느리면, 아무리 큰 버퍼를 사용해도 도움이 되지 않음 : 메모리 시스템이 쓰기를 받아들이는 것보다 쓰기가 더 빨리 발생되기 떄문임

4. 쓰기 발생 속도가 메모리가 받아들이는 속도보다 느려도 지연이 발생할 수 있음
   - 이런 현상은 쓰기가 폭주할 때 발생하며, 이러한 지연이 일어나는 것을 줄이기 위해 프로세서의 쓰기 버퍼 엔트리는 보통 2개 이상임

5. 즉시 쓰기 방식의 대안은 나중 쓰기(Write-Back)라고 불리는 방식
   - 나중 쓰기 : 쓸 때는 캐시 블록의 값만 갱신하고, 나중에 그 블록이 교체될 때 하위 계층 메모리에 변경된 블록을 쓰는 방식
   - 나중 쓰기 방식은 쓰기가 발생했을 때, 새로운 값은 캐시 내 블록에만 씀
   - 그러다가 나중에 캐시에서 쫓겨날 때 쓰기에 의해 변경된 내용이 있으면 이 블록을 하위 메모리 게층에 씀
   - 나중 쓰기 방식은 성능을 향상시킬 수 있으며, 특히 메인 메모리가 처리할 수 있는 속도와 같은 속도 또는 더 빠른 속도로 프로세서가 쓰기를 발생시키는 경우 효과적
   - 그러나 나중 쓰기 방식은 즉시 쓰기 방식보다 구현이 더 복잡

6. 쓰기는 읽기에는 없는 여러 복잡한 문제 야기
   - 즉시 쓰기 캐시의 실패
     + 가장 일반적인 방법은 캐시에 블록을 할당하는 것인데, 이를 쓰기 할당(Write Allocate)이라고 부름 : 일단 전체 블록을 메모리에서 읽어온 후, 블록 중에서 쓰기 실패를 발생시킨 워드만 덮어 씀
     + 다른 방법은 메모리에 있는 블록의 해당 부분만 갱신하고 캐시에 쓰지 않는 방식으로 쓰기 비할당(No Write Allocate)라고 부름 : 이 방식이 나오게 된 동기는 프로그램이 때때로 데이터 블록을 통째로 바꾸는 일이 발생하기 때문임
       * 예를 들면, 운영체제가 메모리의 한 페이지를 모두 0으로 만드는 것과 같은 경우
       * 이 경우, 쓰기 실패가 처음 발생했을 때 이 블록을 캐시로 가져올 필요가 없음 (어떤 컴퓨터들은 페이지마자 쓰기 할당 정책을 다르게 하는 것을 허용)

   - 실제로 나중 쓰기 방식 캐시에서 저장 명령어를 효과적으로 구현하는 것은 즉시 쓰기 방식보다 더욱 복잡
     + 즉시 쓰기 캐시는 데이터를 캐시에 쓰고 태그 값을 읽을 수 있음
     + 이 때, 태그가 일치하지 않으면 캐시 실패이며, 즉시 쓰기 캐시에서는 캐시 블록에 바로 덮어 써도 지워진 블록의 정확한 값이 메모리에 있기 때문에 문제가 되지 않음
     + 나중 쓰기 방식에서는 값이 바뀐 캐시 블록에 대해 실패가 발생하면, 그 블록을 먼저 메모리에 써야 함
     + 캐시 적중이 확인되기도 전 저장 명령어가 캐시 블록에 덮어 쓰면(즉시 쓰기 방식처럼), 하위 계층 메모리에 저장되지 않은 블록을 망가뜨려 그 내용을 잃게 됨

   - 나중 쓰기 캐시는 블록에 바로 덮어 쓸 수 없기 때문에, 저장 명령어가 두 사이클(적중인지를 확인하는 데 한 사이클, 실제로 쓰는 데 한 사이클) 걸리게 하거나 데이터를 보관하는 저장 버퍼(Store Buffer)를 사용해야 함
     + 저장 버퍼는 쓰기 과정을 파이프라인화해서 저장 명령어가 한 사이클만 걸리게 해 줌
     + 저장 버퍼를 사용하면 정상적인 캐시 접근 사이클에 프로세서가 캐시를 검색하고, 데이터를 저장 버퍼에 넣음
     + 검색 결과가 캐시 적중으로 밝혀지면, 사용되지 않는 캐시 접근 사이클이 나올 때까지 새로운 데이터를 저장 버퍼에 꺼내 캐시에 씀

   - 반면에 즉시 쓰기 캐시에서는 쓰기가 항상 한 사이클에 수행
     + 태그를 읽고 선택된 블록의 데이터 영역에 쓰는 것을 한 사이클에 할 수 있기 떄문임
     + 태그가 블록의 주소와 일치하면 맞는 블록을 갱신한 것이므로 프로세서는 정상적으로 실행을 계속함
     + 하지만 태그가 일치하지 않으면 프로세서는 쓰기 실패를 발생시켜서 그 주소에 해당하는 블록의 나머지 부분 일치

   - 나중 쓰기 캐시들 중에서 실패가 발생해서 값이 바뀐 블록을 교체할 때 생기는 실패 손실을 줄이기 위해 쓰기 버퍼를 사용하는 것이 많음
     + 이 경우 요청한 블록을 메모리에서 읽는 동안, 값이 바뀐 캐시 블록을 나중 쓰기 버퍼로 보냈다가 나중에 메모리에 씀
     + 다른 실패가 즉시 발생하지 않는다면, 이 기법은 갱신된 블록이 교체될 때의 실패 손실을 절반으로 줄일 수 있음
