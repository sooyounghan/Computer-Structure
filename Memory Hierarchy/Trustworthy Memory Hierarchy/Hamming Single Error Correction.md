-----
### Hamming 단일 에러 정정, 이중 에러 검출(SEC / DED) 코드
-----
1. Richard Hamming은 메모리에 널리 사용되는 여유분 기법을 발명
   - 여유분 코드를 만들려면 유효한 비트 패턴들이 얼마나 가까운지 살펴보는 것이 중요
   - Hamming 거리(Hamming Distance)는 유효한 두 비트 패턴에서 같은 위치의 비트 중 값이 서로 다른 것의 개수를 의미
     + 예) 011011과 001111의 거리는 2
     + 원소들 간 최소 거리가 2인 코드에서 한 비트 에러가 발생할 경우 : 이 에러는 코드의 유효한 패턴을 잘못된 패턴으로 바꿀 것이므로 코드의 원소가 유효한지 아닌지를 검사할 수 있다면, 한 비트 에러를 검출할 수 있고 이것을 단일 비트 에러 검출 코드(Error Detection Code)라고 말할 수 있음
       * 에러 검출 코드 : 데이터의 에러 1개를 검출할 수 있는 코드로, 에러의 정확한 위치를 알 수 없고 따라서 에러를 고칠 수 없음

2. Hamming은 에러 검출을 위해 패리티 코드(Parity Code)를 사용
   - 패리티 코드에서는 워드 내 1이 몇 개인지 세어서, 1의 개수가 홀수이면 홀수 패리티를 갖는다고 하고, 짝수 개이면 짝수 패리티를 갖는다고 말함
   - 워드를 메모리에 쓸 때 패리티 비트(짝수 패리티 시스템이라면, 워드가 홀수 패리티 일 때 1, 짝수 패리티일 때 0)도 함께 씀
   - 이렇게 하면 N + 1비트의 패리티는 항상 짝수가 됨
   - 워드를 읽을 때는 패리티 비트도 같이 읽어서 검사해야 하며, 메모리 워드의 패리티가 저장된 패리티 비트와 다르면 에러가 발생한 것

3. 예) 한 바이트로 표현된 숫자 31의 패리티를 계산하고 메모리에 저장되는 패턴 (패리티 비트는 오른쪽에 있다고 가정하며)이 존재하며, 최상위 비트(MSB)가 메모리 내에서 바뀌었는데, 그 값을 읽었다고 가정하면 에러를 검출할 수 있는가? 최상위 두 비트가 바뀌었다면 어떻게 되는가?
   - 31 : $00011111_{2}$이므로 5개의 1이 있음
     + 패리티를 짝수로 하려면 패리티 비트에 1을 써서 $000111111_{2}$로 만들어야 함
   - 만약 MSB가 바뀌었으면, $100111111_{2}$를 읽게 되어 1이 7개가 됨
     + 짝수 패리티를 기대하였으나 홀수 패리티가 계산되므로 에러 발생
     + 만약 최상위 두 비트가 바뀌었다면 $110111111_{2}$가 되어 1이 8개가 되므로, 짝수 패리티가 되므로 에러를 검출할 수 없음

4. 두 비트의 에러가 있으면 한 비트 패리티 방식은 에러를 검출하지 못함
   - 에러가 2개 발생하면 패리티가 정상적인 값과 일치하기 때문임 (실제로 한 비트 패리티 방식은 에러의 개수가 홀수 개라면 몇 개가 발생하더라도 검출할 수 있지만, 에러가 3개 생길 확률은 2개 생길 확률보다 훨씬 낮기 때문에, 실용적으로는 한 비트 패리티 코드는 한 비트 에러만 검출하는 것으로 생각)
   - 패리티 코드로는 에러를 정정할 수 없는데, Hamming은 검출뿐만 아니라 정정까지 가능한 코드를 원함
     + 최소 거리가 3인 코드를 사용하면, 단일 비트 에러가 생긴 코드는 다른 어떤 유효한 패턴보다 원래의 옳은 패턴과 더 가까울 것
   - Hamming은 데이터를 거리 3인 코드로 사상하는 알기 쉬운 방법을 생각해냈는데, 이를 Hamming 에러 검출 코드(Hamming Error Correction Code, ECC)라고 부름
     + 단일 에러의 위치를 파악할 수 있도록 패리티 비트를 더 많이 사용

5. Hamming ECC 계산하는 방법
   - 가장 오른쪽 비트 번호를 0으로 하는 대신, 왼쪽부터 1로 번호를 매김
   - 번호가 2의 거듭제곱에 해당하는 모든 비트(위치 1, 2, 4, 8, 16, ...)를 패리티 비트로 함
   - 다른 비트 위치는 모두 데이터 비트로 사용 (위치 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, ... )
   - 패리티 비트의 위치에 따라 검사하는 데이터 비트가 결정
<div align="center">
<img src="https://github.com/user-attachments/assets/15fb52d8-6d91-4563-8e51-26a13224e130">
</div>

   - 비트 1($0001_{2}$)은 비트 (1, 3, 5, 7, 9, 11, ...) 의 패리티 : 번호의 맨 오른쪽 비트가 1인 것 ($0001_{2}$, $0011_{2}$, $0101_{2}$, $0111_{2}$, $1001_{2}$, $1011_{2}$ ...)
   - 비트 2($0010_{2}$)은 비트 (2, 3, 6, 7, 10, 11, 14, 15, ...)의 패리티 : 번호의 오른쪽에서 두 번째 비트가 1인 것들
   - 비트 4($0100_{2}$)은 비트 (4 ~ 7, 12 ~ 15, 20 ~ 23, ...)의 패리티 : 번호의 오른쪽에서 세 번째 비트가 1인 것들
   - 비트 8($1000_{2}$)은 비트 (8 ~ 15, 24 ~ 31, 40 ~ 47, ...)의 패리티 : 번호의 오른쪽에서 네 번째 비트가 1인 것들
     + 모든 데이터 비트는 2개 이상 패리티 비트 계산에 참여함

   - 각 그룹이 짝수 패리티가 되도록 패리티 값 결정

6. 위 그림의 12비트 코드에서 4개의 패리티 계산 결과(p8, p4, p2, p1)가 0000이면 에러가 없는 것
   - 그러나 0000이 아니고 예를 들어 1010(10)이면 10번 비트(d6)가 에러라고 Hamming ECC가 알려주는 것
   - 이진수는 0이 아니면 1이므로, 10번 비트를 반대로 하면 에러 정정 가능

7. 예) 1바이트 데이터 값이 $10011010_{2}$라고 가정하고, 먼저 이 데이터에 대한 Hamming ECC를 보이고, 비트 10을 반대로 바꾼 다음 ECC가 단일 비트 에러를 찾아서 정정하는 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/c692812a-ac4b-4b47-ba61-4e7e9748b4be">
</div>
