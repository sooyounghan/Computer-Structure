-----
### 단일 에러 정정 / 이중 에러 검출(SEC / DED)
-----
1. Hamming은 단일 비트 에러 정정 코드에서 멈추지 않고, 한 비트를 더 사용하면 코드의 최소 Hamming 거리를 4로 만들 수 있는데, 이를 이용해 단일 비트 에러를 정정하고 이중 비트 에러를 검출할 수 있음
2. 이를 위해 전체 워드에 대한 패리티 한 비트를 추가
3. 예) 4비트 데이터 워드
   - 이 경우 7비트만 있으면 단일 비트 에러 검출이 가능
   - Hamming 패리티 비트 H(p1, p2, p3)를 계산하고(늘 그렇듯이 짝수 패리티 사용) 전체 워드에 대한 짝수 패리티 p4를 께산
<div align="center">
<img src="https://github.com/user-attachments/assets/5e698c90-42d8-4e9d-a808-a0e9c37ff15a">
</div>

   - 1개의 에러를 정정하고 2개를 검출하려면 전과 같이 ECC 그룹(H)에 대해 패리티를 계산하고 전체 그룹에 대한 패리티($p_{4}$)를 하나 더 계산하면 됨

4. 네 가지 경우 존재
   - H가 짝수이고, $p_{4}$도 짝수이면, 에러 없음
   - H가 홀수이고, $p_{4}$도 홀수이면, 정정 가능한 1개의 에러가 발생 (에러가 하나 발생하면 $p_{4}$는 홀수 패리티)
   - H가 짝수이고, $p_{4}$가 홀수이면, $p_{4}$ 비트에 단일 에러가 발생할 것이므로, $p_{4}$ 비트 정정
   - H가 홀수이고, $p_{4}$가 짝수이면, 에러가 2개 발생 (에러가 2개 발생하면, $p_{4}$는 짝수 패리티가 됨)

5. 단일 에러 정정 / 이중 에러 검출(SEC / DED)은 오늘날 서버용 메모리에 널리 사용
   - 8바이트 크기 블록은 SEC / DED 때문에 한 바이트가 더 필요
   - 그래서 크기가 72비트인 DIMM이 많음

6. p + d 비트 워드에서는 p는 전체 패리티 비트 수, d는 데이터 비트 수라고 가정할 때, SEC를 위해 얼마나 많은 비트가 필요한지 계산
   - p개의 에러 정정 비트로 에러가 발생하지 않은 경우와 에러가 발생한 경우를 구별하고, 에러가 발생했을 경우 에러 발생 위치(p + d 비트 중 하나)를 표시하려면 다음을 만족해야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/c7c6c7f5-a902-4e03-8bdb-67552929d731">
</div>

   - 예를 들어 8비트 데이터는 d = 8이고, $2^{p} ≥ p + 8 + 1$이므로 p = 4
   - 마찬가지로 16비트 데이터에서는 p = 5이고, 32비트 데이터에서는 p = 6, 64비트 데이터에서는 p = 7

7. 아주 큰 시스템에서는 여러 개의 에러가 동시에 발생하는 것만큼이나 큰 메모리 칩 하나가 통째로 동작하지 않는 것이 중요한 문제가 되었음
   - IBM은 이 문제를 해결하기 위해 칩킬(ChipKill)을 도입하였고, 많은 대형 시스템들이 이 기술을 상요하고 있음 (Intel은 SDDC이라고 부름)
   - 디스크에서 사용되는 RAID 방식과 같이 칩킬은 데이터와 ECC 정보를 분산시켜서 칩 하나가 통째로 동작하지 않더라도 나머지 메모리 칩으로부터 잃어버린 데이터를 복원할 수 있도록 해줌
   - 프로세서가 10,000개 있고 프로세서마다 4 GiB 메모리가 있는 클러스터가 3년 동안 동작할 때, 복구할 수 없는 메모리 에러 발생률에 대한 IBM의 계산
     + 패리티만 사용할 경우 : 매 17분마다 약 90,000개 장애, 또는 1개의 복구할 수 없는(또는 검출할 수 없는) 장애 발생
     + SEC / DED만 사용할 경우 : 매 7.5시간마다 약 3500개 장애, 또는 1개의 검출할 수 없거나 복구할 수 없는 장애 발생
     + 칩킬 : 2개월마다 6개 장애, 또는 1개의 검출할 수 없거나 복구할 수 없는 장애 발생

   - 그러므로 칩킬은 창고 규모 컴퓨터에서는 필수적 기술

8. 메모리 시스템에서는 1개 또는 2개의 비트 에러 발생이 일반적이지만 네트워크에서는 한꺼번에 대량 비트 에러 발생 가능
   - CRC(Cyclic Redundancy Check)라는 방법이 존재 : k 비트 블록에 대해 전송기는 n - k 비트 프레임 검사 시퀀스를 만들어, 미리 정해진 어떤 숫자로 딱 나누어지는 n 비트를 전송
   - 수신기는 그 숫자로 프레임으로 나누고, 나머지가 없으면 에러가 없다고 보며, 있으면 수신기는 메시지를 버리고 송신기에 재전송을 요청
   - 어떤 이진수의 나눗셈은 시프트 레지스터를 이용해 쉽게 계산할 수 있으므로, 하드웨어가 비쌌던 시절에도 CRC 코드는 많이 사용
   - 더 복잡한 Reed-Solomon 코드는 여러 비트의 전송 에러를 정정하기 위해 Galois 필드 이용 : 여기서는 데이터가 다항식 계수로 간주되어 다항식의 값이 코드 공간이 됨
     + 이 계산은 이진 나눗셈보다 훨씬 복잡
