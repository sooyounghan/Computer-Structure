-----
### 다단계 캐시를 이용한 실패 손실 줄이기
-----
1. 현대의 모든 컴퓨터는 캐시를 사용
   - 프로세서의 빠른 클럭 속도와 상대적으로 점점 느려지는 DRAM 접근 시간 차이를 줄이기 위해 대부분 마이크로프로세서는 캐시를 한 계층 더 지원하는데, 이를 2차 캐시(Secondary Cache)라고 함
   - 이 2차 캐시는 보통 마이크로프로세서와 같은 칩에 잇으며, 1차 캐시(Primary Cache)에서 실패가 발생하면 접근
   - 2차 캐시가 원하는 데이터를 갖고 있으면 실패 손실은 2차 캐시의 접근시간이 되며, 이 값은 메인 메모리 접근시간보다 훨씬 짧음
   - 1차 캐시와 2차 캐시 둘 다 데이터를 갖고 있지 않은 경우 메인 메모리 접근이 필요하게 되어 더 큰 실패 손실이 발생

2. 예) 다단계 캐시의 성능
   - 클럭 속도가 4 GHz이고, 모든 참조가 1차 캐시에서 적중된다고 가정했을 때 기본 CPI가 1.0인 프로세서를 가정
     + 실패 처리를 포함하여 메인 메모리 접근시간이 100 ns이고, 1차 캐시에서 명령어 하나당 실패율이 2%라고 가정
     + 접근 시간이 5ns인 2차 캐시를 충분히 많이 추가하여 메인 메모리까지 가야하는 실패의 비율을 0.5%로 낮출 수 있으면 프로세서가 빨라지는 정도

   - 메인 메모리로 가는 경우의 실패 손실
<div align="center">
<img src="https://github.com/user-attachments/assets/59674bdd-90ac-45e7-ac4b-16e6ccffbc5b">
</div>

   - 캐시가 한 계층만 잇는 경우 유효 CPI
<div align="center">
<img src="https://github.com/user-attachments/assets/119b72a7-dfc0-49bc-aca3-c22140a87452">
</div>

   - 2차 캐시가 있을 때 1차 캐시 실패가 2차 캐시에서 처리될 수도 있고, 메인 메모리에서 처리될 수 있음 : 2차 캐시 접근에 따른 실패 손실
<div align="center">
<img src="https://github.com/user-attachments/assets/62adbae5-6e9c-476a-8fc3-39a28452d2ae">
</div>

   - 만약 실패가 2차 캐시에서 처리되면 이 값이 전체 실패 손실이 됨
   - 하지만 메인 메모리까지 가서 실패를 처리하게 되면 전체 실패 손실은 2차 캐시 접근시간과 메인 메모리 접근 시간의 합이 됨
   - 따라서 2단게 캐시에서 전체 CPI는 두 캐시에서 발생하는 지연 사이클과 기본 CPI의 합
<div align="center">
<img src="https://github.com/user-attachments/assets/e2233e34-ee03-42be-995b-658e4b358cae">
</div>

   - 따라서 2차 캐시를 갖는 프로세서는 다음과 같이 빨라지게 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/3ccecad0-4655-4362-8a32-8058c3d3d579">
</div>

   - 다음과 같이 다른 방식으로 계산이 가능
     + 2차 캐시에서 적중된 참조의 지연 사이클은 (2% - 0.5%) X 20 = 0.3
     + 메인 메모리까지 내려간 참조의 지연 사이클은 2차 캐시 접근 시간과 메인 메모리 접근 시간을 포함해야 함 : (0.5%) X (20 + 400) = 2.1
     + 그러므로 이들은 다 합한 전체 CPI는 1.0 + 0.3 + 2.1 = 3.4

3. 1차 캐시와 2차 캐시의 설계 고려사항은 매우 다름
   - 캐시가 하나밖에 없는 단일 계층 캐시와 달리 다른 캐시가 또 있으므로 최적의 선택이 달라짐
   - 1차 캐시 설계는 클럭 사이클의 단축이나 파이프라인 단계의 축소가 가능하도록 적중 시간 최소화에 초점을 맞추고, 2차 캐시 설계는 긴 메모리 접근시간으로 인한 손실을 줄이도록 실패율에 중점을 둠

4. 각 캐시를 단일 계층 캐시의 최적 설계와 비교해보면 이러한 변화가 두 캐시에 미치는 영향을 알 수 있음
   - 단일 캐시와 비교할 때 다단계 캐시(Multi-Level Cache)의 1차 캐시는 대개 더 작음
     + 다단계 캐시 : 단지 하나의 캐시와 메인 메모리로만 구성된 것이 아니라 여러 단계의 캐시를 갖는 메모리 게층 구조
   - 게다가 1차 캐시는 크기를 작게 하고, 실패 손실을 줄이기 위해 블록 크기가 작음
   - 반면에 2차 캐시는 단일 캐시와 비교할 때 접근시간이 덜 중요하므로 크기가 훨씬 더 큼
   - 따라서 단일 캐시에 적절한 블록 크기보다 더 큰 블록을 사용할 수 있음
   - 2차 캐시는 실패율을 줄이는 데 집중해야 하므로 1차 캐시보다 더 높은 연관 정도가 많이 사용

5. 더 좋은 정렬 알고리즘을 찾기 위해 많은 노력을 기울인 결과 버블(Bubble) 정렬, 퀵(Quick) 정렬, 기수(Radix) 정렬 등 여러 알고리즘이 개발
<div align="center">
<img src="https://github.com/user-attachments/assets/a62fbbfd-bd5b-43c2-bb49-e7622bede93c">
</div>

   - 5.19(a) : 기수 정렬과 퀵 정렬에 의해 실행된 명령어 수
     + 큰 배열에서는 기수 정렬이 퀵 정렬에 비해 연산 횟수가 적다는 장점이 존재
   - 5.19(b) : 실행 명령어 대신 실행 시간을 보여줌
     + 처음에는 5.19(a)와 같은 궤적을 갖고 시작하지만, 입력 데이터가 많아지면 기수 정렬의 궤적이 달라짐을 알 수 있음
   - 5.19(c) : 정렬되는 항목당 캐시 실패 횟수를 보여줌
     + 퀵 정렬이 항상 더 적은 캐시 실패를 발생시킴

   - 표준 알고리즘 분석 방법은 메모리 계층 구조의 영향을 무시하는 경우가 많음
