-----
### 더 유연한 블록 배치를 통한 캐시 실패 줄이기
-----
1. 지금까지는 메모리 블록을 캐시에 넣을 때 각 블록이 캐시의 딱 한 곳에만 들어갈 수 있는 단순한 배치 방법 사용
   - 이 방법은 메모리 블록 주소를 상위 계층의 한 주소로 바로 사상시키므로 직접 사상(Direct Mapping)이라 부름
   - 하지만 실제로는 블록을 배치하는 다양한 방식이 존재하는데, 그 중 한 극단적 방법이 블록을 한 곳에만 넣을 수 있는 직접 사상 방식

2. 반대쪽 극단에는 블록이 캐시 내의 어느 곳에나 들어갈 수 있는 방식
   - 메모리 블록을 캐시 내 어떤 엔트리와도 연관시킬 수 있으므로 이를 완전 연관(Fully Associative) 방식이라 부름
     + 완전 연관 : 블록이 캐시 어느 곳에나 들어갈 수 있는 캐시 구조
   - 완전 연관 캐시에서는 블록이 어느 곳에나 있을 수 있으므로, 주어진 블록을 찾으려면 캐시 내 모든 엔트리를 검색해야 함
   - 검색이 실용성이 있으려면 각 캐시 엔트리와 연결된 비교기를 이용해 병렬로 검색해야 함
     + 이 비교기가 하드웨어 비용을 크게 증가시키므로 완전 연관 방식은 블록이 몇 개 안되는 작은 캐시에서만 사용 가능

3. 직접 사상과 완전 연관 사상의 중간 지대에 집합 연관(Set Associative) 방식이 존재
   - 집합 연관 : 각 블록이 들어갈 수 있는 장소의 개수가 정해져 있는(적어도 한 곳 이상) 캐시
   - 즉, 집합 연관 사상 캐시에서는 한 블록이 들어갈 수 있는 자리의 개수가 고정되어 있음
   - 각 블록당 n개의 배치 가능한 위치를 갖는 집합 연관 캐시를 n-way 집합 연관 캐시라고 부름
     + n-way 집합 연관 캐시는 다수의 집합들로 구성되어 있는데, 각 집합에는 n개의 블록이 존재
     + 메모리의 각 블록은 인덱스 필드에 의해 캐시 내 한 집합으로 사상되고, 선택된 집합 내에서는 아무 장소나 들어갈 수 있음
   - 따라서 집합 연관 사상 방식은 직접 사상 방식과 완전 연관 사상 방식을 조합한 것이라고 볼 수 있음
   - 블록을 한 집합에 직접 사상한 후, 집합 내 모든 블록을 검색해 일치하는 것을 찾음

4. 예) 전체 8개의 블록으로 구성된 캐시에 세 가지 블록 배치 방법을 적용했을 때 블록 12가 어디에 들어가는 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/17485fa6-9a37-4460-a08f-0e09da1a1d03">
</div>

   - 직접 사상 캐시 내에서 메모리 블록의 위치 : (블록 번호) modulo (캐시 내 블록 수)
   - 집합 연관 캐시에서 어떤 블록을 갖고 있는 집합 : (블록 번호) modulo (캐시 내 집합 수)
     + 블록이 집합 내 어느 곳에서나 있을 수 있으므로, 집합 내 모든 태그를 다 검색해야 함
   - 완전 연관 캐시에서는 블록이 어느 곳에서나 위치할 수 있으므로, 캐시 내 모든 블록 태그를 다 검색해야 함

5. 모든 블록 배치 방식을 집합 연관 방식의 변형이라 생각할 수 있음
   - 8개 블록 캐시에서 가능한 연관 정도(Asscoiativity) 구조를 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/66d38ad5-c86b-496c-bd13-7563a64ae02c">
</div>

   - 직접 사상 캐시는 단순히 1-way 집합 연관 캐시 : 각 캐시 엔트리는 한 블록을 원소로 갖는 집합으로 구성
   - m개의 엔트리로 구성된 완전 연관 캐시는 간단히 m-way 집합 연관 캐시라고 볼 수 있음 : m개의 블록으로 구성된 집합이 단 1개 있어서 엔트리는 집합 내 어느 블록에도 들어갈 수 있음

6. 연관 정도를 늘리는 것의 장점은 대개 실패율을 줄어든다는 것이며, 가장 큰 단점은 적중 시간의 증가
7. 예) 실패와 캐시의 연관정도
   - 1워드 크기의 블록 4개로 구성된 세 종류의 캐시가 존재
     + 하나는 완전 연관 방식
     + 다른 하나는 2-way 집합 연관 방식
     + 나머지는 직접 사상 방식

   - 블록 주소 0, 8, 0, 6, 8 순으로 블록을 참조할 때 각 캐시 구성에서 실패 발생
   - 직접 사상 캐시의 경우
     + 각 블록 주소가 어느 캐시로 사상되는지 확인
<div align="center">
<img src="https://github.com/user-attachments/assets/dc776204-e8ed-4612-92ac-863271b4d517">
</div>

   - 각 참조 후 캐시 내용을 채울 수 있으며, 빈칸은 블록이 휴효하지 않음을 나타내고, 파란색 글씨는 캐시에 추가된 새로운 엔트리를 보여줌 (흑백 항목은 전부터 있던 엔트리)
<div align="center">
<img src="https://github.com/user-attachments/assets/33473fb6-567e-4d4c-a624-1214a4c28b10">
</div>

   - 직접 사상 캐시는 5번의 접근 시도에 5번의 실패가 발생
   - 집합 연관 캐시에는 집합이 2개(인덱스 0과 1)이 있고, 각 집합에는 2개의 원소가 존재
<div align="center">
<img src="https://github.com/user-attachments/assets/7552d374-697d-437d-8672-0632f88999fc">
</div>

   - 실패 시 집합 내 교체할 엔트리의 선정을 위해서는 교체 방식을 정해야 함
     + 집합 연관 캐시는 대개 집합 내 사용한지 가장 오래된 블록을 교체시키는 LRU(Least Recently Used) 교체 방식을 사용 : 즉, 가장 먼 과거에 사용된 블록이 교체
     + LRU 교체 방식을 사용하면, 각 참조 후 집합 연관 캐시의 내용은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/cef7548a-4e6f-4df1-bb80-61d625c7dfa0">
</div>

   - 블록 6이 참조될 때, 블록 8이 교체 : 블록 8이 블록 0보다 더 오랫동안 참조되지 않았음
   - 2-way 집합 연관 캐시에서는 전부 4번의 실패가 발생하여, 직접 사상 캐시 보다 한 번 적음
   - 완전 연관 캐시는 4개의 캐시 블록으로 구성된 1개의 집합을 가짐 : 즉, 어떠한 메모리 블록도 캐시 내 어느 블록에나 적재 가능
     + 실패가 세 번만 발생하여 가장 성능이 좋음
<div align="center">
<img src="https://github.com/user-attachments/assets/6cff1c60-ebed-4e6d-9ddc-67bfc8a7cabd">
</div>

   - 이 참조는 세 가지 블록 주소를 사용하므로 세 번의 실패가 할 수 있는 최선
   - 만약, 캐시에 블록이 8개 있다면, 2-way 집합 연관 캐시의 경우 교체는 발생하지 않음 : 따라서, 완전 연관 캐시와 실패 횟수가 같게 됨
   - 마찬가지로 블록이 16개 있다면, 이 3 캐시는 모두 같은 개수의 실패를 가짐
   - 이 예제에서 캐시의 크기와 연관 정도가 독립적으로 캐시의 성능을 결정하지 못함

8. 실패율이 연관 정도에 의해 줄어드는 정도
<div align="center">
<img src="https://github.com/user-attachments/assets/2708c7f9-8c84-4957-8815-2d10ad8c6921">
</div>

   - 연관 정도가 달라질 떄 16워드 블록으로 구성된 64 KiB 데이터 캐시의 실패율이 개선되는 정도를 보여줌
   - 1-way에서 2-way 집합 연관 방식으로 바꾸면 실패율이 약 15% 정도 개선
   - 그러나 연관 정도를 더 높였을 때 개선 정도가 미미함
