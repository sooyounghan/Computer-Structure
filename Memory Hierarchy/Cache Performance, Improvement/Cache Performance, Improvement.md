-----
### 캐시 성능 측정 및 향상
-----
1. 캐시 성능을 측정하고 분석하는 방법
   - 2개의 다른 메모리 블록이 캐시의 같은 장소를 두고 경쟁하는 확률을 줄임으로써 실패율을 낮추는 것
   - 메모리 계층 구조에 새로운 계층을 추가함으로써 실패 손실을 줄이는 것 : 다단계 캐싱(Multi-Level Caching)
   - 다단계 캐싱이라고 불리는 이 방식은 1990년도에 고급 컴퓨터에 처음 사용되었으나, 나중에는 개인 휴대용 기기에서도 흔히 볼 수 있음

2. CPU 시간은 CPU가 프로그램을 수행하는 데 쓴 클럭 사이클과 메모리 시스템을 기다리는 데 쓴 클럭 사이클로 나눌 수 있음
   - 일반적으로 적중된 캐시 접근 시간은 정상적인 CPU 수행 사이클의 일부로 간주
<div align="center">
<img src="https://github.com/user-attachments/assets/362b8492-d57f-42d3-8c92-36b46b8182db">
</div>

   - 메모리 지연 클럭 사이클은 주로 캐시 실패 때문에 생김
   - 실제 프로세서에서 읽기와 쓰기 수행 시 발생되는 지연은 상당히 복잡해질 수 있어서, 정확하게 성능을 예측하려면 프로세서와 메모리 시스템의 시뮬레이션이 필요

3. 메모리 지연 클럭 사이클은 읽기와 쓰기 시에 발생하는 지연 사이클의 합으로 정의 : 메모리 지연 클럭 사이클 = 읽기 지연 사이클 + 쓰기 지연 사이클

4. 읽기 지연 사이클은 프로그램 당 읽기 접근의 수, 읽기 시의 실패 손실 클럭 사이클 수, 읽기 실패율에 의해 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/0f22438d-ace3-4772-b37b-fd3645490853">
</div>

5. 쓰기의 경우 복잡함
   - 즉시 쓰기 방식에서 지연의 원인이 두 가지
     + 하나는 쓰기 실패로, 쓰기를 계속 진행하려면 하위 계층 메모리에서 블록을 읽어와야 함
     + 다른 하나는 쓰기 버퍼 지연으로, 쓰려고 할 때 쓰기 버퍼에 빈자리의 경우가 없는 경우에 발생

   - 그러므로 쓰기 시에 지연된느 사이클은 이 두 가지의 합
<div align="center">
<img src="https://github.com/user-attachments/assets/56d81b43-3d81-4e2a-8058-cfac79c302ca">
</div>

   - 쓰기 버퍼 지연은 쓰는 횟수가 아닌 쓰기의 집중도에 따라 결정되므로, 그 값을 계산할 수 있는 단순한 계산 방법은 존재하지 않음
   - 다행스럽게도 적당한 크기(예를 들어, 4워드 이상)의 쓰기 버퍼와 프로그램 평균 쓰기 빈도보다 충분히 빠르게(예를 들어, 2배) 쓰기를 수행할 수 있는 메모리를 갖고 있는 시스템에서는 쓰기 버퍼 지연이 매우 작으므로 무시 가능
   - 시스템이 이를 만족시키지 못한다면, 설계가 잘못된 것이므로 더 큰 쓰기 버퍼를 사용하거나 나중 쓰기 방식을 사용해야 함
   - 나중 쓰기 방식 또한 블록이 교체될 때 메모리에 써야 하므로 추가적 지연이 발생할 수 있음

6. 대부분 즉시 쓰기 캐시 구현 방식에서 읽기 실패 손실과 쓰기 실패 손실은 같음 (메모리에서 블록을 가져오는 시간)
   - 쓰기 버퍼 지연이 무시할 수 있을 정도로 작다고 가정하면, 같은 실패율과 실패 손실을 써서 읽기와 쓰기를 합칠 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/00c8d0a3-4e5e-48c9-90f9-290922521217">
</div>

7. 예) 캐시 성능의 계산
   - 명령어 캐시 실패율이 2%이고, 데이터 캐시 실패율이 4%라고 가정하며, 메모리 지연이 없을 때 CPI가 2이고, 매 실패마다 실패 손실이 100 사이클일 떄, 실패가 발생하지 않는 완벽한 캐시를 사용한다면 시스템이 얼마나 빨라지는지 계산 (적재와 저장 명령어의 실행 빈도는 36%라 가정)
    - 명령어 개수(I)를 사용하여 명령어에 대한 메모리 실패 사이클 수를 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/55816216-92f5-44af-88e3-d12c96d4b064">
</div>

   - 읽기와 쓰기의 빈도는 36%이므로 데이터 참조에 대한 메모리 실패 사이클 수
<div align="center">
<img src="https://github.com/user-attachments/assets/6e6e60e2-092f-4b49-91ad-5fd4b8f8013b">
</div>

   - 전체 메모리 지연 사이클 수는 2.00 I + 1.44 I = 3.44 I (즉, 평균적으로 명령어 당 3사이클 이상 메모리 지연이 발생한다는 뜻)
   - 따라서 메모리 지연을 포함한 CPI는 2 + 3.44 = 5.44가 됨
   - 명령어 개수와 클럭 속도는 변화가 없으므로, 프로세서 수행 시간의 비율은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/a0d50125-f567-4c55-8a8e-36985e9e38c8">
</div>

   - 즉, 완벽한 캐시가 있으면 성능은 5.44 / 2 = 2.72배 더 좋아짐

8. 프로세서를 더 빠르게 만들고 메모리 시스템은 그대로 둘 경우
   - 메모리 지연에 걸리는 시간이 전체 실행 시간 중 더 큰 부분을 차지하게 될 것
   - 앞의 예제에서 클럭 속도는 변화시키지 않고 CPI만 2에서 1로 줄여 컴퓨터를 더 빠르게 만들었다고 가정할 경우, 파이프라인을 개선하면 이렇게 만들 수 있음
   - 이 때, 캐시 실패가 있는 시스템의 CPI는 1 + 3.44 = 4.44가 되므로, 완벽한 캐시를 갖는 시스템이 4.44 / 1 = 4.44배 빠르게 됨
   - 실행 시간 중 메모리 지연에 쓰인 부분
<div align="center">
<img src="https://github.com/user-attachments/assets/7027b57f-cc9b-4754-aa8d-f1709df18e4e">
</div>

   - 14% 정도 증가하며, 마찬가지로 메모리 시스템 변화 없이 클럭 속도를 증가시키는 것 또한 캐시 실패로 인한 성능 손실을 증가시킴
   - 앞의 예제와 식들은 적중시간이 캐시의 성능을 결정하는 요인이 아니라고 가정하고 있음
     + 하지만 적중시간이 증가한다면, 메모리 시스템에서 한 워드를 접근하는 데 걸리는 전체 시간이 증가할 것이고, 따라서 프로세서 사이클 시간 또한 늘어날 것
     + 적중시간을 증가시키는 이유 중 하나는 캐시 크기의 증가 : 더 큰 캐시는 더 긴 접근 시간을 필요로 함
     + 적중시간이 증가하면 캐시 적중에 두 사이클 이상이 소요되어 파이프라인에 새로운 단계가 추가될 수 있음
     + 단계가 많은 파이프라인이 성능에 미치는 영향을 계산하는 것은 간단하지 않지만, 캐시를 어느 정도 이상 크게 하면 적중률 향상보다 적중시간 증가가 더 큰 영향을 미쳐 프로세서 성능이 나빠지는 것을 알 수 있음

9. 적중과 실패 사이 데이터 접근 시간이 모두 성능에 영향을 미치므로, 메모리 시스템 설계자는 서로 다른 캐시 설계 평가 방법으로 평균 메모리 접근 시간(Average Memory Access Time, AMAT)을 사용
    - 평균 메모리 접근 시간은 적중과 실패를 모두 고려하고 서로 다른 접근의 빈도를 감안하여 구한 메모리 접근의 평균 시간
<div align="center">
<img src="https://github.com/user-attachments/assets/7433b7a8-24b2-458d-8abf-0bef0c95959a">
</div>

10. 예) 평균 메모리 접근시간 계산
    - 클럭 사이클 시간이 1ms이고, 실패 손실이 20클럭, 명령어당 실패율이 0.05, 캐시 적중 검사를 포함한 캐시 접근 시간이 1 클럭 사이클 일 때, 평균 메모리 접근 시간 (읽기와 쓰기의 실패 손실은 같고, 다른 쓰기 지연은 무시)
    - 명령어당 평균 메모리 접근 시간
<div align="center">
<img src="https://github.com/user-attachments/assets/0c53953c-dbc1-4d34-8496-4aa6aba57674">
</div>
