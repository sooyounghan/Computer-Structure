-----
### 캐시 성능 측정 및 향상
-----
1. 캐시 성능을 측정하고 분석하는 방법
   - 2개의 다른 메모리 블록이 캐시의 같은 장소를 두고 경쟁하는 확률을 줄임으로써 실패율을 낮추는 것
   - 메모리 계층 구조에 새로운 계층을 추가함으로써 실패 손실을 줄이는 것 : 다단계 캐싱(Multi-Level Caching)
   - 다단계 캐싱이라고 불리는 이 방식은 1990년도에 고급 컴퓨터에 처음 사용되었으나, 나중에는 개인 휴대용 기기에서도 흔히 볼 수 있음

2. CPU 시간은 CPU가 프로그램을 수행하는 데 쓴 클럭 사이클과 메모리 시스템을 기다리는 데 쓴 클럭 사이클로 나눌 수 있음
   - 일반적으로 적중된 캐시 접근 시간은 정상적인 CPU 수행 사이클의 일부로 간주
<div align="center">
<img src="https://github.com/user-attachments/assets/362b8492-d57f-42d3-8c92-36b46b8182db">
</div>

   - 메모리 지연 클럭 사이클은 주로 캐시 실패 때문에 생김
   - 실제 프로세서에서 읽기와 쓰기 수행 시 발생되는 지연은 상당히 복잡해질 수 있어서, 정확하게 성능을 예측하려면 프로세서와 메모리 시스템의 시뮬레이션이 필요

3. 메모리 지연 클럭 사이클은 읽기와 쓰기 시에 발생하는 지연 사이클의 합으로 정의 : 메모리 지연 클럭 사이클 = 읽기 지연 사이클 + 쓰기 지연 사이클

4. 읽기 지연 사이클은 프로그램 당 읽기 접근의 수, 읽기 시의 실패 손실 클럭 사이클 수, 읽기 실패율에 의해 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/0f22438d-ace3-4772-b37b-fd3645490853">
</div>

5. 쓰기의 경우 복잡함
   - 즉시 쓰기 방식에서 지연의 원인이 두 가지
     + 하나는 쓰기 실패로, 쓰기를 계속 진행하려면 하위 계층 메모리에서 블록을 읽어와야 함
     + 다른 하나는 쓰기 버퍼 지연으로, 쓰려고 할 때 쓰기 버퍼에 빈자리의 경우가 없는 경우에 발생

   - 그러므로 쓰기 시에 지연된느 사이클은 이 두 가지의 합
<div align="center">
<img src="https://github.com/user-attachments/assets/56d81b43-3d81-4e2a-8058-cfac79c302ca">
</div>

   - 쓰기 버퍼 지연은 쓰는 횟수가 아닌 쓰기의 집중도에 따라 결정되므로, 그 값을 계산할 수 있는 단순한 계산 방법은 존재하지 않음
   - 다행스럽게도 적당한 크기(예를 들어, 4워드 이상)의 쓰기 버퍼와 프로그램 평균 쓰기 빈도보다 충분히 빠르게(예를 들어, 2배) 쓰기를 수행할 수 있는 메모리를 갖고 있는 시스템에서는 쓰기 버퍼 지연이 매우 작으므로 무시 가능
   - 시스템이 이를 만족시키지 못한다면, 설계가 잘못된 것이므로 더 큰 쓰기 버퍼를 사용하거나 나중 쓰기 방식을 사용해야 함
   - 나중 쓰기 방식 또한 블록이 교체될 때 메모리에 써야 하므로 추가적 지연이 발생할 수 있음

6. 대부분 즉시 쓰기 캐시 구현 방식에서 읽기 실패 손실과 쓰기 실패 손실은 같음 (메모리에서 블록을 가져오는 시간)
   - 쓰기 버퍼 지연이 무시할 수 있을 정도로 작다고 가정하면, 같은 실패율과 실패 손실을 써서 읽기와 쓰기를 합칠 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/00c8d0a3-4e5e-48c9-90f9-290922521217">
</div>
